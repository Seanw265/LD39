// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime_graphics_GLRenderContext
#include <lime/graphics/GLRenderContext.h>
#endif
#ifndef INCLUDED_lime_graphics_Image
#include <lime/graphics/Image.h>
#endif
#ifndef INCLUDED_lime_graphics_ImageBuffer
#include <lime/graphics/ImageBuffer.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GL
#include <lime/graphics/opengl/GL.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLFramebuffer
#include <lime/graphics/opengl/GLFramebuffer.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLObject
#include <lime/graphics/opengl/GLObject.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLTexture
#include <lime/graphics/opengl/GLTexture.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_AbstractMaskManager
#include <openfl/_internal/renderer/AbstractMaskManager.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_AbstractRenderer
#include <openfl/_internal/renderer/AbstractRenderer.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_RenderSession
#include <openfl/_internal/renderer/RenderSession.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_GLBitmap
#include <openfl/_internal/renderer/opengl/GLBitmap.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_BlendModeManager
#include <openfl/_internal/renderer/opengl/utils/BlendModeManager.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_PingPongTexture
#include <openfl/_internal/renderer/opengl/utils/PingPongTexture.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_RenderTexture
#include <openfl/_internal/renderer/opengl/utils/RenderTexture.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_SpriteBatch
#include <openfl/_internal/renderer/opengl/utils/SpriteBatch.h>
#endif
#ifndef INCLUDED_openfl_display_Bitmap
#include <openfl/display/Bitmap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

namespace openfl{
namespace _internal{
namespace renderer{
namespace opengl{

void GLBitmap_obj::__construct() { }

Dynamic GLBitmap_obj::__CreateEmpty() { return new GLBitmap_obj; }

hx::ObjectPtr< GLBitmap_obj > GLBitmap_obj::__new()
{
	hx::ObjectPtr< GLBitmap_obj > _hx_result = new GLBitmap_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic GLBitmap_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< GLBitmap_obj > _hx_result = new GLBitmap_obj();
	_hx_result->__construct();
	return _hx_result;
}

::Array< ::Dynamic> GLBitmap_obj::fbData;

void GLBitmap_obj::render( ::openfl::display::Bitmap bitmap, ::openfl::_internal::renderer::RenderSession renderSession){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.GLBitmap","render",0x8d0c282c,"openfl._internal.renderer.opengl.GLBitmap.render","openfl/_internal/renderer/opengl/GLBitmap.hx",28,0x02850ac4)
            	HX_STACK_ARG(bitmap,"bitmap")
            	HX_STACK_ARG(renderSession,"renderSession")
HXLINE(  30)		Bool _hx_tmp;
HXDLIN(  30)		Bool _hx_tmp1;
HXDLIN(  30)		Bool _hx_tmp2;
HXDLIN(  30)		if (!(!(bitmap->_hx___renderable))) {
HXLINE(  30)			_hx_tmp2 = (bitmap->_hx___worldAlpha <= (int)0);
            		}
            		else {
HXLINE(  30)			_hx_tmp2 = true;
            		}
HXDLIN(  30)		if (!(_hx_tmp2)) {
HXLINE(  30)			_hx_tmp1 = hx::IsNull( bitmap->bitmapData );
            		}
            		else {
HXLINE(  30)			_hx_tmp1 = true;
            		}
HXDLIN(  30)		if (!(_hx_tmp1)) {
HXLINE(  30)			_hx_tmp = !(bitmap->bitmapData->_hx___isValid);
            		}
            		else {
HXLINE(  30)			_hx_tmp = true;
            		}
HXDLIN(  30)		if (_hx_tmp) {
HXLINE(  30)			return;
            		}
HXLINE(  32)		renderSession->spriteBatch->renderBitmapData(bitmap->bitmapData,bitmap->smoothing,bitmap->_hx___renderTransform,bitmap->_hx___worldColorTransform,bitmap->_hx___worldAlpha,bitmap->_hx___blendMode,bitmap->_hx___shader,bitmap->pixelSnapping,null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GLBitmap_obj,render,(void))

 ::openfl::_internal::renderer::opengl::utils::PingPongTexture GLBitmap_obj::pushFramebuffer( ::openfl::_internal::renderer::RenderSession renderSession, ::openfl::_internal::renderer::opengl::utils::PingPongTexture texture, ::openfl::geom::Rectangle viewPort,Bool smoothing, ::Dynamic __o_transparent, ::Dynamic __o_clearBuffer, ::Dynamic __o_powerOfTwo){
 ::Dynamic transparent = __o_transparent.Default(true);
 ::Dynamic clearBuffer = __o_clearBuffer.Default(false);
 ::Dynamic powerOfTwo = __o_powerOfTwo.Default(true);
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.GLBitmap","pushFramebuffer",0x6b2a8d9d,"openfl._internal.renderer.opengl.GLBitmap.pushFramebuffer","openfl/_internal/renderer/opengl/GLBitmap.hx",44,0x02850ac4)
            	HX_STACK_ARG(renderSession,"renderSession")
            	HX_STACK_ARG(texture,"texture")
            	HX_STACK_ARG(viewPort,"viewPort")
            	HX_STACK_ARG(smoothing,"smoothing")
            	HX_STACK_ARG(transparent,"transparent")
            	HX_STACK_ARG(clearBuffer,"clearBuffer")
            	HX_STACK_ARG(powerOfTwo,"powerOfTwo")
HXLINE(  45)		HX_VARI(  ::lime::graphics::GLRenderContext,gl) = renderSession->gl;
HXLINE(  46)		Bool _hx_tmp = hx::IsNull( gl );
HXDLIN(  46)		if (_hx_tmp) {
HXLINE(  46)			return null();
            		}
HXLINE(  48)		HX_VARI(  ::openfl::_internal::renderer::AbstractRenderer,renderer) = renderSession->renderer;
HXLINE(  49)		HX_VARI(  ::openfl::_internal::renderer::opengl::utils::SpriteBatch,spritebatch) = renderSession->spriteBatch;
HXLINE(  50)		HX_VARI( Int,x) = ::Std_obj::_hx_int(viewPort->x);
HXLINE(  51)		HX_VARI( Int,y) = ::Std_obj::_hx_int(viewPort->y);
HXLINE(  52)		HX_VARI( Int,width) = ::Std_obj::_hx_int(viewPort->width);
HXLINE(  53)		HX_VARI( Int,height) = ::Std_obj::_hx_int(viewPort->height);
HXLINE(  55)		spritebatch->finish();
HXLINE(  58)		Bool _hx_tmp1 = (::openfl::_internal::renderer::opengl::GLBitmap_obj::fbData->length <= (int)0);
HXDLIN(  58)		if (_hx_tmp1) {
HXLINE(  59)			::openfl::_internal::renderer::opengl::GLBitmap_obj::fbData->push( ::Dynamic(hx::Anon_obj::Create(3)
            				->setFixed(0,HX_("viewPort",86,78,7e,87),null())
            				->setFixed(1,HX_("texture",db,c8,e0,9e),null())
            				->setFixed(2,HX_("transparent",52,2b,ba,22),renderer->transparent)));
            		}
HXLINE(  62)		Bool _hx_tmp2 = hx::IsNull( texture );
HXDLIN(  62)		if (_hx_tmp2) {
HXLINE(  63)			texture =  ::openfl::_internal::renderer::opengl::utils::PingPongTexture_obj::__new(gl,width,height,smoothing,powerOfTwo);
            		}
HXLINE(  66)		texture->resize(width,height);
HXLINE(  67)		renderer->transparent = transparent;
HXLINE(  70)		renderSession->maskManager->saveState();
HXLINE(  72)		{
HXLINE(  72)			Int target = gl->FRAMEBUFFER;
HXDLIN(  72)			 ::openfl::_internal::renderer::opengl::utils::RenderTexture _hx_tmp3;
HXDLIN(  72)			if (texture->_hx___swapped) {
HXLINE(  72)				_hx_tmp3 = texture->_hx___texture1;
            			}
            			else {
HXLINE(  72)				_hx_tmp3 = texture->_hx___texture0;
            			}
HXDLIN(  72)			HX_VARI(  ::lime::graphics::opengl::GLFramebuffer,framebuffer) = _hx_tmp3->frameBuffer;
HXDLIN(  72)			{
HXLINE(  72)				Int framebuffer1;
HXDLIN(  72)				Bool _hx_tmp4 = hx::IsNull( framebuffer );
HXDLIN(  72)				if (_hx_tmp4) {
HXLINE(  72)					framebuffer1 = (int)0;
            				}
            				else {
HXLINE(  72)					framebuffer1 = framebuffer->id;
            				}
HXDLIN(  72)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_bind_framebuffer(target,framebuffer1);
            			}
            		}
HXLINE(  73)		renderer->setViewport(x,y,width,height);
HXLINE(  76)		::lime::graphics::opengl::GL_obj::cffi_lime_gl_color_mask(true,true,true,true);
HXLINE(  77)		renderSession->blendModeManager->setBlendMode((int)10,null());
HXLINE(  79)		if (clearBuffer) {
HXLINE(  80)			 ::openfl::_internal::renderer::opengl::utils::RenderTexture _hx_tmp5;
HXDLIN(  80)			if (texture->_hx___swapped) {
HXLINE(  80)				_hx_tmp5 = texture->_hx___texture1;
            			}
            			else {
HXLINE(  80)				_hx_tmp5 = texture->_hx___texture0;
            			}
HXDLIN(  80)			_hx_tmp5->clear((int)0,(int)0,(int)0,(int)0,null());
            		}
HXLINE(  83)		::openfl::_internal::renderer::opengl::GLBitmap_obj::fbData->push( ::Dynamic(hx::Anon_obj::Create(3)
            			->setFixed(0,HX_("viewPort",86,78,7e,87),viewPort)
            			->setFixed(1,HX_("texture",db,c8,e0,9e),texture)
            			->setFixed(2,HX_("transparent",52,2b,ba,22),transparent)));
HXLINE(  85)		return texture;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(GLBitmap_obj,pushFramebuffer,return )

void GLBitmap_obj::drawBitmapDrawable( ::openfl::_internal::renderer::RenderSession renderSession, ::openfl::display::BitmapData target,::Dynamic source, ::openfl::geom::Matrix matrix, ::openfl::geom::ColorTransform colorTransform, ::Dynamic blendMode, ::openfl::geom::Rectangle clipRect){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.GLBitmap","drawBitmapDrawable",0x975da3a7,"openfl._internal.renderer.opengl.GLBitmap.drawBitmapDrawable","openfl/_internal/renderer/opengl/GLBitmap.hx",98,0x02850ac4)
            	HX_STACK_ARG(renderSession,"renderSession")
            	HX_STACK_ARG(target,"target")
            	HX_STACK_ARG(source,"source")
            	HX_STACK_ARG(matrix,"matrix")
            	HX_STACK_ARG(colorTransform,"colorTransform")
            	HX_STACK_ARG(blendMode,"blendMode")
            	HX_STACK_ARG(clipRect,"clipRect")
HXLINE(  99)		HX_VARI(  ::Dynamic,data) = ::openfl::_internal::renderer::opengl::GLBitmap_obj::fbData->__get((::openfl::_internal::renderer::opengl::GLBitmap_obj::fbData->length - (int)1));
HXLINE( 100)		Bool _hx_tmp = hx::IsNull( data );
HXDLIN( 100)		if (_hx_tmp) {
HXLINE( 100)			HX_STACK_DO_THROW(HX_("No data to draw to",e9,c0,1f,99));
            		}
HXLINE( 103)		Bool _hx_tmp1 = hx::IsNull( renderSession->gl );
HXDLIN( 103)		if (_hx_tmp1) {
HXLINE( 103)			return;
            		}
HXLINE( 105)		HX_VARI(  ::openfl::geom::Rectangle,viewPort) = ( ( ::openfl::geom::Rectangle)(data->__Field(HX_("viewPort",86,78,7e,87),hx::paccDynamic)) );
HXLINE( 107)		HX_VARI(  ::openfl::_internal::renderer::opengl::utils::SpriteBatch,spritebatch) = renderSession->spriteBatch;
HXLINE( 108)		HX_VARI( Bool,drawTarget) = hx::IsNotNull( target );
HXLINE( 110)		HX_VAR(  ::openfl::geom::Rectangle,tmpRect);
HXDLIN( 110)		Bool _hx_tmp2 = hx::IsNull( clipRect );
HXDLIN( 110)		if (_hx_tmp2) {
HXLINE( 110)			tmpRect =  ::openfl::geom::Rectangle_obj::__new(viewPort->x,viewPort->y,viewPort->width,viewPort->height);
            		}
            		else {
HXLINE( 110)			tmpRect = clipRect->clone();
            		}
HXLINE( 112)		 ::openfl::geom::Rectangle _hx_tmp3;
HXDLIN( 112)		if (drawTarget) {
HXLINE( 112)			_hx_tmp3 = null();
            		}
            		else {
HXLINE( 112)			_hx_tmp3 = tmpRect;
            		}
HXDLIN( 112)		spritebatch->begin(renderSession,_hx_tmp3);
HXLINE( 114)		if (drawTarget) {
HXLINE( 116)			target->_hx___worldTransform->identity();
HXLINE( 117)			{
HXLINE( 117)				HX_VARI(  ::openfl::geom::Matrix,m) = target->_hx___worldTransform;
HXDLIN( 117)				Float height = viewPort->height;
HXDLIN( 117)				HX_VARI( Float,tx) = m->tx;
HXDLIN( 117)				HX_VARI( Float,ty) = m->ty;
HXDLIN( 117)				m->tx = (int)0;
HXDLIN( 117)				m->ty = (int)0;
HXDLIN( 117)				m->scale((int)1,(int)-1);
HXDLIN( 117)				m->translate((int)0,height);
HXDLIN( 117)				hx::AddEq(m->tx,tx);
HXDLIN( 117)				hx::SubEq(m->ty,ty);
            			}
HXLINE( 118)			target->_hx___renderGL(renderSession);
HXLINE( 119)			spritebatch->stop();
HXLINE( 120)			Bool _hx_tmp4 = hx::IsNotNull( target->_hx___texture );
HXDLIN( 120)			if (_hx_tmp4) {
HXLINE( 120)				HX_VARI(  ::lime::graphics::opengl::GLTexture,texture) = target->_hx___texture;
HXDLIN( 120)				{
HXLINE( 120)					{
HXLINE( 120)						Int texture1 = ( (Int)(texture->id) );
HXDLIN( 120)						::lime::graphics::opengl::GL_obj::cffi_lime_gl_delete_texture(texture1);
            					}
HXDLIN( 120)					texture->invalidate();
            				}
            			}
HXLINE( 121)			target->_hx___texture = null();
HXLINE( 122)			spritebatch->start(tmpRect);
            		}
HXLINE( 126)		HX_VARI(  ::openfl::geom::ColorTransform,ctCache) = ( ( ::openfl::geom::ColorTransform)(source->__Field(HX_("__worldColorTransform",5b,ce,21,a3),hx::paccDynamic)) );
HXLINE( 127)		HX_VARI(  ::Dynamic,blendModeCache) = source->__Field(HX_("__blendMode",34,2d,64,3a),hx::paccDynamic);
HXLINE( 128)		HX_VARI( Bool,cached) = ( (Bool)(source->__Field(HX_("__cacheAsBitmap",c3,bb,c1,f1),hx::paccDynamic)) );
HXLINE( 130)		HX_VAR_NAME(  ::openfl::geom::Matrix,m1,"m");
HXDLIN( 130)		Bool _hx_tmp5 = hx::IsNotNull( matrix );
HXDLIN( 130)		if (_hx_tmp5) {
HXLINE( 130)			m1 = matrix->clone();
            		}
            		else {
HXLINE( 130)			m1 =  ::openfl::geom::Matrix_obj::__new(null(),null(),null(),null(),null(),null());
            		}
HXLINE( 132)		{
HXLINE( 132)			Float height1 = viewPort->height;
HXDLIN( 132)			HX_VARI_NAME( Float,tx1,"tx") = m1->tx;
HXDLIN( 132)			HX_VARI_NAME( Float,ty1,"ty") = m1->ty;
HXDLIN( 132)			m1->tx = (int)0;
HXDLIN( 132)			m1->ty = (int)0;
HXDLIN( 132)			m1->scale((int)1,(int)-1);
HXDLIN( 132)			m1->translate((int)0,height1);
HXDLIN( 132)			hx::AddEq(m1->tx,tx1);
HXDLIN( 132)			hx::SubEq(m1->ty,ty1);
            		}
HXLINE( 134)		 ::openfl::geom::ColorTransform _hx_tmp6;
HXDLIN( 134)		Bool _hx_tmp7 = hx::IsNotNull( colorTransform );
HXDLIN( 134)		if (_hx_tmp7) {
HXLINE( 134)			_hx_tmp6 = colorTransform;
            		}
            		else {
HXLINE( 134)			_hx_tmp6 =  ::openfl::geom::ColorTransform_obj::__new(null(),null(),null(),null(),null(),null(),null(),null());
            		}
HXDLIN( 134)		source->__SetField(HX_("__worldColorTransform",5b,ce,21,a3),_hx_tmp6,hx::paccDynamic);
HXLINE( 135)		source->__SetField(HX_("__blendMode",34,2d,64,3a),blendMode,hx::paccDynamic);
HXLINE( 136)		::openfl::display::DisplayObject_obj::_hx___cacheAsBitmapMode = true;
HXLINE( 138)		::openfl::display::IBitmapDrawable_obj::_hx___updateTransforms(source,m1);
HXLINE( 139)		::openfl::display::IBitmapDrawable_obj::_hx___updateChildren(source,false);
HXLINE( 141)		source->__SetField(HX_("__cacheAsBitmap",c3,bb,c1,f1),false,hx::paccDynamic);
HXLINE( 142)		::openfl::display::IBitmapDrawable_obj::_hx___renderGL(source,renderSession);
HXLINE( 143)		source->__SetField(HX_("__cacheAsBitmap",c3,bb,c1,f1),cached,hx::paccDynamic);
HXLINE( 145)		source->__SetField(HX_("__worldColorTransform",5b,ce,21,a3),ctCache,hx::paccDynamic);
HXLINE( 146)		source->__SetField(HX_("__blendMode",34,2d,64,3a),blendModeCache,hx::paccDynamic);
HXLINE( 147)		::openfl::display::DisplayObject_obj::_hx___cacheAsBitmapMode = false;
HXLINE( 149)		::openfl::display::IBitmapDrawable_obj::_hx___updateTransforms(source,null());
HXLINE( 150)		::openfl::display::IBitmapDrawable_obj::_hx___updateChildren(source,false);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(GLBitmap_obj,drawBitmapDrawable,(void))

void GLBitmap_obj::popFramebuffer( ::openfl::_internal::renderer::RenderSession renderSession, ::lime::graphics::Image image){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.GLBitmap","popFramebuffer",0x655209b2,"openfl._internal.renderer.opengl.GLBitmap.popFramebuffer","openfl/_internal/renderer/opengl/GLBitmap.hx",160,0x02850ac4)
            	HX_STACK_ARG(renderSession,"renderSession")
            	HX_STACK_ARG(image,"image")
HXLINE( 161)		HX_VARI(  ::lime::graphics::GLRenderContext,gl) = renderSession->gl;
HXLINE( 162)		Bool _hx_tmp = hx::IsNull( gl );
HXDLIN( 162)		if (_hx_tmp) {
HXLINE( 162)			return;
            		}
HXLINE( 164)		renderSession->spriteBatch->finish();
HXLINE( 167)		::openfl::_internal::renderer::opengl::GLBitmap_obj::fbData->pop();
HXLINE( 168)		HX_VARI(  ::Dynamic,data) = ::openfl::_internal::renderer::opengl::GLBitmap_obj::fbData->__get((::openfl::_internal::renderer::opengl::GLBitmap_obj::fbData->length - (int)1));
HXLINE( 169)		Bool _hx_tmp1 = hx::IsNull( data );
HXDLIN( 169)		if (_hx_tmp1) {
HXLINE( 170)			HX_STACK_DO_THROW(HX_("oh",19,61,00,00));
            		}
HXLINE( 173)		HX_VAR( Int,x);
HXDLIN( 173)		HX_VAR( Int,y);
HXDLIN( 173)		HX_VAR( Int,width);
HXDLIN( 173)		HX_VAR( Int,height);
HXLINE( 175)		Bool _hx_tmp2 = hx::IsNull( ( ( ::openfl::geom::Rectangle)(data->__Field(HX_("viewPort",86,78,7e,87),hx::paccDynamic)) ) );
HXDLIN( 175)		if (_hx_tmp2) {
HXLINE( 176)			y = (int)0;
HXDLIN( 176)			x = (int)0;
HXLINE( 177)			width = renderSession->renderer->width;
HXLINE( 178)			height = renderSession->renderer->height;
            		}
            		else {
HXLINE( 180)			x = ::Math_obj::floor(( ( ::openfl::geom::Rectangle)(data->__Field(HX_("viewPort",86,78,7e,87),hx::paccDynamic)) )->x);
HXLINE( 181)			y = ::Math_obj::floor(( ( ::openfl::geom::Rectangle)(data->__Field(HX_("viewPort",86,78,7e,87),hx::paccDynamic)) )->y);
HXLINE( 182)			width = ::Math_obj::ceil(( ( ::openfl::geom::Rectangle)(data->__Field(HX_("viewPort",86,78,7e,87),hx::paccDynamic)) )->width);
HXLINE( 183)			height = ::Math_obj::ceil(( ( ::openfl::geom::Rectangle)(data->__Field(HX_("viewPort",86,78,7e,87),hx::paccDynamic)) )->height);
            		}
HXLINE( 186)		Bool _hx_tmp3 = hx::IsNotNull( image );
HXDLIN( 186)		if (_hx_tmp3) {
HXLINE( 189)			Bool _hx_tmp4;
HXDLIN( 189)			if ((image->width == width)) {
HXLINE( 189)				_hx_tmp4 = (image->height != height);
            			}
            			else {
HXLINE( 189)				_hx_tmp4 = true;
            			}
HXDLIN( 189)			if (_hx_tmp4) {
HXLINE( 191)				image->resize(width,height);
            			}
HXLINE( 195)			{
HXLINE( 195)				Int format = gl->RGBA;
HXDLIN( 195)				Int type = gl->UNSIGNED_BYTE;
HXDLIN( 195)				HX_VARI(  ::lime::utils::ArrayBufferView,pixels) = image->buffer->data;
HXDLIN( 195)				{
HXLINE( 195)					HX_VAR(  ::haxe::io::Bytes,buffer);
HXDLIN( 195)					Bool _hx_tmp5 = hx::IsNull( pixels );
HXDLIN( 195)					if (_hx_tmp5) {
HXLINE( 195)						buffer = null();
            					}
            					else {
HXLINE( 195)						buffer = pixels->buffer;
            					}
HXDLIN( 195)					{
HXLINE( 195)						Int byteOffset;
HXDLIN( 195)						Bool _hx_tmp6 = hx::IsNull( pixels );
HXDLIN( 195)						if (_hx_tmp6) {
HXLINE( 195)							byteOffset = (int)0;
            						}
            						else {
HXLINE( 195)							byteOffset = pixels->byteOffset;
            						}
HXDLIN( 195)						::lime::graphics::opengl::GL_obj::cffi_lime_gl_read_pixels(x,y,width,height,format,type,hx::DynamicPtr(buffer),byteOffset);
            					}
            				}
            			}
HXLINE( 197)			image->dirty = false;
HXLINE( 198)			image->set_premultiplied(true);
            		}
HXLINE( 202)		{
HXLINE( 202)			Int target = gl->FRAMEBUFFER;
HXDLIN( 202)			HX_VAR(  ::lime::graphics::opengl::GLFramebuffer,framebuffer);
HXDLIN( 202)			Bool _hx_tmp7 = hx::IsNull( ( ( ::openfl::_internal::renderer::opengl::utils::PingPongTexture)(data->__Field(HX_("texture",db,c8,e0,9e),hx::paccDynamic)) ) );
HXDLIN( 202)			if (_hx_tmp7) {
HXLINE( 202)				framebuffer = renderSession->defaultFramebuffer;
            			}
            			else {
HXLINE( 202)				HX_VARI(  ::openfl::_internal::renderer::opengl::utils::PingPongTexture,_this) = ( ( ::openfl::_internal::renderer::opengl::utils::PingPongTexture)(data->__Field(HX_("texture",db,c8,e0,9e),hx::paccDynamic)) );
HXDLIN( 202)				 ::openfl::_internal::renderer::opengl::utils::RenderTexture _hx_tmp8;
HXDLIN( 202)				if (_this->_hx___swapped) {
HXLINE( 202)					_hx_tmp8 = _this->_hx___texture1;
            				}
            				else {
HXLINE( 202)					_hx_tmp8 = _this->_hx___texture0;
            				}
HXDLIN( 202)				framebuffer = _hx_tmp8->frameBuffer;
            			}
HXDLIN( 202)			{
HXLINE( 202)				Int framebuffer1;
HXDLIN( 202)				Bool _hx_tmp9 = hx::IsNull( framebuffer );
HXDLIN( 202)				if (_hx_tmp9) {
HXLINE( 202)					framebuffer1 = (int)0;
            				}
            				else {
HXLINE( 202)					framebuffer1 = framebuffer->id;
            				}
HXDLIN( 202)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_bind_framebuffer(target,framebuffer1);
            			}
            		}
HXLINE( 203)		renderSession->renderer->setViewport(x,y,width,height);
HXLINE( 204)		renderSession->renderer->transparent = ( (Bool)(data->__Field(HX_("transparent",52,2b,ba,22),hx::paccDynamic)) );
HXLINE( 207)		renderSession->maskManager->restoreState();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GLBitmap_obj,popFramebuffer,(void))

void GLBitmap_obj::flipMatrix( ::openfl::geom::Matrix m,Float height){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.GLBitmap","flipMatrix",0xe0a65ca4,"openfl._internal.renderer.opengl.GLBitmap.flipMatrix","openfl/_internal/renderer/opengl/GLBitmap.hx",211,0x02850ac4)
            	HX_STACK_ARG(m,"m")
            	HX_STACK_ARG(height,"height")
HXLINE( 213)		HX_VARI( Float,tx) = m->tx;
HXLINE( 214)		HX_VARI( Float,ty) = m->ty;
HXLINE( 215)		m->tx = (int)0;
HXLINE( 216)		m->ty = (int)0;
HXLINE( 217)		m->scale((int)1,(int)-1);
HXLINE( 218)		m->translate((int)0,height);
HXLINE( 219)		hx::AddEq(m->tx,tx);
HXLINE( 220)		hx::SubEq(m->ty,ty);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GLBitmap_obj,flipMatrix,(void))


GLBitmap_obj::GLBitmap_obj()
{
}

bool GLBitmap_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"fbData") ) { outValue = fbData; return true; }
		if (HX_FIELD_EQ(inName,"render") ) { outValue = render_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"flipMatrix") ) { outValue = flipMatrix_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"popFramebuffer") ) { outValue = popFramebuffer_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"pushFramebuffer") ) { outValue = pushFramebuffer_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"drawBitmapDrawable") ) { outValue = drawBitmapDrawable_dyn(); return true; }
	}
	return false;
}

bool GLBitmap_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"fbData") ) { fbData=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *GLBitmap_obj_sMemberStorageInfo = 0;
static hx::StaticInfo GLBitmap_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*cpp::ArrayBase*/ ,(void *) &GLBitmap_obj::fbData,HX_HCSTRING("fbData","\x86","\x29","\xe8","\x62")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void GLBitmap_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(GLBitmap_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(GLBitmap_obj::fbData,"fbData");
};

#ifdef HXCPP_VISIT_ALLOCS
static void GLBitmap_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(GLBitmap_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(GLBitmap_obj::fbData,"fbData");
};

#endif

hx::Class GLBitmap_obj::__mClass;

static ::String GLBitmap_obj_sStaticFields[] = {
	HX_HCSTRING("fbData","\x86","\x29","\xe8","\x62"),
	HX_HCSTRING("render","\x56","\x6b","\x29","\x05"),
	HX_HCSTRING("pushFramebuffer","\x33","\x95","\x04","\x91"),
	HX_HCSTRING("drawBitmapDrawable","\xd1","\xfd","\x67","\x19"),
	HX_HCSTRING("popFramebuffer","\xdc","\x86","\x85","\x8c"),
	HX_HCSTRING("flipMatrix","\xce","\x7c","\xf5","\x32"),
	::String(null())
};

void GLBitmap_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl._internal.renderer.opengl.GLBitmap","\xd8","\x64","\xbd","\x49");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &GLBitmap_obj::__GetStatic;
	__mClass->mSetStaticField = &GLBitmap_obj::__SetStatic;
	__mClass->mMarkFunc = GLBitmap_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(GLBitmap_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< GLBitmap_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = GLBitmap_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = GLBitmap_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = GLBitmap_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void GLBitmap_obj::__boot()
{
{
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.GLBitmap","boot",0x13d83f88,"openfl._internal.renderer.opengl.GLBitmap.boot","openfl/_internal/renderer/opengl/GLBitmap.hx",26,0x02850ac4)
HXLINE(  26)		fbData = ::Array_obj< ::Dynamic>::__new(0);
            	}
}

} // end namespace openfl
} // end namespace _internal
} // end namespace renderer
} // end namespace opengl
