// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_lime_graphics_GLRenderContext
#include <lime/graphics/GLRenderContext.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_AbstractMaskManager
#include <openfl/_internal/renderer/AbstractMaskManager.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_AbstractRenderer
#include <openfl/_internal/renderer/AbstractRenderer.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_RenderSession
#include <openfl/_internal/renderer/RenderSession.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_GLMaskManager
#include <openfl/_internal/renderer/opengl/utils/GLMaskManager.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_SpriteBatch
#include <openfl/_internal/renderer/opengl/utils/SpriteBatch.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_StencilManager
#include <openfl/_internal/renderer/opengl/utils/StencilManager.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

namespace openfl{
namespace _internal{
namespace renderer{
namespace opengl{
namespace utils{

void GLMaskManager_obj::__construct( ::openfl::_internal::renderer::RenderSession renderSession){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.GLMaskManager","new",0xe472edcd,"openfl._internal.renderer.opengl.utils.GLMaskManager.new","openfl/_internal/renderer/opengl/utils/GLMaskManager.hx",22,0xb5eaf726)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(renderSession,"renderSession")
HXLINE(  24)		super::__construct(renderSession);
HXLINE(  26)		this->setContext(renderSession->gl);
HXLINE(  28)		this->clips = ::Array_obj< ::Dynamic>::__new(0);
            	}

Dynamic GLMaskManager_obj::__CreateEmpty() { return new GLMaskManager_obj; }

hx::ObjectPtr< GLMaskManager_obj > GLMaskManager_obj::__new( ::openfl::_internal::renderer::RenderSession renderSession)
{
	hx::ObjectPtr< GLMaskManager_obj > _hx_result = new GLMaskManager_obj();
	_hx_result->__construct(renderSession);
	return _hx_result;
}

Dynamic GLMaskManager_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< GLMaskManager_obj > _hx_result = new GLMaskManager_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

void GLMaskManager_obj::destroy(){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.GLMaskManager","destroy",0x65a504e7,"openfl._internal.renderer.opengl.utils.GLMaskManager.destroy","openfl/_internal/renderer/opengl/utils/GLMaskManager.hx",35,0xb5eaf726)
            	HX_STACK_THIS(this)
HXLINE(  35)		this->gl = null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(GLMaskManager_obj,destroy,(void))

void GLMaskManager_obj::pushRect( ::openfl::geom::Rectangle rect, ::openfl::geom::Matrix transform){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.GLMaskManager","pushRect",0xd4769791,"openfl._internal.renderer.opengl.utils.GLMaskManager.pushRect","openfl/_internal/renderer/opengl/utils/GLMaskManager.hx",40,0xb5eaf726)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(rect,"rect")
            	HX_STACK_ARG(transform,"transform")
HXLINE(  42)		Bool _hx_tmp = hx::IsNull( rect );
HXDLIN(  42)		if (_hx_tmp) {
HXLINE(  42)			return;
            		}
HXLINE(  44)		HX_VARI(  ::openfl::geom::Matrix,m) = transform->clone();
HXLINE(  46)		{
HXLINE(  46)			Float height = this->renderSession->renderer->viewport->height;
HXDLIN(  46)			HX_VARI( Float,tx) = m->tx;
HXDLIN(  46)			HX_VARI( Float,ty) = m->ty;
HXDLIN(  46)			m->tx = (int)0;
HXDLIN(  46)			m->ty = (int)0;
HXDLIN(  46)			m->scale((int)1,(int)-1);
HXDLIN(  46)			m->translate((int)0,height);
HXDLIN(  46)			hx::AddEq(m->tx,tx);
HXDLIN(  46)			hx::SubEq(m->ty,ty);
            		}
HXLINE(  47)		HX_VARI(  ::openfl::geom::Rectangle,clip) = rect->clone();
HXLINE(  48)		clip->_hx___transform(clip,m);
HXLINE(  50)		Bool _hx_tmp1 = hx::IsNotNull( this->currentClip );
HXDLIN(  50)		if (_hx_tmp1) {
HXLINE(  52)			clip = this->currentClip->intersection(clip);
            		}
HXLINE(  56)		HX_VAR( Bool,restartBatch);
HXDLIN(  56)		Bool _hx_tmp2;
HXDLIN(  56)		Bool _hx_tmp3 = hx::IsNotNull( this->currentClip );
HXDLIN(  56)		if (_hx_tmp3) {
HXLINE(  56)			_hx_tmp2 = clip->isEmpty();
            		}
            		else {
HXLINE(  56)			_hx_tmp2 = true;
            		}
HXDLIN(  56)		if (!(_hx_tmp2)) {
HXLINE(  56)			restartBatch = this->currentClip->containsRect(clip);
            		}
            		else {
HXLINE(  56)			restartBatch = true;
            		}
HXLINE(  58)		this->clips->push(clip);
HXLINE(  59)		this->currentClip = clip;
HXLINE(  61)		if (restartBatch) {
HXLINE(  63)			this->renderSession->spriteBatch->stop();
HXLINE(  64)			this->renderSession->spriteBatch->start(this->currentClip);
            		}
            	}


void GLMaskManager_obj::pushMask( ::openfl::display::DisplayObject mask){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.GLMaskManager","pushMask",0xd1258b59,"openfl._internal.renderer.opengl.utils.GLMaskManager.pushMask","openfl/_internal/renderer/opengl/utils/GLMaskManager.hx",71,0xb5eaf726)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(mask,"mask")
HXLINE(  73)		this->renderSession->spriteBatch->stop();
HXLINE(  74)		this->renderSession->stencilManager->pushMask(mask,this->renderSession);
HXLINE(  75)		this->renderSession->spriteBatch->start(this->currentClip);
            	}


void GLMaskManager_obj::popMask(){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.GLMaskManager","popMask",0x84303f0a,"openfl._internal.renderer.opengl.utils.GLMaskManager.popMask","openfl/_internal/renderer/opengl/utils/GLMaskManager.hx",80,0xb5eaf726)
            	HX_STACK_THIS(this)
HXLINE(  82)		this->renderSession->spriteBatch->stop();
HXLINE(  83)		this->renderSession->stencilManager->popMask(null(),this->renderSession);
HXLINE(  84)		this->renderSession->spriteBatch->start(this->currentClip);
            	}


void GLMaskManager_obj::popRect(){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.GLMaskManager","popRect",0x87814b42,"openfl._internal.renderer.opengl.utils.GLMaskManager.popRect","openfl/_internal/renderer/opengl/utils/GLMaskManager.hx",88,0xb5eaf726)
            	HX_STACK_THIS(this)
HXLINE(  90)		this->renderSession->spriteBatch->stop();
HXLINE(  92)		this->clips->pop().StaticCast<  ::openfl::geom::Rectangle >();
HXLINE(  93)		Int _hx_tmp = (this->clips->length - (int)1);
HXDLIN(  93)		this->currentClip = this->clips->__get(_hx_tmp).StaticCast<  ::openfl::geom::Rectangle >();
HXLINE(  95)		this->renderSession->spriteBatch->start(this->currentClip);
            	}


void GLMaskManager_obj::saveState(){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.GLMaskManager","saveState",0xfb2eeac1,"openfl._internal.renderer.opengl.utils.GLMaskManager.saveState","openfl/_internal/renderer/opengl/utils/GLMaskManager.hx",99,0xb5eaf726)
            	HX_STACK_THIS(this)
HXLINE( 101)		this->savedClip = this->currentClip;
HXLINE( 102)		this->currentClip = null();
            	}


void GLMaskManager_obj::restoreState(){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.GLMaskManager","restoreState",0x4fd390d6,"openfl._internal.renderer.opengl.utils.GLMaskManager.restoreState","openfl/_internal/renderer/opengl/utils/GLMaskManager.hx",106,0xb5eaf726)
            	HX_STACK_THIS(this)
HXLINE( 108)		this->currentClip = this->savedClip;
HXLINE( 109)		this->savedClip = null();
            	}


void GLMaskManager_obj::setContext( ::lime::graphics::GLRenderContext gl){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.GLMaskManager","setContext",0xeb7fd4a0,"openfl._internal.renderer.opengl.utils.GLMaskManager.setContext","openfl/_internal/renderer/opengl/utils/GLMaskManager.hx",114,0xb5eaf726)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(gl,"gl")
HXLINE( 116)		Bool _hx_tmp = hx::IsNotNull( this->renderSession );
HXDLIN( 116)		if (_hx_tmp) {
HXLINE( 118)			this->renderSession->gl = gl;
            		}
HXLINE( 122)		this->gl = gl;
            	}


HX_DEFINE_DYNAMIC_FUNC1(GLMaskManager_obj,setContext,(void))


GLMaskManager_obj::GLMaskManager_obj()
{
}

void GLMaskManager_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(GLMaskManager);
	HX_MARK_MEMBER_NAME(gl,"gl");
	HX_MARK_MEMBER_NAME(clips,"clips");
	HX_MARK_MEMBER_NAME(currentClip,"currentClip");
	HX_MARK_MEMBER_NAME(savedClip,"savedClip");
	 ::openfl::_internal::renderer::AbstractMaskManager_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void GLMaskManager_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(gl,"gl");
	HX_VISIT_MEMBER_NAME(clips,"clips");
	HX_VISIT_MEMBER_NAME(currentClip,"currentClip");
	HX_VISIT_MEMBER_NAME(savedClip,"savedClip");
	 ::openfl::_internal::renderer::AbstractMaskManager_obj::__Visit(HX_VISIT_ARG);
}

hx::Val GLMaskManager_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { return hx::Val( gl); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"clips") ) { return hx::Val( clips); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"destroy") ) { return hx::Val( destroy_dyn()); }
		if (HX_FIELD_EQ(inName,"popMask") ) { return hx::Val( popMask_dyn()); }
		if (HX_FIELD_EQ(inName,"popRect") ) { return hx::Val( popRect_dyn()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"pushRect") ) { return hx::Val( pushRect_dyn()); }
		if (HX_FIELD_EQ(inName,"pushMask") ) { return hx::Val( pushMask_dyn()); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"savedClip") ) { return hx::Val( savedClip); }
		if (HX_FIELD_EQ(inName,"saveState") ) { return hx::Val( saveState_dyn()); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"setContext") ) { return hx::Val( setContext_dyn()); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"currentClip") ) { return hx::Val( currentClip); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"restoreState") ) { return hx::Val( restoreState_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val GLMaskManager_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { gl=inValue.Cast<  ::lime::graphics::GLRenderContext >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"clips") ) { clips=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"savedClip") ) { savedClip=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"currentClip") ) { currentClip=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void GLMaskManager_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("gl","\x25","\x5a","\x00","\x00"));
	outFields->push(HX_HCSTRING("clips","\xa3","\x87","\x5e","\x48"));
	outFields->push(HX_HCSTRING("currentClip","\xa9","\x47","\x54","\x7a"));
	outFields->push(HX_HCSTRING("savedClip","\xf7","\x34","\x2d","\xbc"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo GLMaskManager_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::lime::graphics::GLRenderContext*/ ,(int)offsetof(GLMaskManager_obj,gl),HX_HCSTRING("gl","\x25","\x5a","\x00","\x00")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(GLMaskManager_obj,clips),HX_HCSTRING("clips","\xa3","\x87","\x5e","\x48")},
	{hx::fsObject /*::openfl::geom::Rectangle*/ ,(int)offsetof(GLMaskManager_obj,currentClip),HX_HCSTRING("currentClip","\xa9","\x47","\x54","\x7a")},
	{hx::fsObject /*::openfl::geom::Rectangle*/ ,(int)offsetof(GLMaskManager_obj,savedClip),HX_HCSTRING("savedClip","\xf7","\x34","\x2d","\xbc")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *GLMaskManager_obj_sStaticStorageInfo = 0;
#endif

static ::String GLMaskManager_obj_sMemberFields[] = {
	HX_HCSTRING("gl","\x25","\x5a","\x00","\x00"),
	HX_HCSTRING("clips","\xa3","\x87","\x5e","\x48"),
	HX_HCSTRING("currentClip","\xa9","\x47","\x54","\x7a"),
	HX_HCSTRING("savedClip","\xf7","\x34","\x2d","\xbc"),
	HX_HCSTRING("destroy","\xfa","\x2c","\x86","\x24"),
	HX_HCSTRING("pushRect","\x1e","\x80","\x98","\x1a"),
	HX_HCSTRING("pushMask","\xe6","\x73","\x47","\x17"),
	HX_HCSTRING("popMask","\x1d","\x67","\x11","\x43"),
	HX_HCSTRING("popRect","\x55","\x73","\x62","\x46"),
	HX_HCSTRING("saveState","\x94","\x7d","\xb8","\x12"),
	HX_HCSTRING("restoreState","\xe3","\x43","\x89","\xe0"),
	HX_HCSTRING("setContext","\x6d","\xba","\x56","\x6c"),
	::String(null()) };

static void GLMaskManager_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(GLMaskManager_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void GLMaskManager_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(GLMaskManager_obj::__mClass,"__mClass");
};

#endif

hx::Class GLMaskManager_obj::__mClass;

void GLMaskManager_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl._internal.renderer.opengl.utils.GLMaskManager","\x5b","\x03","\x03","\xef");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = GLMaskManager_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(GLMaskManager_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< GLMaskManager_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = GLMaskManager_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = GLMaskManager_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = GLMaskManager_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace openfl
} // end namespace _internal
} // end namespace renderer
} // end namespace opengl
} // end namespace utils
