// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime_graphics_GLRenderContext
#include <lime/graphics/GLRenderContext.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GL
#include <lime/graphics/opengl/GL.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLBuffer
#include <lime/graphics/opengl/GLBuffer.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLObject
#include <lime/graphics/opengl/GLObject.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLTexture
#include <lime/graphics/opengl/GLTexture.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif
#ifndef INCLUDED_lime_utils_TAError
#include <lime/utils/TAError.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_RenderSession
#include <openfl/_internal/renderer/RenderSession.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_shaders2_DefaultShader
#include <openfl/_internal/renderer/opengl/shaders2/DefaultShader.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_shaders2_Shader
#include <openfl/_internal/renderer/opengl/shaders2/Shader.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_BlendModeManager
#include <openfl/_internal/renderer/opengl/utils/BlendModeManager.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_PingPongTexture
#include <openfl/_internal/renderer/opengl/utils/PingPongTexture.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_RenderTexture
#include <openfl/_internal/renderer/opengl/utils/RenderTexture.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_ShaderManager
#include <openfl/_internal/renderer/opengl/utils/ShaderManager.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_SpriteBatch
#include <openfl/_internal/renderer/opengl/utils/SpriteBatch.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_VertexArray
#include <openfl/_internal/renderer/opengl/utils/VertexArray.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_VertexAttribute
#include <openfl/_internal/renderer/opengl/utils/VertexAttribute.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils__SpriteBatch_State
#include <openfl/_internal/renderer/opengl/utils/_SpriteBatch/State.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_GLShaderParameter
#include <openfl/display/GLShaderParameter.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_TextureUvs
#include <openfl/display/TextureUvs.h>
#endif
#ifndef INCLUDED_openfl_display_Tilesheet
#include <openfl/display/Tilesheet.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

static const Int _hx_array_data_2[] = {
	(Int)1,(Int)1,(Int)1,(Int)1,
};
namespace openfl{
namespace _internal{
namespace renderer{
namespace opengl{
namespace utils{

void SpriteBatch_obj::__construct( ::lime::graphics::GLRenderContext gl,hx::Null< Int >  __o_maxSprites){
Int maxSprites = __o_maxSprites.Default(2000);
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.SpriteBatch","new",0x9b485926,"openfl._internal.renderer.opengl.utils.SpriteBatch.new","openfl/_internal/renderer/opengl/utils/SpriteBatch.hx",31,0x8289eb2d)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(gl,"gl")
            	HX_STACK_ARG(maxSprites,"maxSprites")
HXLINE(  71)		this->colorTransform =  ::openfl::geom::ColorTransform_obj::__new(null(),null(),null(),null(),null(),null(),null(),null());
HXLINE(  70)		this->uvs =  ::openfl::display::TextureUvs_obj::__new();
HXLINE(  69)		this->matrix =  ::openfl::geom::Matrix_obj::__new(null(),null(),null(),null(),null(),null());
HXLINE(  67)		this->lastEnableColor = true;
HXLINE(  65)		this->enableColor = true;
HXLINE(  63)		this->attributes = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  60)		this->writtenVertexBytes = (int)0;
HXLINE(  49)		this->drawing = false;
HXLINE(  48)		this->dirty = true;
HXLINE(  38)		this->states = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  74)		this->maxSprites = maxSprites;
HXLINE(  76)		this->attributes->push( ::openfl::_internal::renderer::opengl::utils::VertexAttribute_obj::__new((int)2,(int)5126,false,HX_("openfl_aPosition",7b,19,f2,d0),null()));
HXLINE(  77)		this->attributes->push( ::openfl::_internal::renderer::opengl::utils::VertexAttribute_obj::__new((int)2,(int)5126,false,HX_("openfl_aTexCoord0",10,9c,05,d4),null()));
HXLINE(  78)		this->attributes->push( ::openfl::_internal::renderer::opengl::utils::VertexAttribute_obj::__new((int)4,(int)5121,true,HX_("openfl_aColor",51,21,0d,bc),null()));
HXLINE(  80)		HX_VARI( ::cpp::VirtualArray,array) = ::Array_obj< Int >::fromData( _hx_array_data_2,4);
HXDLIN(  80)		HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this1,"this");
HXDLIN(  80)		Bool _hx_tmp = hx::IsNotNull( array );
HXDLIN(  80)		if (_hx_tmp) {
HXLINE(  80)			HX_VARI(  ::lime::utils::ArrayBufferView,_this) =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)8);
HXDLIN(  80)			_this->byteOffset = (int)0;
HXDLIN(  80)			_this->length = array->get_length();
HXDLIN(  80)			Int _hx_tmp1 = (_this->length * _this->bytesPerElement);
HXDLIN(  80)			_this->byteLength = _hx_tmp1;
HXDLIN(  80)			Int byteLength = _this->byteLength;
HXDLIN(  80)			HX_VARI_NAME(  ::haxe::io::Bytes,this2,"this") = ::haxe::io::Bytes_obj::alloc(byteLength);
HXDLIN(  80)			_this->buffer = this2;
HXDLIN(  80)			_this->copyFromArray(array,null());
HXDLIN(  80)			this1 = _this;
            		}
            		else {
HXLINE(  80)			HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            		}
HXDLIN(  80)		this->attributes->__get((int)2).StaticCast<  ::openfl::_internal::renderer::opengl::utils::VertexAttribute >()->defaultValue = this1;
HXLINE(  82)		this->maxElementsPerVertex = (int)0;
HXLINE(  84)		{
HXLINE(  84)			HX_VARI( Int,_g) = (int)0;
HXDLIN(  84)			HX_VARI( ::Array< ::Dynamic>,_g1) = this->attributes;
HXDLIN(  84)			while((_g < _g1->length)){
HXLINE(  84)				HX_VARI(  ::openfl::_internal::renderer::opengl::utils::VertexAttribute,a) = _g1->__get(_g).StaticCast<  ::openfl::_internal::renderer::opengl::utils::VertexAttribute >();
HXDLIN(  84)				++_g;
HXLINE(  85)				HX_VARI_NAME( Int,_g2,"_g") = a->type;
HXDLIN(  85)				Int _hx_tmp2;
HXDLIN(  85)				switch((int)(_g2)){
            					case (int)5120: case (int)5121: {
HXLINE(  85)						_hx_tmp2 = (int)1;
            					}
            					break;
            					case (int)5122: case (int)5123: {
HXLINE(  85)						_hx_tmp2 = (int)2;
            					}
            					break;
            					default:{
HXLINE(  85)						_hx_tmp2 = (int)4;
            					}
            				}
HXDLIN(  85)				Float _hx_tmp3 = ((Float)(a->components * _hx_tmp2) / (Float)(int)4);
HXDLIN(  85)				hx::AddEq(this->maxElementsPerVertex,::Math_obj::floor(_hx_tmp3));
            			}
            		}
HXLINE(  88)		Int _hx_tmp4 = ((maxSprites * this->maxElementsPerVertex) * (int)4);
HXDLIN(  88)		this->vertexArraySize = (_hx_tmp4 * (int)4);
HXLINE(  89)		this->indexArraySize = (maxSprites * (int)6);
HXLINE(  91)		this->vertexArray =  ::openfl::_internal::renderer::opengl::utils::VertexArray_obj::__new(this->attributes,this->vertexArraySize,false);
HXLINE(  92)		HX_VARI(  ::haxe::io::Bytes,buffer) = this->vertexArray->buffer;
HXDLIN(  92)		HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this3,"this");
HXDLIN(  92)		Bool _hx_tmp5 = hx::IsNotNull( buffer );
HXDLIN(  92)		if (_hx_tmp5) {
HXLINE(  92)			HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this1,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)8);
HXDLIN(  92)			if ((hx::Mod((int)0,_this1->bytesPerElement) != (int)0)) {
HXLINE(  92)				HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            			}
HXDLIN(  92)			HX_VARI( Int,bufferByteLength) = buffer->length;
HXDLIN(  92)			{
HXLINE(  92)				if ((hx::Mod(bufferByteLength,_this1->bytesPerElement) != (int)0)) {
HXLINE(  92)					HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            				}
HXDLIN(  92)				if ((bufferByteLength < (int)0)) {
HXLINE(  92)					HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            				}
            			}
HXDLIN(  92)			_this1->buffer = buffer;
HXDLIN(  92)			_this1->byteOffset = (int)0;
HXDLIN(  92)			_this1->byteLength = bufferByteLength;
HXDLIN(  92)			Float _hx_tmp6 = ((Float)bufferByteLength / (Float)_this1->bytesPerElement);
HXDLIN(  92)			_this1->length = ::Std_obj::_hx_int(_hx_tmp6);
HXDLIN(  92)			this3 = _this1;
            		}
            		else {
HXLINE(  92)			HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            		}
HXDLIN(  92)		this->positions = this3;
HXLINE(  93)		HX_VARI_NAME(  ::haxe::io::Bytes,buffer1,"buffer") = this->vertexArray->buffer;
HXDLIN(  93)		HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this4,"this");
HXDLIN(  93)		Bool _hx_tmp7 = hx::IsNotNull( buffer1 );
HXDLIN(  93)		if (_hx_tmp7) {
HXLINE(  93)			HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this2,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)7);
HXDLIN(  93)			if ((hx::Mod((int)0,_this2->bytesPerElement) != (int)0)) {
HXLINE(  93)				HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            			}
HXDLIN(  93)			HX_VARI_NAME( Int,bufferByteLength1,"bufferByteLength") = buffer1->length;
HXDLIN(  93)			{
HXLINE(  93)				if ((hx::Mod(bufferByteLength1,_this2->bytesPerElement) != (int)0)) {
HXLINE(  93)					HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            				}
HXDLIN(  93)				if ((bufferByteLength1 < (int)0)) {
HXLINE(  93)					HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            				}
            			}
HXDLIN(  93)			_this2->buffer = buffer1;
HXDLIN(  93)			_this2->byteOffset = (int)0;
HXDLIN(  93)			_this2->byteLength = bufferByteLength1;
HXDLIN(  93)			Float _hx_tmp8 = ((Float)bufferByteLength1 / (Float)_this2->bytesPerElement);
HXDLIN(  93)			_this2->length = ::Std_obj::_hx_int(_hx_tmp8);
HXDLIN(  93)			this4 = _this2;
            		}
            		else {
HXLINE(  93)			HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Uint32Array",f0,3e,3a,98));
            		}
HXDLIN(  93)		this->colors = this4;
HXLINE(  95)		HX_VARI(  ::Dynamic,elements) = this->indexArraySize;
HXDLIN(  95)		HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this5,"this");
HXDLIN(  95)		Bool _hx_tmp9 = hx::IsNotNull( elements );
HXDLIN(  95)		if (_hx_tmp9) {
HXLINE(  95)			this5 =  ::lime::utils::ArrayBufferView_obj::__new(elements,(int)6);
            		}
            		else {
HXLINE(  95)			HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Uint16Array",ea,c2,7c,de));
            		}
HXDLIN(  95)		this->indices = this5;
HXLINE(  97)		HX_VARI( Int,i) = (int)0;
HXDLIN(  97)		HX_VARI( Int,j) = (int)0;
HXLINE(  98)		while((i < this->indexArraySize)){
HXLINE(  99)			{
HXLINE(  99)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this6,"this") = this->indices;
HXDLIN(  99)				{
HXLINE(  99)					Int byteOffset = (this6->byteOffset + (i * (int)2));
HXDLIN(  99)					::__hxcpp_memory_set_ui16(this6->buffer->b,byteOffset,j);
            				}
            			}
HXLINE( 100)			{
HXLINE( 100)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this7,"this") = this->indices;
HXDLIN( 100)				HX_VARI( Int,val) = (j + (int)1);
HXDLIN( 100)				{
HXLINE( 100)					Int _hx_tmp10 = this7->byteOffset;
HXDLIN( 100)					::__hxcpp_memory_set_ui16(this7->buffer->b,(_hx_tmp10 + ((i + (int)1) * (int)2)),val);
            				}
            			}
HXLINE( 101)			{
HXLINE( 101)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this8,"this") = this->indices;
HXDLIN( 101)				HX_VARI_NAME( Int,val1,"val") = (j + (int)2);
HXDLIN( 101)				{
HXLINE( 101)					Int _hx_tmp11 = this8->byteOffset;
HXDLIN( 101)					::__hxcpp_memory_set_ui16(this8->buffer->b,(_hx_tmp11 + ((i + (int)2) * (int)2)),val1);
            				}
            			}
HXLINE( 102)			{
HXLINE( 102)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this9,"this") = this->indices;
HXDLIN( 102)				{
HXLINE( 102)					Int _hx_tmp12 = this9->byteOffset;
HXDLIN( 102)					::__hxcpp_memory_set_ui16(this9->buffer->b,(_hx_tmp12 + ((i + (int)3) * (int)2)),j);
            				}
            			}
HXLINE( 103)			{
HXLINE( 103)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this10,"this") = this->indices;
HXDLIN( 103)				HX_VARI_NAME( Int,val2,"val") = (j + (int)2);
HXDLIN( 103)				{
HXLINE( 103)					Int _hx_tmp13 = this10->byteOffset;
HXDLIN( 103)					::__hxcpp_memory_set_ui16(this10->buffer->b,(_hx_tmp13 + ((i + (int)4) * (int)2)),val2);
            				}
            			}
HXLINE( 104)			{
HXLINE( 104)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this11,"this") = this->indices;
HXDLIN( 104)				HX_VARI_NAME( Int,val3,"val") = (j + (int)3);
HXDLIN( 104)				{
HXLINE( 104)					Int _hx_tmp14 = this11->byteOffset;
HXDLIN( 104)					::__hxcpp_memory_set_ui16(this11->buffer->b,(_hx_tmp14 + ((i + (int)5) * (int)2)),val3);
            				}
            			}
HXLINE( 105)			hx::AddEq(i,(int)6);
HXLINE( 106)			hx::AddEq(j,(int)4);
            		}
HXLINE( 109)		this->currentState =  ::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State_obj::__new();
HXLINE( 110)		this->dirty = true;
HXLINE( 111)		this->drawing = false;
HXLINE( 112)		this->batchedSprites = (int)0;
HXLINE( 114)		this->setContext(gl);
            	}

Dynamic SpriteBatch_obj::__CreateEmpty() { return new SpriteBatch_obj; }

hx::ObjectPtr< SpriteBatch_obj > SpriteBatch_obj::__new( ::lime::graphics::GLRenderContext gl,hx::Null< Int >  __o_maxSprites)
{
	hx::ObjectPtr< SpriteBatch_obj > _hx_result = new SpriteBatch_obj();
	_hx_result->__construct(gl,__o_maxSprites);
	return _hx_result;
}

Dynamic SpriteBatch_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< SpriteBatch_obj > _hx_result = new SpriteBatch_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

void SpriteBatch_obj::destroy(){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.SpriteBatch","destroy",0xc9b590c0,"openfl._internal.renderer.opengl.utils.SpriteBatch.destroy","openfl/_internal/renderer/opengl/utils/SpriteBatch.hx",118,0x8289eb2d)
            	HX_STACK_THIS(this)
HXLINE( 119)		this->vertexArray->destroy();
HXLINE( 120)		this->vertexArray = null();
HXLINE( 122)		this->indices = null();
HXLINE( 123)		{
HXLINE( 123)			HX_VARI(  ::lime::graphics::opengl::GLBuffer,buffer) = this->indexBuffer;
HXDLIN( 123)			{
HXLINE( 123)				{
HXLINE( 123)					Int buffer1 = ( (Int)(buffer->id) );
HXDLIN( 123)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_delete_buffer(buffer1);
            				}
HXDLIN( 123)				buffer->invalidate();
            			}
            		}
HXLINE( 125)		this->currentState->destroy();
HXLINE( 126)		{
HXLINE( 126)			HX_VARI( Int,_g) = (int)0;
HXDLIN( 126)			HX_VARI( ::Array< ::Dynamic>,_g1) = this->states;
HXDLIN( 126)			while((_g < _g1->length)){
HXLINE( 126)				HX_VARI(  ::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State,state) = _g1->__get(_g).StaticCast<  ::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State >();
HXDLIN( 126)				++_g;
HXLINE( 127)				state->destroy();
            			}
            		}
HXLINE( 130)		this->colorTransform = null();
HXLINE( 132)		this->gl = null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(SpriteBatch_obj,destroy,(void))

void SpriteBatch_obj::begin( ::openfl::_internal::renderer::RenderSession renderSession, ::openfl::geom::Rectangle clipRect){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.SpriteBatch","begin",0x5812b06f,"openfl._internal.renderer.opengl.utils.SpriteBatch.begin","openfl/_internal/renderer/opengl/utils/SpriteBatch.hx",135,0x8289eb2d)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(renderSession,"renderSession")
            	HX_STACK_ARG(clipRect,"clipRect")
HXLINE( 137)		this->renderSession = renderSession;
HXLINE( 138)		this->shader = renderSession->shaderManager->defaultShader;
HXLINE( 139)		this->drawing = true;
HXLINE( 140)		this->start(clipRect);
            	}


HX_DEFINE_DYNAMIC_FUNC2(SpriteBatch_obj,begin,(void))

void SpriteBatch_obj::finish(){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.SpriteBatch","finish",0xa3eff74d,"openfl._internal.renderer.opengl.utils.SpriteBatch.finish","openfl/_internal/renderer/opengl/utils/SpriteBatch.hx",144,0x8289eb2d)
            	HX_STACK_THIS(this)
HXLINE( 145)		this->stop();
HXLINE( 146)		this->clipRect = null();
HXLINE( 147)		this->drawing = false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(SpriteBatch_obj,finish,(void))

void SpriteBatch_obj::start( ::openfl::geom::Rectangle clipRect){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.SpriteBatch","start",0x2bc83aa8,"openfl._internal.renderer.opengl.utils.SpriteBatch.start","openfl/_internal/renderer/opengl/utils/SpriteBatch.hx",150,0x8289eb2d)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(clipRect,"clipRect")
HXLINE( 151)		Bool _hx_tmp = !(this->drawing);
HXDLIN( 151)		if (_hx_tmp) {
HXLINE( 152)			this->stop();
            		}
HXLINE( 154)		this->dirty = true;
HXLINE( 155)		this->clipRect = clipRect;
            	}


HX_DEFINE_DYNAMIC_FUNC1(SpriteBatch_obj,start,(void))

void SpriteBatch_obj::stop(){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.SpriteBatch","stop",0x475f147c,"openfl._internal.renderer.opengl.utils.SpriteBatch.stop","openfl/_internal/renderer/opengl/utils/SpriteBatch.hx",159,0x8289eb2d)
            	HX_STACK_THIS(this)
HXLINE( 159)		this->flush();
            	}


HX_DEFINE_DYNAMIC_FUNC0(SpriteBatch_obj,stop,(void))

void SpriteBatch_obj::renderBitmapData( ::openfl::display::BitmapData bitmapData,Bool smoothing, ::openfl::geom::Matrix matrix, ::openfl::geom::ColorTransform ct, ::Dynamic __o_alpha, ::Dynamic blendMode, ::openfl::display::Shader flashShader, ::Dynamic pixelSnapping,hx::Null< Bool >  __o_bgra){
 ::Dynamic alpha = __o_alpha.Default(1);
Bool bgra = __o_bgra.Default(false);
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.SpriteBatch","renderBitmapData",0x214be029,"openfl._internal.renderer.opengl.utils.SpriteBatch.renderBitmapData","openfl/_internal/renderer/opengl/utils/SpriteBatch.hx",162,0x8289eb2d)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(bitmapData,"bitmapData")
            	HX_STACK_ARG(smoothing,"smoothing")
            	HX_STACK_ARG(matrix,"matrix")
            	HX_STACK_ARG(ct,"ct")
            	HX_STACK_ARG(alpha,"alpha")
            	HX_STACK_ARG(blendMode,"blendMode")
            	HX_STACK_ARG(flashShader,"flashShader")
            	HX_STACK_ARG(pixelSnapping,"pixelSnapping")
            	HX_STACK_ARG(bgra,"bgra")
HXLINE( 163)		Bool _hx_tmp = hx::IsNull( bitmapData );
HXDLIN( 163)		if (_hx_tmp) {
HXLINE( 163)			return;
            		}
HXLINE( 164)		HX_VARI(  ::lime::graphics::opengl::GLTexture,texture) = bitmapData->getTexture(this->gl);
HXLINE( 166)		Bool _hx_tmp1 = (this->batchedSprites >= this->maxSprites);
HXDLIN( 166)		if (_hx_tmp1) {
HXLINE( 167)			this->flush();
            		}
HXLINE( 170)		HX_VARI(  ::openfl::display::TextureUvs,uvs) = bitmapData->_hx___uvData;
HXLINE( 171)		Bool _hx_tmp2 = hx::IsNull( uvs );
HXDLIN( 171)		if (_hx_tmp2) {
HXLINE( 171)			return;
            		}
HXLINE( 173)		Bool _hx_tmp3 = hx::IsNotNull( flashShader );
HXDLIN( 173)		if (_hx_tmp3) {
HXLINE( 173)			flashShader->_hx___init(this->gl);
HXDLIN( 173)			flashShader->_hx___shader->wrapS = flashShader->repeatX;
HXDLIN( 173)			flashShader->_hx___shader->wrapT = flashShader->repeatY;
HXDLIN( 173)			flashShader->_hx___shader->smooth = flashShader->smooth;
HXDLIN( 173)			flashShader->_hx___shader->blendMode = flashShader->blendMode;
HXDLIN( 173)			HX_VARI(  ::openfl::display::GLShaderParameter,objSize) = flashShader->data->get(::openfl::display::Shader_obj::uObjectSize).StaticCast<  ::openfl::display::GLShaderParameter >();
HXDLIN( 173)			HX_VARI(  ::openfl::display::GLShaderParameter,texSize) = flashShader->data->get(::openfl::display::Shader_obj::uTextureSize).StaticCast<  ::openfl::display::GLShaderParameter >();
HXDLIN( 173)			Bool _hx_tmp4 = hx::IsNotNull( bitmapData );
HXDLIN( 173)			if (_hx_tmp4) {
HXLINE( 173)				objSize->value[(int)0] = bitmapData->width;
HXDLIN( 173)				objSize->value[(int)1] = bitmapData->height;
HXDLIN( 173)				Bool _hx_tmp5 = hx::IsNotNull( bitmapData->_hx___pingPongTexture );
HXDLIN( 173)				if (_hx_tmp5) {
HXLINE( 173)					HX_VARI(  ::openfl::_internal::renderer::opengl::utils::PingPongTexture,_this) = bitmapData->_hx___pingPongTexture;
HXDLIN( 173)					 ::openfl::_internal::renderer::opengl::utils::RenderTexture _hx_tmp6;
HXDLIN( 173)					if (_this->_hx___swapped) {
HXLINE( 173)						_hx_tmp6 = _this->_hx___texture1;
            					}
            					else {
HXLINE( 173)						_hx_tmp6 = _this->_hx___texture0;
            					}
HXDLIN( 173)					texSize->value[(int)0] = _hx_tmp6->_hx___width;
HXDLIN( 173)					HX_VARI_NAME(  ::openfl::_internal::renderer::opengl::utils::PingPongTexture,_this1,"_this") = bitmapData->_hx___pingPongTexture;
HXDLIN( 173)					 ::openfl::_internal::renderer::opengl::utils::RenderTexture _hx_tmp7;
HXDLIN( 173)					if (_this1->_hx___swapped) {
HXLINE( 173)						_hx_tmp7 = _this1->_hx___texture1;
            					}
            					else {
HXLINE( 173)						_hx_tmp7 = _this1->_hx___texture0;
            					}
HXDLIN( 173)					texSize->value[(int)1] = _hx_tmp7->_hx___height;
            				}
            				else {
HXLINE( 173)					texSize->value[(int)0] = bitmapData->width;
HXDLIN( 173)					texSize->value[(int)1] = bitmapData->height;
            				}
            			}
            			else {
HXLINE( 173)				objSize->value[(int)0] = (int)0;
HXDLIN( 173)				objSize->value[(int)1] = (int)0;
HXDLIN( 173)				texSize->value[(int)0] = (int)0;
HXDLIN( 173)				texSize->value[(int)1] = (int)0;
            			}
            		}
HXLINE( 175)		Int _hx_tmp8 = ::Std_obj::_hx_int((alpha * (int)255));
HXDLIN( 175)		HX_VARI( Int,color) = ((int)((int)((int)_hx_tmp8 & (int)(int)255) << (int)(int)24) | (int)(int)16777215);
HXLINE( 178)		{
HXLINE( 178)			this->enableColor = true;
HXDLIN( 178)			Bool _hx_tmp9 = (this->enableColor != this->lastEnableColor);
HXDLIN( 178)			if (_hx_tmp9) {
HXLINE( 178)				this->flush();
HXDLIN( 178)				this->lastEnableColor = this->enableColor;
            			}
HXDLIN( 178)			this->attributes->__get((int)2).StaticCast<  ::openfl::_internal::renderer::opengl::utils::VertexAttribute >()->enabled = this->lastEnableColor;
HXDLIN( 178)			HX_VARI( Int,r) = (int)0;
HXDLIN( 178)			{
HXLINE( 178)				HX_VARI( Int,_g) = (int)0;
HXDLIN( 178)				HX_VARI( ::Array< ::Dynamic>,_g1) = this->attributes;
HXDLIN( 178)				while((_g < _g1->length)){
HXLINE( 178)					HX_VARI(  ::openfl::_internal::renderer::opengl::utils::VertexAttribute,a) = _g1->__get(_g).StaticCast<  ::openfl::_internal::renderer::opengl::utils::VertexAttribute >();
HXDLIN( 178)					++_g;
HXDLIN( 178)					Bool _hx_tmp10 = a->enabled;
HXDLIN( 178)					if (_hx_tmp10) {
HXLINE( 178)						HX_VARI_NAME( Int,_g2,"_g") = a->type;
HXDLIN( 178)						Int _hx_tmp11;
HXDLIN( 178)						switch((int)(_g2)){
            							case (int)5120: case (int)5121: {
HXLINE( 178)								_hx_tmp11 = (int)1;
            							}
            							break;
            							case (int)5122: case (int)5123: {
HXLINE( 178)								_hx_tmp11 = (int)2;
            							}
            							break;
            							default:{
HXLINE( 178)								_hx_tmp11 = (int)4;
            							}
            						}
HXDLIN( 178)						Float _hx_tmp12 = ((Float)(a->components * _hx_tmp11) / (Float)(int)4);
HXDLIN( 178)						Int _hx_tmp13 = ::Math_obj::floor(_hx_tmp12);
HXDLIN( 178)						hx::AddEq(r,_hx_tmp13);
            					}
            				}
            			}
HXDLIN( 178)			this->elementsPerVertex = r;
            		}
HXLINE( 180)		HX_VARI( Int,index) = ((this->batchedSprites * (int)4) * this->elementsPerVertex);
HXLINE( 181)		{
HXLINE( 181)			HX_VARI( Float,width) = bitmapData->width;
HXDLIN( 181)			HX_VARI( Float,height) = bitmapData->height;
HXDLIN( 181)			HX_VARI_NAME( Float,a1,"a") = matrix->a;
HXDLIN( 181)			HX_VARI( Float,b) = matrix->b;
HXDLIN( 181)			HX_VARI( Float,c) = matrix->c;
HXDLIN( 181)			HX_VARI( Float,d) = matrix->d;
HXDLIN( 181)			HX_VARI( Float,tx) = matrix->tx;
HXDLIN( 181)			HX_VARI( Float,ty) = matrix->ty;
HXDLIN( 181)			Bool _hx_tmp14;
HXDLIN( 181)			Bool _hx_tmp15 = hx::IsNotNull( pixelSnapping );
HXDLIN( 181)			if (_hx_tmp15) {
HXLINE( 181)				_hx_tmp14 = hx::IsEq( pixelSnapping,(int)2 );
            			}
            			else {
HXLINE( 181)				_hx_tmp14 = true;
            			}
HXDLIN( 181)			if (_hx_tmp14) {
HXLINE( 181)				{
HXLINE( 181)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this1,"this") = this->positions;
HXDLIN( 181)					{
HXLINE( 181)						Int byteOffset = (this1->byteOffset + (index * (int)4));
HXDLIN( 181)						::__hxcpp_memory_set_float(this1->buffer->b,byteOffset,tx);
            					}
            				}
HXDLIN( 181)				{
HXLINE( 181)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this2,"this") = this->positions;
HXDLIN( 181)					{
HXLINE( 181)						Int byteOffset1 = (this2->byteOffset + ((index + (int)1) * (int)4));
HXDLIN( 181)						::__hxcpp_memory_set_float(this2->buffer->b,byteOffset1,ty);
            					}
            				}
HXDLIN( 181)				{
HXLINE( 181)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this3,"this") = this->positions;
HXDLIN( 181)					{
HXLINE( 181)						Int byteOffset2 = (this3->byteOffset + ((index + (int)5) * (int)4));
HXDLIN( 181)						::__hxcpp_memory_set_float(this3->buffer->b,byteOffset2,((a1 * width) + tx));
            					}
            				}
HXDLIN( 181)				{
HXLINE( 181)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this4,"this") = this->positions;
HXDLIN( 181)					{
HXLINE( 181)						Int byteOffset3 = (this4->byteOffset + ((index + (int)6) * (int)4));
HXDLIN( 181)						::__hxcpp_memory_set_float(this4->buffer->b,byteOffset3,((b * width) + ty));
            					}
            				}
HXDLIN( 181)				{
HXLINE( 181)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this5,"this") = this->positions;
HXDLIN( 181)					{
HXLINE( 181)						Int byteOffset4 = (this5->byteOffset + ((index + (int)10) * (int)4));
HXDLIN( 181)						::__hxcpp_memory_set_float(this5->buffer->b,byteOffset4,(((a1 * width) + (c * height)) + tx));
            					}
            				}
HXDLIN( 181)				{
HXLINE( 181)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this6,"this") = this->positions;
HXDLIN( 181)					{
HXLINE( 181)						Int byteOffset5 = (this6->byteOffset + ((index + (int)11) * (int)4));
HXDLIN( 181)						::__hxcpp_memory_set_float(this6->buffer->b,byteOffset5,(((d * height) + (b * width)) + ty));
            					}
            				}
HXDLIN( 181)				{
HXLINE( 181)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this7,"this") = this->positions;
HXDLIN( 181)					{
HXLINE( 181)						Int byteOffset6 = (this7->byteOffset + ((index + (int)15) * (int)4));
HXDLIN( 181)						::__hxcpp_memory_set_float(this7->buffer->b,byteOffset6,((c * height) + tx));
            					}
            				}
HXDLIN( 181)				{
HXLINE( 181)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this8,"this") = this->positions;
HXDLIN( 181)					{
HXLINE( 181)						Int byteOffset7 = (this8->byteOffset + ((index + (int)16) * (int)4));
HXDLIN( 181)						::__hxcpp_memory_set_float(this8->buffer->b,byteOffset7,((d * height) + ty));
            					}
            				}
            			}
            			else {
HXLINE( 181)				{
HXLINE( 181)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this9,"this") = this->positions;
HXDLIN( 181)					HX_VARI( Float,val) = ::Math_obj::fround(tx);
HXDLIN( 181)					{
HXLINE( 181)						Int byteOffset8 = (this9->byteOffset + (index * (int)4));
HXDLIN( 181)						::__hxcpp_memory_set_float(this9->buffer->b,byteOffset8,val);
            					}
            				}
HXDLIN( 181)				{
HXLINE( 181)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this10,"this") = this->positions;
HXDLIN( 181)					HX_VARI_NAME( Float,val1,"val") = ::Math_obj::fround(ty);
HXDLIN( 181)					{
HXLINE( 181)						Int byteOffset9 = (this10->byteOffset + ((index + (int)1) * (int)4));
HXDLIN( 181)						::__hxcpp_memory_set_float(this10->buffer->b,byteOffset9,val1);
            					}
            				}
HXDLIN( 181)				{
HXLINE( 181)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this11,"this") = this->positions;
HXDLIN( 181)					HX_VARI_NAME( Float,val2,"val") = ::Math_obj::fround(((a1 * width) + tx));
HXDLIN( 181)					{
HXLINE( 181)						Int byteOffset10 = (this11->byteOffset + ((index + (int)5) * (int)4));
HXDLIN( 181)						::__hxcpp_memory_set_float(this11->buffer->b,byteOffset10,val2);
            					}
            				}
HXDLIN( 181)				{
HXLINE( 181)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this12,"this") = this->positions;
HXDLIN( 181)					HX_VARI_NAME( Float,val3,"val") = ::Math_obj::fround(((b * width) + ty));
HXDLIN( 181)					{
HXLINE( 181)						Int byteOffset11 = (this12->byteOffset + ((index + (int)6) * (int)4));
HXDLIN( 181)						::__hxcpp_memory_set_float(this12->buffer->b,byteOffset11,val3);
            					}
            				}
HXDLIN( 181)				{
HXLINE( 181)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this13,"this") = this->positions;
HXDLIN( 181)					HX_VARI_NAME( Float,val4,"val") = ::Math_obj::fround((((a1 * width) + (c * height)) + tx));
HXDLIN( 181)					{
HXLINE( 181)						Int byteOffset12 = (this13->byteOffset + ((index + (int)10) * (int)4));
HXDLIN( 181)						::__hxcpp_memory_set_float(this13->buffer->b,byteOffset12,val4);
            					}
            				}
HXDLIN( 181)				{
HXLINE( 181)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this14,"this") = this->positions;
HXDLIN( 181)					HX_VARI_NAME( Float,val5,"val") = ::Math_obj::fround((((d * height) + (b * width)) + ty));
HXDLIN( 181)					{
HXLINE( 181)						Int byteOffset13 = (this14->byteOffset + ((index + (int)11) * (int)4));
HXDLIN( 181)						::__hxcpp_memory_set_float(this14->buffer->b,byteOffset13,val5);
            					}
            				}
HXDLIN( 181)				{
HXLINE( 181)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this15,"this") = this->positions;
HXDLIN( 181)					HX_VARI_NAME( Float,val6,"val") = ::Math_obj::fround(((c * height) + tx));
HXDLIN( 181)					{
HXLINE( 181)						Int byteOffset14 = (this15->byteOffset + ((index + (int)15) * (int)4));
HXDLIN( 181)						::__hxcpp_memory_set_float(this15->buffer->b,byteOffset14,val6);
            					}
            				}
HXDLIN( 181)				{
HXLINE( 181)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this16,"this") = this->positions;
HXDLIN( 181)					HX_VARI_NAME( Float,val7,"val") = ::Math_obj::fround(((d * height) + ty));
HXDLIN( 181)					{
HXLINE( 181)						Int byteOffset15 = (this16->byteOffset + ((index + (int)16) * (int)4));
HXDLIN( 181)						::__hxcpp_memory_set_float(this16->buffer->b,byteOffset15,val7);
            					}
            				}
            			}
HXDLIN( 181)			Bool _hx_tmp16 = this->enableColor;
HXDLIN( 181)			if (_hx_tmp16) {
HXLINE( 181)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this17,"this") = this->colors;
HXDLIN( 181)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this18,"this") = this->colors;
HXDLIN( 181)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this19,"this") = this->colors;
HXDLIN( 181)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this20,"this") = this->colors;
HXDLIN( 181)				Int byteOffset16 = (this20->byteOffset + ((index + (int)19) * (int)4));
HXDLIN( 181)				::__hxcpp_memory_set_ui32(this20->buffer->b,byteOffset16,color);
HXDLIN( 181)				HX_VARI_NAME( Int,val8,"val") = color;
HXDLIN( 181)				Int byteOffset17 = (this19->byteOffset + ((index + (int)14) * (int)4));
HXDLIN( 181)				::__hxcpp_memory_set_ui32(this19->buffer->b,byteOffset17,val8);
HXDLIN( 181)				Int byteOffset18 = (this18->byteOffset + ((index + (int)9) * (int)4));
HXDLIN( 181)				::__hxcpp_memory_set_ui32(this18->buffer->b,byteOffset18,val8);
HXDLIN( 181)				{
HXLINE( 181)					Int byteOffset19 = (this17->byteOffset + ((index + (int)4) * (int)4));
HXDLIN( 181)					::__hxcpp_memory_set_ui32(this17->buffer->b,byteOffset19,val8);
            				}
            			}
HXDLIN( 181)			{
HXLINE( 181)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this21,"this") = this->positions;
HXDLIN( 181)				HX_VARI_NAME( Float,val9,"val") = uvs->x0;
HXDLIN( 181)				{
HXLINE( 181)					Int byteOffset20 = (this21->byteOffset + ((index + (int)2) * (int)4));
HXDLIN( 181)					::__hxcpp_memory_set_float(this21->buffer->b,byteOffset20,val9);
            				}
            			}
HXDLIN( 181)			{
HXLINE( 181)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this22,"this") = this->positions;
HXDLIN( 181)				HX_VARI_NAME( Float,val10,"val") = uvs->y0;
HXDLIN( 181)				{
HXLINE( 181)					Int byteOffset21 = (this22->byteOffset + ((index + (int)3) * (int)4));
HXDLIN( 181)					::__hxcpp_memory_set_float(this22->buffer->b,byteOffset21,val10);
            				}
            			}
HXDLIN( 181)			{
HXLINE( 181)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this23,"this") = this->positions;
HXDLIN( 181)				HX_VARI_NAME( Float,val11,"val") = uvs->x1;
HXDLIN( 181)				{
HXLINE( 181)					Int byteOffset22 = (this23->byteOffset + ((index + (int)7) * (int)4));
HXDLIN( 181)					::__hxcpp_memory_set_float(this23->buffer->b,byteOffset22,val11);
            				}
            			}
HXDLIN( 181)			{
HXLINE( 181)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this24,"this") = this->positions;
HXDLIN( 181)				HX_VARI_NAME( Float,val12,"val") = uvs->y1;
HXDLIN( 181)				{
HXLINE( 181)					Int byteOffset23 = (this24->byteOffset + ((index + (int)8) * (int)4));
HXDLIN( 181)					::__hxcpp_memory_set_float(this24->buffer->b,byteOffset23,val12);
            				}
            			}
HXDLIN( 181)			{
HXLINE( 181)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this25,"this") = this->positions;
HXDLIN( 181)				HX_VARI_NAME( Float,val13,"val") = uvs->x2;
HXDLIN( 181)				{
HXLINE( 181)					Int byteOffset24 = (this25->byteOffset + ((index + (int)12) * (int)4));
HXDLIN( 181)					::__hxcpp_memory_set_float(this25->buffer->b,byteOffset24,val13);
            				}
            			}
HXDLIN( 181)			{
HXLINE( 181)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this26,"this") = this->positions;
HXDLIN( 181)				HX_VARI_NAME( Float,val14,"val") = uvs->y2;
HXDLIN( 181)				{
HXLINE( 181)					Int byteOffset25 = (this26->byteOffset + ((index + (int)13) * (int)4));
HXDLIN( 181)					::__hxcpp_memory_set_float(this26->buffer->b,byteOffset25,val14);
            				}
            			}
HXDLIN( 181)			{
HXLINE( 181)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this27,"this") = this->positions;
HXDLIN( 181)				HX_VARI_NAME( Float,val15,"val") = uvs->x3;
HXDLIN( 181)				{
HXLINE( 181)					Int byteOffset26 = (this27->byteOffset + ((index + (int)17) * (int)4));
HXDLIN( 181)					::__hxcpp_memory_set_float(this27->buffer->b,byteOffset26,val15);
            				}
            			}
HXDLIN( 181)			{
HXLINE( 181)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this28,"this") = this->positions;
HXDLIN( 181)				HX_VARI_NAME( Float,val16,"val") = uvs->y3;
HXDLIN( 181)				{
HXLINE( 181)					Int byteOffset27 = (this28->byteOffset + ((index + (int)18) * (int)4));
HXDLIN( 181)					::__hxcpp_memory_set_float(this28->buffer->b,byteOffset27,val16);
            				}
            			}
HXDLIN( 181)			this->writtenVertexBytes = (index + (int)20);
            		}
HXLINE( 183)		{
HXLINE( 183)			HX_VARI_NAME( Int,index1,"index") = this->batchedSprites;
HXDLIN( 183)			HX_VARI(  ::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State,state) = this->states->__get(index1).StaticCast<  ::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State >();
HXDLIN( 183)			Bool _hx_tmp17 = hx::IsNull( state );
HXDLIN( 183)			if (_hx_tmp17) {
HXLINE( 183)				state = (this->states[index1] =  ::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State_obj::__new());
            			}
HXDLIN( 183)			state->texture = texture;
HXDLIN( 183)			state->textureSmooth = smoothing;
HXDLIN( 183)			state->blendMode = blendMode;
HXDLIN( 183)			Bool _hx_tmp18;
HXDLIN( 183)			Bool _hx_tmp19 = hx::IsNotNull( ct );
HXDLIN( 183)			if (_hx_tmp19) {
HXLINE( 183)				_hx_tmp18 = ct->_hx___isDefault();
            			}
            			else {
HXLINE( 183)				_hx_tmp18 = false;
            			}
HXDLIN( 183)			state->skipColorTransform = _hx_tmp18;
HXDLIN( 183)			Bool _hx_tmp20 = !(state->skipColorTransform);
HXDLIN( 183)			if (_hx_tmp20) {
HXLINE( 183)				state->colorTransform->redMultiplier = ct->redMultiplier;
HXDLIN( 183)				state->colorTransform->greenMultiplier = ct->greenMultiplier;
HXDLIN( 183)				state->colorTransform->blueMultiplier = ct->blueMultiplier;
HXDLIN( 183)				state->colorTransform->alphaMultiplier = ct->alphaMultiplier;
HXDLIN( 183)				state->colorTransform->redOffset = ct->redOffset;
HXDLIN( 183)				state->colorTransform->greenOffset = ct->greenOffset;
HXDLIN( 183)				state->colorTransform->blueOffset = ct->blueOffset;
HXDLIN( 183)				state->colorTransform->alphaOffset = ct->alphaOffset;
            			}
HXDLIN( 183)			state->skipColorTransformAlpha = true;
HXDLIN( 183)			Bool _hx_tmp21 = hx::IsNull( flashShader );
HXDLIN( 183)			if (_hx_tmp21) {
HXLINE( 183)				state->shader = null();
HXDLIN( 183)				state->shaderData = null();
            			}
            			else {
HXLINE( 183)				state->shader = flashShader->_hx___shader;
HXDLIN( 183)				state->shaderData = flashShader->data;
            			}
            		}
HXLINE( 185)		this->batchedSprites++;
            	}


HX_DEFINE_DYNAMIC_FUNC9(SpriteBatch_obj,renderBitmapData,(void))

void SpriteBatch_obj::renderTiles( ::openfl::display::DisplayObject object, ::openfl::display::Tilesheet sheet,::Array< Float > tileData,hx::Null< Bool >  __o_smooth,hx::Null< Int >  __o_flags, ::openfl::display::Shader flashShader,hx::Null< Int >  __o_count){
Bool smooth = __o_smooth.Default(false);
Int flags = __o_flags.Default(0);
Int count = __o_count.Default(-1);
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.SpriteBatch","renderTiles",0xf159e915,"openfl._internal.renderer.opengl.utils.SpriteBatch.renderTiles","openfl/_internal/renderer/opengl/utils/SpriteBatch.hx",188,0x8289eb2d)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(object,"object")
            	HX_STACK_ARG(sheet,"sheet")
            	HX_STACK_ARG(tileData,"tileData")
            	HX_STACK_ARG(smooth,"smooth")
            	HX_STACK_ARG(flags,"flags")
            	HX_STACK_ARG(flashShader,"flashShader")
            	HX_STACK_ARG(count,"count")
HXLINE( 190)		HX_VARI(  ::lime::graphics::opengl::GLTexture,texture) = sheet->_hx___bitmap->getTexture(this->gl);
HXLINE( 191)		Bool _hx_tmp = hx::IsNull( texture );
HXDLIN( 191)		if (_hx_tmp) {
HXLINE( 191)			return;
            		}
HXLINE( 193)		HX_VARI( Bool,useScale) = (((int)flags & (int)(int)1) > (int)0);
HXLINE( 194)		HX_VARI( Bool,useRotation) = (((int)flags & (int)(int)2) > (int)0);
HXLINE( 195)		HX_VARI( Bool,useTransform) = (((int)flags & (int)(int)16) > (int)0);
HXLINE( 196)		HX_VARI( Bool,useRGB) = (((int)flags & (int)(int)4) > (int)0);
HXLINE( 197)		HX_VARI( Bool,useAlpha) = (((int)flags & (int)(int)8) > (int)0);
HXLINE( 198)		HX_VARI( Bool,useRect) = (((int)flags & (int)(int)32) > (int)0);
HXLINE( 199)		HX_VARI( Bool,useOrigin) = (((int)flags & (int)(int)64) > (int)0);
HXLINE( 200)		HX_VARI( Bool,useRGBOffset) = (((int)flags & (int)(int)128) > (int)0);
HXLINE( 202)		HX_VAR(  ::Dynamic,blendMode);
HXDLIN( 202)		switch((int)(((int)flags & (int)(int)983040))){
            			case (int)65536: {
HXLINE( 202)				blendMode = (int)0;
            			}
            			break;
            			case (int)131072: {
HXLINE( 202)				blendMode = (int)9;
            			}
            			break;
            			case (int)262144: {
HXLINE( 202)				blendMode = (int)12;
            			}
            			break;
            			case (int)524288: {
HXLINE( 202)				blendMode = (int)14;
            			}
            			break;
            			default:{
HXLINE( 207)				switch((int)(((int)flags & (int)(int)15728640))){
            					case (int)1048576: {
HXLINE( 202)						blendMode = (int)2;
            					}
            					break;
            					case (int)2097152: {
HXLINE( 202)						blendMode = (int)8;
            					}
            					break;
            					case (int)4194304: {
HXLINE( 202)						blendMode = (int)11;
            					}
            					break;
            					case (int)8388608: {
HXLINE( 202)						blendMode = (int)5;
            					}
            					break;
            					default:{
HXLINE( 212)						switch((int)(((int)flags & (int)(int)251658240))){
            							case (int)16777216: {
HXLINE( 202)								blendMode = (int)3;
            							}
            							break;
            							case (int)33554432: {
HXLINE( 202)								blendMode = (int)6;
            							}
            							break;
            							default:{
HXLINE( 202)								blendMode = (int)10;
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 220)		if (useTransform) {
HXLINE( 220)			useScale = false;
HXDLIN( 220)			useRotation = false;
            		}
HXLINE( 222)		HX_VARI( Int,scaleIndex) = (int)0;
HXLINE( 223)		HX_VARI( Int,rotationIndex) = (int)0;
HXLINE( 224)		HX_VARI( Int,rgbIndex) = (int)0;
HXLINE( 225)		HX_VARI( Int,rgbOffsetIndex) = (int)0;
HXLINE( 226)		HX_VARI( Int,alphaIndex) = (int)0;
HXLINE( 227)		HX_VARI( Int,transformIndex) = (int)0;
HXLINE( 229)		HX_VARI( Int,numValues) = (int)3;
HXLINE( 231)		if (useRect) {
HXLINE( 231)			if (useOrigin) {
HXLINE( 231)				numValues = (int)8;
            			}
            			else {
HXLINE( 231)				numValues = (int)6;
            			}
            		}
HXLINE( 232)		if (useScale) {
HXLINE( 232)			scaleIndex = numValues;
HXDLIN( 232)			++numValues;
            		}
HXLINE( 233)		if (useRotation) {
HXLINE( 233)			rotationIndex = numValues;
HXDLIN( 233)			++numValues;
            		}
HXLINE( 234)		if (useTransform) {
HXLINE( 234)			transformIndex = numValues;
HXDLIN( 234)			hx::AddEq(numValues,(int)4);
            		}
HXLINE( 235)		if (useRGB) {
HXLINE( 235)			rgbIndex = numValues;
HXDLIN( 235)			hx::AddEq(numValues,(int)3);
            		}
HXLINE( 236)		if (useAlpha) {
HXLINE( 236)			alphaIndex = numValues;
HXDLIN( 236)			++numValues;
            		}
HXLINE( 237)		if (useRGBOffset) {
HXLINE( 237)			rgbOffsetIndex = numValues;
HXDLIN( 237)			hx::AddEq(numValues,(int)4);
            		}
HXLINE( 239)		HX_VARI( Int,totalCount) = tileData->length;
HXLINE( 240)		Bool _hx_tmp1;
HXDLIN( 240)		if ((count >= (int)0)) {
HXLINE( 240)			_hx_tmp1 = (totalCount > count);
            		}
            		else {
HXLINE( 240)			_hx_tmp1 = false;
            		}
HXDLIN( 240)		if (_hx_tmp1) {
HXLINE( 240)			totalCount = count;
            		}
HXLINE( 241)		::Math_obj::ceil(((Float)totalCount / (Float)numValues));
HXLINE( 242)		HX_VARI( Int,iIndex) = (int)0;
HXLINE( 244)		HX_VARI( Int,tileID) = (int)-1;
HXLINE( 245)		HX_VARI(  ::openfl::geom::Rectangle,rect) = sheet->_hx___rectTile;
HXLINE( 246)		HX_VARI(  ::openfl::geom::Rectangle,tileUV) = sheet->_hx___rectUV;
HXLINE( 247)		HX_VARI(  ::openfl::geom::Point,center) = sheet->_hx___point;
HXLINE( 248)		HX_VARI( Float,x) = ((Float)0.0);
HXDLIN( 248)		HX_VARI( Float,y) = ((Float)0.0);
HXLINE( 249)		HX_VARI( Float,alpha) = ((Float)1.0);
HXDLIN( 249)		HX_VARI( Int,tint) = (int)16777215;
HXLINE( 250)		HX_VARI( Float,scale) = ((Float)1.0);
HXDLIN( 250)		HX_VARI( Float,rotation) = ((Float)0.0);
HXLINE( 251)		HX_VARI( Float,cosTheta) = ((Float)1.0);
HXDLIN( 251)		HX_VARI( Float,sinTheta) = ((Float)0.0);
HXLINE( 252)		HX_VARI( Float,a) = ((Float)0.0);
HXDLIN( 252)		HX_VARI( Float,b) = ((Float)0.0);
HXDLIN( 252)		HX_VARI( Float,c) = ((Float)0.0);
HXDLIN( 252)		HX_VARI( Float,d) = ((Float)0.0);
HXDLIN( 252)		HX_VARI( Float,tx) = ((Float)0.0);
HXDLIN( 252)		HX_VARI( Float,ty) = ((Float)0.0);
HXLINE( 253)		HX_VARI( Float,ox) = ((Float)0.0);
HXDLIN( 253)		HX_VARI( Float,oy) = ((Float)0.0);
HXLINE( 255)		HX_VARI(  ::openfl::geom::Matrix,oMatrix) = object->_hx___worldTransform;
HXLINE( 257)		HX_VARI( Int,bIndex) = (int)0;
HXLINE( 258)		HX_VARI( Float,tMa) = ((Float)1.0);
HXDLIN( 258)		HX_VARI( Float,tMb) = ((Float)0.0);
HXLINE( 259)		HX_VARI( Float,tMc) = ((Float)0.0);
HXDLIN( 259)		HX_VARI( Float,tMd) = ((Float)1.0);
HXLINE( 260)		HX_VARI( Float,tMtx) = ((Float)0.0);
HXDLIN( 260)		HX_VARI( Float,tMty) = ((Float)0.0);
HXLINE( 262)		HX_VARI( Float,oMa) = oMatrix->a;
HXLINE( 263)		HX_VARI( Float,oMb) = oMatrix->b;
HXLINE( 264)		HX_VARI( Float,oMc) = oMatrix->c;
HXLINE( 265)		HX_VARI( Float,oMd) = oMatrix->d;
HXLINE( 266)		HX_VARI( Float,oMtx) = oMatrix->tx;
HXLINE( 267)		HX_VARI( Float,oMty) = oMatrix->ty;
HXLINE( 269)		HX_VARI( Float,rw) = ((Float)0.0);
HXDLIN( 269)		HX_VARI( Float,rh) = ((Float)0.0);
HXLINE( 270)		HX_VARI( Float,tuvx) = ((Float)0.0);
HXDLIN( 270)		HX_VARI( Float,tuvy) = ((Float)0.0);
HXDLIN( 270)		HX_VARI( Float,tuvw) = ((Float)0.0);
HXDLIN( 270)		HX_VARI( Float,tuvh) = ((Float)0.0);
HXLINE( 273)		{
HXLINE( 273)			this->enableColor = true;
HXDLIN( 273)			Bool _hx_tmp2 = (this->enableColor != this->lastEnableColor);
HXDLIN( 273)			if (_hx_tmp2) {
HXLINE( 273)				this->flush();
HXDLIN( 273)				this->lastEnableColor = this->enableColor;
            			}
HXDLIN( 273)			this->attributes->__get((int)2).StaticCast<  ::openfl::_internal::renderer::opengl::utils::VertexAttribute >()->enabled = this->lastEnableColor;
HXDLIN( 273)			HX_VARI( Int,r) = (int)0;
HXDLIN( 273)			{
HXLINE( 273)				HX_VARI( Int,_g) = (int)0;
HXDLIN( 273)				HX_VARI( ::Array< ::Dynamic>,_g1) = this->attributes;
HXDLIN( 273)				while((_g < _g1->length)){
HXLINE( 273)					HX_VARI_NAME(  ::openfl::_internal::renderer::opengl::utils::VertexAttribute,a1,"a") = _g1->__get(_g).StaticCast<  ::openfl::_internal::renderer::opengl::utils::VertexAttribute >();
HXDLIN( 273)					++_g;
HXDLIN( 273)					Bool _hx_tmp3 = a1->enabled;
HXDLIN( 273)					if (_hx_tmp3) {
HXLINE( 273)						HX_VARI_NAME( Int,_g2,"_g") = a1->type;
HXDLIN( 273)						Int _hx_tmp4;
HXDLIN( 273)						switch((int)(_g2)){
            							case (int)5120: case (int)5121: {
HXLINE( 273)								_hx_tmp4 = (int)1;
            							}
            							break;
            							case (int)5122: case (int)5123: {
HXLINE( 273)								_hx_tmp4 = (int)2;
            							}
            							break;
            							default:{
HXLINE( 273)								_hx_tmp4 = (int)4;
            							}
            						}
HXDLIN( 273)						Float _hx_tmp5 = ((Float)(a1->components * _hx_tmp4) / (Float)(int)4);
HXDLIN( 273)						Int _hx_tmp6 = ::Math_obj::floor(_hx_tmp5);
HXDLIN( 273)						hx::AddEq(r,_hx_tmp6);
            					}
            				}
            			}
HXDLIN( 273)			this->elementsPerVertex = r;
            		}
HXLINE( 275)		Bool _hx_tmp7 = hx::IsNotNull( flashShader );
HXDLIN( 275)		if (_hx_tmp7) {
HXLINE( 275)			flashShader->_hx___init(this->gl);
HXDLIN( 275)			flashShader->_hx___shader->wrapS = flashShader->repeatX;
HXDLIN( 275)			flashShader->_hx___shader->wrapT = flashShader->repeatY;
HXDLIN( 275)			flashShader->_hx___shader->smooth = flashShader->smooth;
HXDLIN( 275)			flashShader->_hx___shader->blendMode = flashShader->blendMode;
HXDLIN( 275)			HX_VARI(  ::openfl::display::GLShaderParameter,objSize) = flashShader->data->get(::openfl::display::Shader_obj::uObjectSize).StaticCast<  ::openfl::display::GLShaderParameter >();
HXDLIN( 275)			HX_VARI(  ::openfl::display::GLShaderParameter,texSize) = flashShader->data->get(::openfl::display::Shader_obj::uTextureSize).StaticCast<  ::openfl::display::GLShaderParameter >();
HXDLIN( 275)			{
HXLINE( 275)				objSize->value[(int)0] = (int)0;
HXDLIN( 275)				objSize->value[(int)1] = (int)0;
HXDLIN( 275)				texSize->value[(int)0] = (int)0;
HXDLIN( 275)				texSize->value[(int)1] = (int)0;
            			}
            		}
HXLINE( 277)		while((iIndex < totalCount)){
HXLINE( 279)			Bool _hx_tmp8 = (this->batchedSprites >= this->maxSprites);
HXDLIN( 279)			if (_hx_tmp8) {
HXLINE( 280)				this->flush();
            			}
HXLINE( 283)			x = tileData->__get(iIndex);
HXLINE( 284)			y = tileData->__get((iIndex + (int)1));
HXLINE( 286)			if (useRect) {
HXLINE( 287)				tileID = (int)-1;
HXLINE( 289)				rect->x = tileData->__get((iIndex + (int)2));
HXLINE( 290)				rect->y = tileData->__get((iIndex + (int)3));
HXLINE( 291)				rect->width = tileData->__get((iIndex + (int)4));
HXLINE( 292)				rect->height = tileData->__get((iIndex + (int)5));
HXLINE( 294)				if (useOrigin) {
HXLINE( 295)					center->x = tileData->__get((iIndex + (int)6));
HXLINE( 296)					center->y = tileData->__get((iIndex + (int)7));
            				}
            				else {
HXLINE( 298)					center->setTo((int)0,(int)0);
            				}
HXLINE( 301)				rw = rect->width;
HXDLIN( 301)				rh = rect->height;
HXLINE( 302)				Float _hx_tmp9 = rect->get_left();
HXDLIN( 302)				tuvx = ((Float)_hx_tmp9 / (Float)sheet->_hx___bitmap->width);
HXLINE( 303)				Float _hx_tmp10 = rect->get_top();
HXDLIN( 303)				tuvy = ((Float)_hx_tmp10 / (Float)sheet->_hx___bitmap->height);
HXLINE( 304)				Float _hx_tmp11 = rect->get_right();
HXDLIN( 304)				tuvw = ((Float)_hx_tmp11 / (Float)sheet->_hx___bitmap->width);
HXLINE( 305)				Float _hx_tmp12 = rect->get_bottom();
HXDLIN( 305)				tuvh = ((Float)_hx_tmp12 / (Float)sheet->_hx___bitmap->height);
            			}
            			else {
HXLINE( 307)				Float _hx_tmp13 = tileData->__get((iIndex + (int)2));
HXDLIN( 307)				tileID = ::Std_obj::_hx_int(_hx_tmp13);
HXLINE( 308)				rect = sheet->_hx___tileRects->__get(tileID).StaticCast<  ::openfl::geom::Rectangle >();
HXLINE( 309)				center = sheet->_hx___centerPoints->__get(tileID).StaticCast<  ::openfl::geom::Point >();
HXLINE( 310)				tileUV = sheet->_hx___tileUVs->__get(tileID).StaticCast<  ::openfl::geom::Rectangle >();
HXLINE( 312)				Bool _hx_tmp14 = hx::IsNotNull( rect );
HXDLIN( 312)				if (_hx_tmp14) {
HXLINE( 313)					rw = rect->width;
HXDLIN( 313)					rh = rect->height;
HXLINE( 314)					tuvx = tileUV->x;
HXDLIN( 314)					tuvy = tileUV->y;
HXDLIN( 314)					tuvw = tileUV->width;
HXDLIN( 314)					tuvh = tileUV->height;
            				}
            			}
HXLINE( 318)			Bool _hx_tmp15;
HXDLIN( 318)			Bool _hx_tmp16;
HXDLIN( 318)			Bool _hx_tmp17;
HXDLIN( 318)			Bool _hx_tmp18 = hx::IsNotNull( rect );
HXDLIN( 318)			if (_hx_tmp18) {
HXLINE( 318)				_hx_tmp17 = (rect->width > (int)0);
            			}
            			else {
HXLINE( 318)				_hx_tmp17 = false;
            			}
HXDLIN( 318)			if (_hx_tmp17) {
HXLINE( 318)				_hx_tmp16 = (rect->height > (int)0);
            			}
            			else {
HXLINE( 318)				_hx_tmp16 = false;
            			}
HXDLIN( 318)			if (_hx_tmp16) {
HXLINE( 318)				_hx_tmp15 = hx::IsNotNull( center );
            			}
            			else {
HXLINE( 318)				_hx_tmp15 = false;
            			}
HXDLIN( 318)			if (_hx_tmp15) {
HXLINE( 320)				alpha = (int)1;
HXLINE( 321)				tint = (int)16777215;
HXLINE( 322)				scale = ((Float)1.0);
HXLINE( 323)				rotation = ((Float)0.0);
HXLINE( 324)				cosTheta = ((Float)1.0);
HXLINE( 325)				sinTheta = ((Float)0.0);
HXLINE( 327)				if (useAlpha) {
HXLINE( 328)					alpha = (tileData->__get((iIndex + alphaIndex)) * object->_hx___worldAlpha);
            				}
            				else {
HXLINE( 330)					alpha = object->_hx___worldAlpha;
            				}
HXLINE( 333)				if (useRGB) {
HXLINE( 334)					Float _hx_tmp19 = tileData->__get((iIndex + rgbIndex));
HXDLIN( 334)					Int _hx_tmp20 = ::Std_obj::_hx_int((_hx_tmp19 * (int)255));
HXDLIN( 334)					Int _hx_tmp21 = ((int)_hx_tmp20 << (int)(int)16);
HXDLIN( 334)					Float _hx_tmp22 = (tileData->__get(((iIndex + rgbIndex) + (int)1)) * (int)255);
HXDLIN( 334)					Int _hx_tmp23 = ::Std_obj::_hx_int(_hx_tmp22);
HXDLIN( 334)					Int _hx_tmp24 = ((int)_hx_tmp21 | (int)((int)_hx_tmp23 << (int)(int)8));
HXDLIN( 334)					Float _hx_tmp25 = (tileData->__get(((iIndex + rgbIndex) + (int)2)) * (int)255);
HXDLIN( 334)					Int _hx_tmp26 = ::Std_obj::_hx_int(_hx_tmp25);
HXDLIN( 334)					tint = ((int)_hx_tmp24 | (int)_hx_tmp26);
            				}
HXLINE( 337)				HX_VARI(  ::openfl::geom::ColorTransform,wct) = object->_hx___worldColorTransform;
HXLINE( 338)				this->colorTransform->redMultiplier = wct->redMultiplier;
HXLINE( 339)				this->colorTransform->greenMultiplier = wct->greenMultiplier;
HXLINE( 340)				this->colorTransform->blueMultiplier = wct->blueMultiplier;
HXLINE( 341)				this->colorTransform->alphaMultiplier = wct->alphaMultiplier;
HXLINE( 342)				this->colorTransform->redOffset = wct->redOffset;
HXLINE( 343)				this->colorTransform->greenOffset = wct->greenOffset;
HXLINE( 344)				this->colorTransform->blueOffset = wct->blueOffset;
HXLINE( 345)				this->colorTransform->alphaOffset = wct->alphaOffset;
HXLINE( 347)				if (useRGBOffset) {
HXLINE( 348)					hx::AddEq(this->colorTransform->redOffset,tileData->__get((iIndex + rgbOffsetIndex)));
HXLINE( 349)					hx::AddEq(this->colorTransform->greenOffset,tileData->__get(((iIndex + rgbOffsetIndex) + (int)1)));
HXLINE( 350)					hx::AddEq(this->colorTransform->blueOffset,tileData->__get(((iIndex + rgbOffsetIndex) + (int)2)));
HXLINE( 351)					hx::AddEq(this->colorTransform->alphaOffset,tileData->__get(((iIndex + rgbOffsetIndex) + (int)3)));
            				}
HXLINE( 354)				if (useScale) {
HXLINE( 355)					scale = tileData->__get((iIndex + scaleIndex));
            				}
HXLINE( 358)				if (useRotation) {
HXLINE( 359)					rotation = tileData->__get((iIndex + rotationIndex));
HXLINE( 360)					cosTheta = ::Math_obj::cos(rotation);
HXLINE( 361)					sinTheta = ::Math_obj::sin(rotation);
            				}
HXLINE( 364)				if (useTransform) {
HXLINE( 365)					a = tileData->__get((iIndex + transformIndex));
HXLINE( 366)					b = tileData->__get(((iIndex + transformIndex) + (int)1));
HXLINE( 367)					c = tileData->__get(((iIndex + transformIndex) + (int)2));
HXLINE( 368)					d = tileData->__get(((iIndex + transformIndex) + (int)3));
            				}
            				else {
HXLINE( 370)					a = (scale * cosTheta);
HXLINE( 371)					b = (scale * sinTheta);
HXLINE( 372)					c = -(b);
HXLINE( 373)					d = a;
            				}
HXLINE( 376)				ox = ((center->x * a) + (center->y * c));
HXLINE( 377)				oy = ((center->x * b) + (center->y * d));
HXLINE( 379)				tx = (x - ox);
HXLINE( 380)				ty = (y - oy);
HXLINE( 384)				tMa = (((a * oMa) + (b * oMc)) * rw);
HXLINE( 385)				tMb = (((a * oMb) + (b * oMd)) * rw);
HXLINE( 386)				tMc = (((c * oMa) + (d * oMc)) * rh);
HXLINE( 387)				tMd = (((c * oMb) + (d * oMd)) * rh);
HXLINE( 388)				tMtx = (((tx * oMa) + (ty * oMc)) + oMtx);
HXLINE( 389)				tMty = (((tx * oMb) + (ty * oMd)) + oMty);
HXLINE( 391)				bIndex = ((this->batchedSprites * (int)4) * this->elementsPerVertex);
HXLINE( 393)				{
HXLINE( 393)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this1,"this") = this->positions;
HXDLIN( 393)					{
HXLINE( 393)						Int byteOffset = (this1->byteOffset + (bIndex * (int)4));
HXDLIN( 393)						::__hxcpp_memory_set_float(this1->buffer->b,byteOffset,tMtx);
            					}
            				}
HXLINE( 394)				{
HXLINE( 394)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this2,"this") = this->positions;
HXDLIN( 394)					{
HXLINE( 394)						Int byteOffset1 = (this2->byteOffset + ((bIndex + (int)1) * (int)4));
HXDLIN( 394)						::__hxcpp_memory_set_float(this2->buffer->b,byteOffset1,tMty);
            					}
            				}
HXLINE( 395)				{
HXLINE( 395)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this3,"this") = this->positions;
HXDLIN( 395)					{
HXLINE( 395)						Int byteOffset2 = (this3->byteOffset + ((bIndex + (int)5) * (int)4));
HXDLIN( 395)						::__hxcpp_memory_set_float(this3->buffer->b,byteOffset2,(tMa + tMtx));
            					}
            				}
HXLINE( 396)				{
HXLINE( 396)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this4,"this") = this->positions;
HXDLIN( 396)					{
HXLINE( 396)						Int byteOffset3 = (this4->byteOffset + ((bIndex + (int)6) * (int)4));
HXDLIN( 396)						::__hxcpp_memory_set_float(this4->buffer->b,byteOffset3,(tMb + tMty));
            					}
            				}
HXLINE( 397)				{
HXLINE( 397)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this5,"this") = this->positions;
HXDLIN( 397)					{
HXLINE( 397)						Int byteOffset4 = (this5->byteOffset + ((bIndex + (int)10) * (int)4));
HXDLIN( 397)						::__hxcpp_memory_set_float(this5->buffer->b,byteOffset4,((tMa + tMc) + tMtx));
            					}
            				}
HXLINE( 398)				{
HXLINE( 398)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this6,"this") = this->positions;
HXDLIN( 398)					{
HXLINE( 398)						Int byteOffset5 = (this6->byteOffset + ((bIndex + (int)11) * (int)4));
HXDLIN( 398)						::__hxcpp_memory_set_float(this6->buffer->b,byteOffset5,((tMd + tMb) + tMty));
            					}
            				}
HXLINE( 399)				{
HXLINE( 399)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this7,"this") = this->positions;
HXDLIN( 399)					{
HXLINE( 399)						Int byteOffset6 = (this7->byteOffset + ((bIndex + (int)15) * (int)4));
HXDLIN( 399)						::__hxcpp_memory_set_float(this7->buffer->b,byteOffset6,(tMc + tMtx));
            					}
            				}
HXLINE( 400)				{
HXLINE( 400)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this8,"this") = this->positions;
HXDLIN( 400)					{
HXLINE( 400)						Int byteOffset7 = (this8->byteOffset + ((bIndex + (int)16) * (int)4));
HXDLIN( 400)						::__hxcpp_memory_set_float(this8->buffer->b,byteOffset7,(tMd + tMty));
            					}
            				}
HXLINE( 402)				{
HXLINE( 402)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this9,"this") = this->colors;
HXDLIN( 402)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this10,"this") = this->colors;
HXDLIN( 402)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this11,"this") = this->colors;
HXDLIN( 402)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this12,"this") = this->colors;
HXDLIN( 402)					Int _hx_tmp27 = ::Std_obj::_hx_int((alpha * (int)255));
HXDLIN( 402)					HX_VARI( Int,val) = ((int)((int)((int)_hx_tmp27 & (int)(int)255) << (int)(int)24) | (int)tint);
HXDLIN( 402)					Int byteOffset8 = (this12->byteOffset + ((bIndex + (int)19) * (int)4));
HXDLIN( 402)					::__hxcpp_memory_set_ui32(this12->buffer->b,byteOffset8,val);
HXDLIN( 402)					Int byteOffset9 = (this11->byteOffset + ((bIndex + (int)14) * (int)4));
HXDLIN( 402)					::__hxcpp_memory_set_ui32(this11->buffer->b,byteOffset9,val);
HXDLIN( 402)					Int byteOffset10 = (this10->byteOffset + ((bIndex + (int)9) * (int)4));
HXDLIN( 402)					::__hxcpp_memory_set_ui32(this10->buffer->b,byteOffset10,val);
HXDLIN( 402)					{
HXLINE( 402)						Int byteOffset11 = (this9->byteOffset + ((bIndex + (int)4) * (int)4));
HXDLIN( 402)						::__hxcpp_memory_set_ui32(this9->buffer->b,byteOffset11,val);
            					}
            				}
HXLINE( 404)				{
HXLINE( 404)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this13,"this") = this->positions;
HXDLIN( 404)					{
HXLINE( 404)						Int byteOffset12 = (this13->byteOffset + ((bIndex + (int)2) * (int)4));
HXDLIN( 404)						::__hxcpp_memory_set_float(this13->buffer->b,byteOffset12,tuvx);
            					}
            				}
HXLINE( 405)				{
HXLINE( 405)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this14,"this") = this->positions;
HXDLIN( 405)					{
HXLINE( 405)						Int byteOffset13 = (this14->byteOffset + ((bIndex + (int)3) * (int)4));
HXDLIN( 405)						::__hxcpp_memory_set_float(this14->buffer->b,byteOffset13,tuvy);
            					}
            				}
HXLINE( 406)				{
HXLINE( 406)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this15,"this") = this->positions;
HXDLIN( 406)					{
HXLINE( 406)						Int byteOffset14 = (this15->byteOffset + ((bIndex + (int)7) * (int)4));
HXDLIN( 406)						::__hxcpp_memory_set_float(this15->buffer->b,byteOffset14,tuvw);
            					}
            				}
HXLINE( 407)				{
HXLINE( 407)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this16,"this") = this->positions;
HXDLIN( 407)					{
HXLINE( 407)						Int byteOffset15 = (this16->byteOffset + ((bIndex + (int)8) * (int)4));
HXDLIN( 407)						::__hxcpp_memory_set_float(this16->buffer->b,byteOffset15,tuvy);
            					}
            				}
HXLINE( 408)				{
HXLINE( 408)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this17,"this") = this->positions;
HXDLIN( 408)					{
HXLINE( 408)						Int byteOffset16 = (this17->byteOffset + ((bIndex + (int)12) * (int)4));
HXDLIN( 408)						::__hxcpp_memory_set_float(this17->buffer->b,byteOffset16,tuvw);
            					}
            				}
HXLINE( 409)				{
HXLINE( 409)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this18,"this") = this->positions;
HXDLIN( 409)					{
HXLINE( 409)						Int byteOffset17 = (this18->byteOffset + ((bIndex + (int)13) * (int)4));
HXDLIN( 409)						::__hxcpp_memory_set_float(this18->buffer->b,byteOffset17,tuvh);
            					}
            				}
HXLINE( 410)				{
HXLINE( 410)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this19,"this") = this->positions;
HXDLIN( 410)					{
HXLINE( 410)						Int byteOffset18 = (this19->byteOffset + ((bIndex + (int)17) * (int)4));
HXDLIN( 410)						::__hxcpp_memory_set_float(this19->buffer->b,byteOffset18,tuvx);
            					}
            				}
HXLINE( 411)				{
HXLINE( 411)					HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this20,"this") = this->positions;
HXDLIN( 411)					{
HXLINE( 411)						Int byteOffset19 = (this20->byteOffset + ((bIndex + (int)18) * (int)4));
HXDLIN( 411)						::__hxcpp_memory_set_float(this20->buffer->b,byteOffset19,tuvh);
            					}
            				}
HXLINE( 413)				this->writtenVertexBytes = (bIndex + (int)20);
HXLINE( 415)				{
HXLINE( 415)					HX_VARI( Int,index) = this->batchedSprites;
HXDLIN( 415)					HX_VARI(  ::openfl::geom::ColorTransform,colorTransform) = this->colorTransform;
HXDLIN( 415)					HX_VARI(  ::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State,state) = this->states->__get(index).StaticCast<  ::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State >();
HXDLIN( 415)					Bool _hx_tmp28 = hx::IsNull( state );
HXDLIN( 415)					if (_hx_tmp28) {
HXLINE( 415)						state = (this->states[index] =  ::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State_obj::__new());
            					}
HXDLIN( 415)					state->texture = texture;
HXDLIN( 415)					state->textureSmooth = smooth;
HXDLIN( 415)					state->blendMode = blendMode;
HXDLIN( 415)					Bool _hx_tmp29;
HXDLIN( 415)					Bool _hx_tmp30 = hx::IsNotNull( colorTransform );
HXDLIN( 415)					if (_hx_tmp30) {
HXLINE( 415)						_hx_tmp29 = colorTransform->_hx___isDefault();
            					}
            					else {
HXLINE( 415)						_hx_tmp29 = false;
            					}
HXDLIN( 415)					state->skipColorTransform = _hx_tmp29;
HXDLIN( 415)					Bool _hx_tmp31 = !(state->skipColorTransform);
HXDLIN( 415)					if (_hx_tmp31) {
HXLINE( 415)						state->colorTransform->redMultiplier = colorTransform->redMultiplier;
HXDLIN( 415)						state->colorTransform->greenMultiplier = colorTransform->greenMultiplier;
HXDLIN( 415)						state->colorTransform->blueMultiplier = colorTransform->blueMultiplier;
HXDLIN( 415)						state->colorTransform->alphaMultiplier = colorTransform->alphaMultiplier;
HXDLIN( 415)						state->colorTransform->redOffset = colorTransform->redOffset;
HXDLIN( 415)						state->colorTransform->greenOffset = colorTransform->greenOffset;
HXDLIN( 415)						state->colorTransform->blueOffset = colorTransform->blueOffset;
HXDLIN( 415)						state->colorTransform->alphaOffset = colorTransform->alphaOffset;
            					}
HXDLIN( 415)					state->skipColorTransformAlpha = false;
HXDLIN( 415)					Bool _hx_tmp32 = hx::IsNull( flashShader );
HXDLIN( 415)					if (_hx_tmp32) {
HXLINE( 415)						state->shader = null();
HXDLIN( 415)						state->shaderData = null();
            					}
            					else {
HXLINE( 415)						state->shader = flashShader->_hx___shader;
HXDLIN( 415)						state->shaderData = flashShader->data;
            					}
            				}
HXLINE( 417)				this->batchedSprites++;
            			}
HXLINE( 420)			hx::AddEq(iIndex,numValues);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC7(SpriteBatch_obj,renderTiles,(void))

void SpriteBatch_obj::fillVertices(Int index,Float width,Float height, ::openfl::geom::Matrix matrix, ::openfl::display::TextureUvs uvs,hx::Null< Int >  __o_color, ::Dynamic pixelSnapping){
Int color = __o_color.Default(-1);
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.SpriteBatch","fillVertices",0x1e5d3416,"openfl._internal.renderer.opengl.utils.SpriteBatch.fillVertices","openfl/_internal/renderer/opengl/utils/SpriteBatch.hx",426,0x8289eb2d)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(index,"index")
            	HX_STACK_ARG(width,"width")
            	HX_STACK_ARG(height,"height")
            	HX_STACK_ARG(matrix,"matrix")
            	HX_STACK_ARG(uvs,"uvs")
            	HX_STACK_ARG(color,"color")
            	HX_STACK_ARG(pixelSnapping,"pixelSnapping")
HXLINE( 428)		HX_VARI( Float,a) = matrix->a;
HXLINE( 429)		HX_VARI( Float,b) = matrix->b;
HXLINE( 430)		HX_VARI( Float,c) = matrix->c;
HXLINE( 431)		HX_VARI( Float,d) = matrix->d;
HXLINE( 432)		HX_VARI( Float,tx) = matrix->tx;
HXLINE( 433)		HX_VARI( Float,ty) = matrix->ty;
HXLINE( 436)		Bool _hx_tmp;
HXDLIN( 436)		Bool _hx_tmp1 = hx::IsNotNull( pixelSnapping );
HXDLIN( 436)		if (_hx_tmp1) {
HXLINE( 436)			_hx_tmp = hx::IsEq( pixelSnapping,(int)2 );
            		}
            		else {
HXLINE( 436)			_hx_tmp = true;
            		}
HXDLIN( 436)		if (_hx_tmp) {
HXLINE( 437)			{
HXLINE( 437)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this1,"this") = this->positions;
HXDLIN( 437)				{
HXLINE( 437)					Int byteOffset = (this1->byteOffset + (index * (int)4));
HXDLIN( 437)					::__hxcpp_memory_set_float(this1->buffer->b,byteOffset,tx);
            				}
            			}
HXLINE( 438)			{
HXLINE( 438)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this2,"this") = this->positions;
HXDLIN( 438)				{
HXLINE( 438)					Int byteOffset1 = (this2->byteOffset + ((index + (int)1) * (int)4));
HXDLIN( 438)					::__hxcpp_memory_set_float(this2->buffer->b,byteOffset1,ty);
            				}
            			}
HXLINE( 439)			{
HXLINE( 439)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this3,"this") = this->positions;
HXDLIN( 439)				{
HXLINE( 439)					Int byteOffset2 = (this3->byteOffset + ((index + (int)5) * (int)4));
HXDLIN( 439)					::__hxcpp_memory_set_float(this3->buffer->b,byteOffset2,((a * width) + tx));
            				}
            			}
HXLINE( 440)			{
HXLINE( 440)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this4,"this") = this->positions;
HXDLIN( 440)				{
HXLINE( 440)					Int byteOffset3 = (this4->byteOffset + ((index + (int)6) * (int)4));
HXDLIN( 440)					::__hxcpp_memory_set_float(this4->buffer->b,byteOffset3,((b * width) + ty));
            				}
            			}
HXLINE( 441)			{
HXLINE( 441)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this5,"this") = this->positions;
HXDLIN( 441)				{
HXLINE( 441)					Int byteOffset4 = (this5->byteOffset + ((index + (int)10) * (int)4));
HXDLIN( 441)					::__hxcpp_memory_set_float(this5->buffer->b,byteOffset4,(((a * width) + (c * height)) + tx));
            				}
            			}
HXLINE( 442)			{
HXLINE( 442)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this6,"this") = this->positions;
HXDLIN( 442)				{
HXLINE( 442)					Int byteOffset5 = (this6->byteOffset + ((index + (int)11) * (int)4));
HXDLIN( 442)					::__hxcpp_memory_set_float(this6->buffer->b,byteOffset5,(((d * height) + (b * width)) + ty));
            				}
            			}
HXLINE( 443)			{
HXLINE( 443)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this7,"this") = this->positions;
HXDLIN( 443)				{
HXLINE( 443)					Int byteOffset6 = (this7->byteOffset + ((index + (int)15) * (int)4));
HXDLIN( 443)					::__hxcpp_memory_set_float(this7->buffer->b,byteOffset6,((c * height) + tx));
            				}
            			}
HXLINE( 444)			{
HXLINE( 444)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this8,"this") = this->positions;
HXDLIN( 444)				{
HXLINE( 444)					Int byteOffset7 = (this8->byteOffset + ((index + (int)16) * (int)4));
HXDLIN( 444)					::__hxcpp_memory_set_float(this8->buffer->b,byteOffset7,((d * height) + ty));
            				}
            			}
            		}
            		else {
HXLINE( 446)			{
HXLINE( 446)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this9,"this") = this->positions;
HXDLIN( 446)				HX_VARI( Float,val) = ::Math_obj::fround(tx);
HXDLIN( 446)				{
HXLINE( 446)					Int byteOffset8 = (this9->byteOffset + (index * (int)4));
HXDLIN( 446)					::__hxcpp_memory_set_float(this9->buffer->b,byteOffset8,val);
            				}
            			}
HXLINE( 447)			{
HXLINE( 447)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this10,"this") = this->positions;
HXDLIN( 447)				HX_VARI_NAME( Float,val1,"val") = ::Math_obj::fround(ty);
HXDLIN( 447)				{
HXLINE( 447)					Int byteOffset9 = (this10->byteOffset + ((index + (int)1) * (int)4));
HXDLIN( 447)					::__hxcpp_memory_set_float(this10->buffer->b,byteOffset9,val1);
            				}
            			}
HXLINE( 448)			{
HXLINE( 448)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this11,"this") = this->positions;
HXDLIN( 448)				HX_VARI_NAME( Float,val2,"val") = ::Math_obj::fround(((a * width) + tx));
HXDLIN( 448)				{
HXLINE( 448)					Int byteOffset10 = (this11->byteOffset + ((index + (int)5) * (int)4));
HXDLIN( 448)					::__hxcpp_memory_set_float(this11->buffer->b,byteOffset10,val2);
            				}
            			}
HXLINE( 449)			{
HXLINE( 449)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this12,"this") = this->positions;
HXDLIN( 449)				HX_VARI_NAME( Float,val3,"val") = ::Math_obj::fround(((b * width) + ty));
HXDLIN( 449)				{
HXLINE( 449)					Int byteOffset11 = (this12->byteOffset + ((index + (int)6) * (int)4));
HXDLIN( 449)					::__hxcpp_memory_set_float(this12->buffer->b,byteOffset11,val3);
            				}
            			}
HXLINE( 450)			{
HXLINE( 450)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this13,"this") = this->positions;
HXDLIN( 450)				HX_VARI_NAME( Float,val4,"val") = ::Math_obj::fround((((a * width) + (c * height)) + tx));
HXDLIN( 450)				{
HXLINE( 450)					Int byteOffset12 = (this13->byteOffset + ((index + (int)10) * (int)4));
HXDLIN( 450)					::__hxcpp_memory_set_float(this13->buffer->b,byteOffset12,val4);
            				}
            			}
HXLINE( 451)			{
HXLINE( 451)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this14,"this") = this->positions;
HXDLIN( 451)				HX_VARI_NAME( Float,val5,"val") = ::Math_obj::fround((((d * height) + (b * width)) + ty));
HXDLIN( 451)				{
HXLINE( 451)					Int byteOffset13 = (this14->byteOffset + ((index + (int)11) * (int)4));
HXDLIN( 451)					::__hxcpp_memory_set_float(this14->buffer->b,byteOffset13,val5);
            				}
            			}
HXLINE( 452)			{
HXLINE( 452)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this15,"this") = this->positions;
HXDLIN( 452)				HX_VARI_NAME( Float,val6,"val") = ::Math_obj::fround(((c * height) + tx));
HXDLIN( 452)				{
HXLINE( 452)					Int byteOffset14 = (this15->byteOffset + ((index + (int)15) * (int)4));
HXDLIN( 452)					::__hxcpp_memory_set_float(this15->buffer->b,byteOffset14,val6);
            				}
            			}
HXLINE( 453)			{
HXLINE( 453)				HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this16,"this") = this->positions;
HXDLIN( 453)				HX_VARI_NAME( Float,val7,"val") = ::Math_obj::fround(((d * height) + ty));
HXDLIN( 453)				{
HXLINE( 453)					Int byteOffset15 = (this16->byteOffset + ((index + (int)16) * (int)4));
HXDLIN( 453)					::__hxcpp_memory_set_float(this16->buffer->b,byteOffset15,val7);
            				}
            			}
            		}
HXLINE( 457)		Bool _hx_tmp2 = this->enableColor;
HXDLIN( 457)		if (_hx_tmp2) {
HXLINE( 458)			HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this17,"this") = this->colors;
HXDLIN( 458)			HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this18,"this") = this->colors;
HXDLIN( 458)			HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this19,"this") = this->colors;
HXDLIN( 458)			HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this20,"this") = this->colors;
HXDLIN( 458)			Int byteOffset16 = (this20->byteOffset + ((index + (int)19) * (int)4));
HXDLIN( 458)			::__hxcpp_memory_set_ui32(this20->buffer->b,byteOffset16,color);
HXDLIN( 458)			HX_VARI_NAME( Int,val8,"val") = color;
HXDLIN( 458)			Int byteOffset17 = (this19->byteOffset + ((index + (int)14) * (int)4));
HXDLIN( 458)			::__hxcpp_memory_set_ui32(this19->buffer->b,byteOffset17,val8);
HXDLIN( 458)			Int byteOffset18 = (this18->byteOffset + ((index + (int)9) * (int)4));
HXDLIN( 458)			::__hxcpp_memory_set_ui32(this18->buffer->b,byteOffset18,val8);
HXDLIN( 458)			{
HXLINE( 458)				Int byteOffset19 = (this17->byteOffset + ((index + (int)4) * (int)4));
HXDLIN( 458)				::__hxcpp_memory_set_ui32(this17->buffer->b,byteOffset19,val8);
            			}
            		}
HXLINE( 462)		{
HXLINE( 462)			HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this21,"this") = this->positions;
HXDLIN( 462)			HX_VARI_NAME( Float,val9,"val") = uvs->x0;
HXDLIN( 462)			{
HXLINE( 462)				Int byteOffset20 = (this21->byteOffset + ((index + (int)2) * (int)4));
HXDLIN( 462)				::__hxcpp_memory_set_float(this21->buffer->b,byteOffset20,val9);
            			}
            		}
HXLINE( 463)		{
HXLINE( 463)			HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this22,"this") = this->positions;
HXDLIN( 463)			HX_VARI_NAME( Float,val10,"val") = uvs->y0;
HXDLIN( 463)			{
HXLINE( 463)				Int byteOffset21 = (this22->byteOffset + ((index + (int)3) * (int)4));
HXDLIN( 463)				::__hxcpp_memory_set_float(this22->buffer->b,byteOffset21,val10);
            			}
            		}
HXLINE( 464)		{
HXLINE( 464)			HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this23,"this") = this->positions;
HXDLIN( 464)			HX_VARI_NAME( Float,val11,"val") = uvs->x1;
HXDLIN( 464)			{
HXLINE( 464)				Int byteOffset22 = (this23->byteOffset + ((index + (int)7) * (int)4));
HXDLIN( 464)				::__hxcpp_memory_set_float(this23->buffer->b,byteOffset22,val11);
            			}
            		}
HXLINE( 465)		{
HXLINE( 465)			HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this24,"this") = this->positions;
HXDLIN( 465)			HX_VARI_NAME( Float,val12,"val") = uvs->y1;
HXDLIN( 465)			{
HXLINE( 465)				Int byteOffset23 = (this24->byteOffset + ((index + (int)8) * (int)4));
HXDLIN( 465)				::__hxcpp_memory_set_float(this24->buffer->b,byteOffset23,val12);
            			}
            		}
HXLINE( 466)		{
HXLINE( 466)			HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this25,"this") = this->positions;
HXDLIN( 466)			HX_VARI_NAME( Float,val13,"val") = uvs->x2;
HXDLIN( 466)			{
HXLINE( 466)				Int byteOffset24 = (this25->byteOffset + ((index + (int)12) * (int)4));
HXDLIN( 466)				::__hxcpp_memory_set_float(this25->buffer->b,byteOffset24,val13);
            			}
            		}
HXLINE( 467)		{
HXLINE( 467)			HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this26,"this") = this->positions;
HXDLIN( 467)			HX_VARI_NAME( Float,val14,"val") = uvs->y2;
HXDLIN( 467)			{
HXLINE( 467)				Int byteOffset25 = (this26->byteOffset + ((index + (int)13) * (int)4));
HXDLIN( 467)				::__hxcpp_memory_set_float(this26->buffer->b,byteOffset25,val14);
            			}
            		}
HXLINE( 468)		{
HXLINE( 468)			HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this27,"this") = this->positions;
HXDLIN( 468)			HX_VARI_NAME( Float,val15,"val") = uvs->x3;
HXDLIN( 468)			{
HXLINE( 468)				Int byteOffset26 = (this27->byteOffset + ((index + (int)17) * (int)4));
HXDLIN( 468)				::__hxcpp_memory_set_float(this27->buffer->b,byteOffset26,val15);
            			}
            		}
HXLINE( 469)		{
HXLINE( 469)			HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this28,"this") = this->positions;
HXDLIN( 469)			HX_VARI_NAME( Float,val16,"val") = uvs->y3;
HXDLIN( 469)			{
HXLINE( 469)				Int byteOffset27 = (this28->byteOffset + ((index + (int)18) * (int)4));
HXDLIN( 469)				::__hxcpp_memory_set_float(this28->buffer->b,byteOffset27,val16);
            			}
            		}
HXLINE( 471)		this->writtenVertexBytes = (index + (int)20);
            	}


HX_DEFINE_DYNAMIC_FUNC7(SpriteBatch_obj,fillVertices,(void))

void SpriteBatch_obj::enableAttributes( ::Dynamic __o_color){
 ::Dynamic color = __o_color.Default(-1);
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.SpriteBatch","enableAttributes",0x7705b0b4,"openfl._internal.renderer.opengl.utils.SpriteBatch.enableAttributes","openfl/_internal/renderer/opengl/utils/SpriteBatch.hx",474,0x8289eb2d)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(color,"color")
HXLINE( 475)		this->enableColor = hx::IsNotEq( color,(int)-1 );
HXLINE( 477)		Bool _hx_tmp = (this->enableColor != this->lastEnableColor);
HXDLIN( 477)		if (_hx_tmp) {
HXLINE( 478)			this->flush();
HXLINE( 479)			this->lastEnableColor = this->enableColor;
            		}
HXLINE( 482)		this->attributes->__get((int)2).StaticCast<  ::openfl::_internal::renderer::opengl::utils::VertexAttribute >()->enabled = this->lastEnableColor;
HXLINE( 484)		HX_VARI( Int,r) = (int)0;
HXDLIN( 484)		{
HXLINE( 484)			HX_VARI( Int,_g) = (int)0;
HXDLIN( 484)			HX_VARI( ::Array< ::Dynamic>,_g1) = this->attributes;
HXDLIN( 484)			while((_g < _g1->length)){
HXLINE( 484)				HX_VARI(  ::openfl::_internal::renderer::opengl::utils::VertexAttribute,a) = _g1->__get(_g).StaticCast<  ::openfl::_internal::renderer::opengl::utils::VertexAttribute >();
HXDLIN( 484)				++_g;
HXDLIN( 484)				Bool _hx_tmp1 = a->enabled;
HXDLIN( 484)				if (_hx_tmp1) {
HXLINE( 484)					HX_VARI_NAME( Int,_g2,"_g") = a->type;
HXDLIN( 484)					Int _hx_tmp2;
HXDLIN( 484)					switch((int)(_g2)){
            						case (int)5120: case (int)5121: {
HXLINE( 484)							_hx_tmp2 = (int)1;
            						}
            						break;
            						case (int)5122: case (int)5123: {
HXLINE( 484)							_hx_tmp2 = (int)2;
            						}
            						break;
            						default:{
HXLINE( 484)							_hx_tmp2 = (int)4;
            						}
            					}
HXDLIN( 484)					Float _hx_tmp3 = ((Float)(a->components * _hx_tmp2) / (Float)(int)4);
HXDLIN( 484)					Int _hx_tmp4 = ::Math_obj::floor(_hx_tmp3);
HXDLIN( 484)					hx::AddEq(r,_hx_tmp4);
            				}
            			}
            		}
HXDLIN( 484)		this->elementsPerVertex = r;
            	}


HX_DEFINE_DYNAMIC_FUNC1(SpriteBatch_obj,enableAttributes,(void))

void SpriteBatch_obj::flush(){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.SpriteBatch","flush",0xaa58290a,"openfl._internal.renderer.opengl.utils.SpriteBatch.flush","openfl/_internal/renderer/opengl/utils/SpriteBatch.hx",487,0x8289eb2d)
            	HX_STACK_THIS(this)
HXLINE( 488)		if ((this->batchedSprites == (int)0)) {
HXLINE( 488)			return;
            		}
HXLINE( 490)		Bool _hx_tmp = hx::IsNotNull( this->clipRect );
HXDLIN( 490)		if (_hx_tmp) {
HXLINE( 491)			{
HXLINE( 491)				Int cap = this->gl->SCISSOR_TEST;
HXDLIN( 491)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_enable(cap);
            			}
HXLINE( 492)			{
HXLINE( 492)				Int x = ::Math_obj::floor(this->clipRect->x);
HXDLIN( 492)				Int y = ::Math_obj::floor(this->clipRect->y);
HXDLIN( 492)				Int width = ::Math_obj::ceil(this->clipRect->width);
HXDLIN( 492)				Int height = ::Math_obj::ceil(this->clipRect->height);
HXDLIN( 492)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_scissor(x,y,width,height);
            			}
            		}
HXLINE( 499)		Bool _hx_tmp1 = this->dirty;
HXDLIN( 499)		if (_hx_tmp1) {
HXLINE( 500)			this->dirty = false;
HXLINE( 502)			this->renderSession->activeTextures = (int)1;
HXLINE( 503)			{
HXLINE( 503)				HX_VARI(  ::openfl::_internal::renderer::opengl::utils::VertexArray,_this) = this->vertexArray;
HXDLIN( 503)				{
HXLINE( 503)					Int target = _this->gl->ARRAY_BUFFER;
HXDLIN( 503)					HX_VARI(  ::lime::graphics::opengl::GLBuffer,buffer) = _this->glBuffer;
HXDLIN( 503)					{
HXLINE( 503)						Int buffer1;
HXDLIN( 503)						Bool _hx_tmp2 = hx::IsNull( buffer );
HXDLIN( 503)						if (_hx_tmp2) {
HXLINE( 503)							buffer1 = (int)0;
            						}
            						else {
HXLINE( 503)							buffer1 = buffer->id;
            						}
HXDLIN( 503)						::lime::graphics::opengl::GL_obj::cffi_lime_gl_bind_buffer(target,buffer1);
            					}
            				}
            			}
HXLINE( 504)			{
HXLINE( 504)				Int target1 = this->gl->ELEMENT_ARRAY_BUFFER;
HXDLIN( 504)				HX_VARI_NAME(  ::lime::graphics::opengl::GLBuffer,buffer2,"buffer") = this->indexBuffer;
HXDLIN( 504)				{
HXLINE( 504)					Int buffer3;
HXDLIN( 504)					Bool _hx_tmp3 = hx::IsNull( buffer2 );
HXDLIN( 504)					if (_hx_tmp3) {
HXLINE( 504)						buffer3 = (int)0;
            					}
            					else {
HXLINE( 504)						buffer3 = buffer2->id;
            					}
HXDLIN( 504)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_bind_buffer(target1,buffer3);
            				}
            			}
            		}
HXLINE( 507)		Bool _hx_tmp4 = (this->writtenVertexBytes > (this->vertexArraySize * ((Float)0.5)));
HXDLIN( 507)		if (_hx_tmp4) {
HXLINE( 508)			this->vertexArray->upload(this->positions);
            		}
            		else {
HXLINE( 510)			HX_VARI_NAME(  ::lime::utils::ArrayBufferView,this1,"this") = this->positions;
HXDLIN( 510)			HX_VARI(  ::Dynamic,end) = this->writtenVertexBytes;
HXDLIN( 510)			Bool _hx_tmp5 = hx::IsNull( end );
HXDLIN( 510)			HX_VARI( Int,len) = end;
HXDLIN( 510)			HX_VARI( Int,byte_offset) = ((int)0 * this1->bytesPerElement);
HXDLIN( 510)			HX_VAR(  ::lime::utils::ArrayBufferView,view);
HXDLIN( 510)			HX_VARI( Int,_g) = this1->type;
HXDLIN( 510)			switch((int)(_g)){
            				case (int)0: {
HXLINE( 510)					HX_STACK_DO_THROW(HX_("subarray on a blank ArrayBufferView",39,87,fd,19));
            				}
            				break;
            				case (int)1: {
HXLINE( 510)					HX_VARI_NAME(  ::haxe::io::Bytes,buffer4,"buffer") = this1->buffer;
HXDLIN( 510)					HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this2,"this");
HXDLIN( 510)					Bool _hx_tmp6 = hx::IsNotNull( buffer4 );
HXDLIN( 510)					if (_hx_tmp6) {
HXLINE( 510)						HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this1,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)1);
HXDLIN( 510)						if ((byte_offset < (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						if ((hx::Mod(byte_offset,_this1->bytesPerElement) != (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						HX_VARI( Int,bufferByteLength) = buffer4->length;
HXDLIN( 510)						HX_VARI( Int,newByteLength) = bufferByteLength;
HXDLIN( 510)						Bool _hx_tmp7 = hx::IsNull( len );
HXDLIN( 510)						if (_hx_tmp7) {
HXLINE( 510)							newByteLength = (bufferByteLength - byte_offset);
HXDLIN( 510)							if ((hx::Mod(bufferByteLength,_this1->bytesPerElement) != (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
HXDLIN( 510)							if ((newByteLength < (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
            						else {
HXLINE( 510)							newByteLength = (len * _this1->bytesPerElement);
HXDLIN( 510)							if (((byte_offset + newByteLength) > bufferByteLength)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
HXDLIN( 510)						_this1->buffer = buffer4;
HXDLIN( 510)						_this1->byteOffset = byte_offset;
HXDLIN( 510)						_this1->byteLength = newByteLength;
HXDLIN( 510)						Float _hx_tmp8 = ((Float)newByteLength / (Float)_this1->bytesPerElement);
HXDLIN( 510)						_this1->length = ::Std_obj::_hx_int(_hx_tmp8);
HXDLIN( 510)						this2 = _this1;
            					}
            					else {
HXLINE( 510)						HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Int8Array",40,53,da,77));
            					}
HXDLIN( 510)					view = this2;
            				}
            				break;
            				case (int)2: {
HXLINE( 510)					HX_VARI_NAME(  ::haxe::io::Bytes,buffer5,"buffer") = this1->buffer;
HXDLIN( 510)					HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this3,"this");
HXDLIN( 510)					Bool _hx_tmp9 = hx::IsNotNull( buffer5 );
HXDLIN( 510)					if (_hx_tmp9) {
HXLINE( 510)						HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this2,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)2);
HXDLIN( 510)						if ((byte_offset < (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						if ((hx::Mod(byte_offset,_this2->bytesPerElement) != (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						HX_VARI_NAME( Int,bufferByteLength1,"bufferByteLength") = buffer5->length;
HXDLIN( 510)						HX_VARI_NAME( Int,newByteLength1,"newByteLength") = bufferByteLength1;
HXDLIN( 510)						Bool _hx_tmp10 = hx::IsNull( len );
HXDLIN( 510)						if (_hx_tmp10) {
HXLINE( 510)							newByteLength1 = (bufferByteLength1 - byte_offset);
HXDLIN( 510)							if ((hx::Mod(bufferByteLength1,_this2->bytesPerElement) != (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
HXDLIN( 510)							if ((newByteLength1 < (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
            						else {
HXLINE( 510)							newByteLength1 = (len * _this2->bytesPerElement);
HXDLIN( 510)							if (((byte_offset + newByteLength1) > bufferByteLength1)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
HXDLIN( 510)						_this2->buffer = buffer5;
HXDLIN( 510)						_this2->byteOffset = byte_offset;
HXDLIN( 510)						_this2->byteLength = newByteLength1;
HXDLIN( 510)						Float _hx_tmp11 = ((Float)newByteLength1 / (Float)_this2->bytesPerElement);
HXDLIN( 510)						_this2->length = ::Std_obj::_hx_int(_hx_tmp11);
HXDLIN( 510)						this3 = _this2;
            					}
            					else {
HXLINE( 510)						HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Int16Array",95,b2,95,a7));
            					}
HXDLIN( 510)					view = this3;
            				}
            				break;
            				case (int)3: {
HXLINE( 510)					HX_VARI_NAME(  ::haxe::io::Bytes,buffer6,"buffer") = this1->buffer;
HXDLIN( 510)					HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this4,"this");
HXDLIN( 510)					Bool _hx_tmp12 = hx::IsNotNull( buffer6 );
HXDLIN( 510)					if (_hx_tmp12) {
HXLINE( 510)						HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this3,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)3);
HXDLIN( 510)						if ((byte_offset < (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						if ((hx::Mod(byte_offset,_this3->bytesPerElement) != (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						HX_VARI_NAME( Int,bufferByteLength2,"bufferByteLength") = buffer6->length;
HXDLIN( 510)						HX_VARI_NAME( Int,newByteLength2,"newByteLength") = bufferByteLength2;
HXDLIN( 510)						Bool _hx_tmp13 = hx::IsNull( len );
HXDLIN( 510)						if (_hx_tmp13) {
HXLINE( 510)							newByteLength2 = (bufferByteLength2 - byte_offset);
HXDLIN( 510)							if ((hx::Mod(bufferByteLength2,_this3->bytesPerElement) != (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
HXDLIN( 510)							if ((newByteLength2 < (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
            						else {
HXLINE( 510)							newByteLength2 = (len * _this3->bytesPerElement);
HXDLIN( 510)							if (((byte_offset + newByteLength2) > bufferByteLength2)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
HXDLIN( 510)						_this3->buffer = buffer6;
HXDLIN( 510)						_this3->byteOffset = byte_offset;
HXDLIN( 510)						_this3->byteLength = newByteLength2;
HXDLIN( 510)						Float _hx_tmp14 = ((Float)newByteLength2 / (Float)_this3->bytesPerElement);
HXDLIN( 510)						_this3->length = ::Std_obj::_hx_int(_hx_tmp14);
HXDLIN( 510)						this4 = _this3;
            					}
            					else {
HXLINE( 510)						HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Int32Array",9b,2e,53,61));
            					}
HXDLIN( 510)					view = this4;
            				}
            				break;
            				case (int)4: {
HXLINE( 510)					HX_VARI_NAME(  ::haxe::io::Bytes,buffer7,"buffer") = this1->buffer;
HXDLIN( 510)					HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this5,"this");
HXDLIN( 510)					Bool _hx_tmp15 = hx::IsNotNull( buffer7 );
HXDLIN( 510)					if (_hx_tmp15) {
HXLINE( 510)						HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this4,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)4);
HXDLIN( 510)						if ((byte_offset < (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						if ((hx::Mod(byte_offset,_this4->bytesPerElement) != (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						HX_VARI_NAME( Int,bufferByteLength3,"bufferByteLength") = buffer7->length;
HXDLIN( 510)						HX_VARI_NAME( Int,newByteLength3,"newByteLength") = bufferByteLength3;
HXDLIN( 510)						Bool _hx_tmp16 = hx::IsNull( len );
HXDLIN( 510)						if (_hx_tmp16) {
HXLINE( 510)							newByteLength3 = (bufferByteLength3 - byte_offset);
HXDLIN( 510)							if ((hx::Mod(bufferByteLength3,_this4->bytesPerElement) != (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
HXDLIN( 510)							if ((newByteLength3 < (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
            						else {
HXLINE( 510)							newByteLength3 = (len * _this4->bytesPerElement);
HXDLIN( 510)							if (((byte_offset + newByteLength3) > bufferByteLength3)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
HXDLIN( 510)						_this4->buffer = buffer7;
HXDLIN( 510)						_this4->byteOffset = byte_offset;
HXDLIN( 510)						_this4->byteLength = newByteLength3;
HXDLIN( 510)						Float _hx_tmp17 = ((Float)newByteLength3 / (Float)_this4->bytesPerElement);
HXDLIN( 510)						_this4->length = ::Std_obj::_hx_int(_hx_tmp17);
HXDLIN( 510)						this5 = _this4;
            					}
            					else {
HXLINE( 510)						HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Uint8Array",8b,64,02,e4));
            					}
HXDLIN( 510)					view = this5;
            				}
            				break;
            				case (int)5: {
HXLINE( 510)					HX_VARI_NAME(  ::haxe::io::Bytes,buffer8,"buffer") = this1->buffer;
HXDLIN( 510)					HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this6,"this");
HXDLIN( 510)					Bool _hx_tmp18 = hx::IsNotNull( buffer8 );
HXDLIN( 510)					if (_hx_tmp18) {
HXLINE( 510)						HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this5,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)5);
HXDLIN( 510)						if ((byte_offset < (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						if ((hx::Mod(byte_offset,_this5->bytesPerElement) != (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						HX_VARI_NAME( Int,bufferByteLength4,"bufferByteLength") = buffer8->length;
HXDLIN( 510)						HX_VARI_NAME( Int,newByteLength4,"newByteLength") = bufferByteLength4;
HXDLIN( 510)						Bool _hx_tmp19 = hx::IsNull( len );
HXDLIN( 510)						if (_hx_tmp19) {
HXLINE( 510)							newByteLength4 = (bufferByteLength4 - byte_offset);
HXDLIN( 510)							if ((hx::Mod(bufferByteLength4,_this5->bytesPerElement) != (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
HXDLIN( 510)							if ((newByteLength4 < (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
            						else {
HXLINE( 510)							newByteLength4 = (len * _this5->bytesPerElement);
HXDLIN( 510)							if (((byte_offset + newByteLength4) > bufferByteLength4)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
HXDLIN( 510)						_this5->buffer = buffer8;
HXDLIN( 510)						_this5->byteOffset = byte_offset;
HXDLIN( 510)						_this5->byteLength = newByteLength4;
HXDLIN( 510)						Float _hx_tmp20 = ((Float)newByteLength4 / (Float)_this5->bytesPerElement);
HXDLIN( 510)						_this5->length = ::Std_obj::_hx_int(_hx_tmp20);
HXDLIN( 510)						this6 = _this5;
            					}
            					else {
HXLINE( 510)						HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Uint8ClampedArray",6d,2a,7c,f9));
            					}
HXDLIN( 510)					view = this6;
            				}
            				break;
            				case (int)6: {
HXLINE( 510)					HX_VARI_NAME(  ::haxe::io::Bytes,buffer9,"buffer") = this1->buffer;
HXDLIN( 510)					HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this7,"this");
HXDLIN( 510)					Bool _hx_tmp21 = hx::IsNotNull( buffer9 );
HXDLIN( 510)					if (_hx_tmp21) {
HXLINE( 510)						HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this6,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)6);
HXDLIN( 510)						if ((byte_offset < (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						if ((hx::Mod(byte_offset,_this6->bytesPerElement) != (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						HX_VARI_NAME( Int,bufferByteLength5,"bufferByteLength") = buffer9->length;
HXDLIN( 510)						HX_VARI_NAME( Int,newByteLength5,"newByteLength") = bufferByteLength5;
HXDLIN( 510)						Bool _hx_tmp22 = hx::IsNull( len );
HXDLIN( 510)						if (_hx_tmp22) {
HXLINE( 510)							newByteLength5 = (bufferByteLength5 - byte_offset);
HXDLIN( 510)							if ((hx::Mod(bufferByteLength5,_this6->bytesPerElement) != (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
HXDLIN( 510)							if ((newByteLength5 < (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
            						else {
HXLINE( 510)							newByteLength5 = (len * _this6->bytesPerElement);
HXDLIN( 510)							if (((byte_offset + newByteLength5) > bufferByteLength5)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
HXDLIN( 510)						_this6->buffer = buffer9;
HXDLIN( 510)						_this6->byteOffset = byte_offset;
HXDLIN( 510)						_this6->byteLength = newByteLength5;
HXDLIN( 510)						Float _hx_tmp23 = ((Float)newByteLength5 / (Float)_this6->bytesPerElement);
HXDLIN( 510)						_this6->length = ::Std_obj::_hx_int(_hx_tmp23);
HXDLIN( 510)						this7 = _this6;
            					}
            					else {
HXLINE( 510)						HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Uint16Array",ea,c2,7c,de));
            					}
HXDLIN( 510)					view = this7;
            				}
            				break;
            				case (int)7: {
HXLINE( 510)					HX_VARI_NAME(  ::haxe::io::Bytes,buffer10,"buffer") = this1->buffer;
HXDLIN( 510)					HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this8,"this");
HXDLIN( 510)					Bool _hx_tmp24 = hx::IsNotNull( buffer10 );
HXDLIN( 510)					if (_hx_tmp24) {
HXLINE( 510)						HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this7,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)7);
HXDLIN( 510)						if ((byte_offset < (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						if ((hx::Mod(byte_offset,_this7->bytesPerElement) != (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						HX_VARI_NAME( Int,bufferByteLength6,"bufferByteLength") = buffer10->length;
HXDLIN( 510)						HX_VARI_NAME( Int,newByteLength6,"newByteLength") = bufferByteLength6;
HXDLIN( 510)						Bool _hx_tmp25 = hx::IsNull( len );
HXDLIN( 510)						if (_hx_tmp25) {
HXLINE( 510)							newByteLength6 = (bufferByteLength6 - byte_offset);
HXDLIN( 510)							if ((hx::Mod(bufferByteLength6,_this7->bytesPerElement) != (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
HXDLIN( 510)							if ((newByteLength6 < (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
            						else {
HXLINE( 510)							newByteLength6 = (len * _this7->bytesPerElement);
HXDLIN( 510)							if (((byte_offset + newByteLength6) > bufferByteLength6)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
HXDLIN( 510)						_this7->buffer = buffer10;
HXDLIN( 510)						_this7->byteOffset = byte_offset;
HXDLIN( 510)						_this7->byteLength = newByteLength6;
HXDLIN( 510)						Float _hx_tmp26 = ((Float)newByteLength6 / (Float)_this7->bytesPerElement);
HXDLIN( 510)						_this7->length = ::Std_obj::_hx_int(_hx_tmp26);
HXDLIN( 510)						this8 = _this7;
            					}
            					else {
HXLINE( 510)						HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Uint32Array",f0,3e,3a,98));
            					}
HXDLIN( 510)					view = this8;
            				}
            				break;
            				case (int)8: {
HXLINE( 510)					HX_VARI_NAME(  ::haxe::io::Bytes,buffer11,"buffer") = this1->buffer;
HXDLIN( 510)					HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this9,"this");
HXDLIN( 510)					Bool _hx_tmp27 = hx::IsNotNull( buffer11 );
HXDLIN( 510)					if (_hx_tmp27) {
HXLINE( 510)						HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this8,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)8);
HXDLIN( 510)						if ((byte_offset < (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						if ((hx::Mod(byte_offset,_this8->bytesPerElement) != (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						HX_VARI_NAME( Int,bufferByteLength7,"bufferByteLength") = buffer11->length;
HXDLIN( 510)						HX_VARI_NAME( Int,newByteLength7,"newByteLength") = bufferByteLength7;
HXDLIN( 510)						Bool _hx_tmp28 = hx::IsNull( len );
HXDLIN( 510)						if (_hx_tmp28) {
HXLINE( 510)							newByteLength7 = (bufferByteLength7 - byte_offset);
HXDLIN( 510)							if ((hx::Mod(bufferByteLength7,_this8->bytesPerElement) != (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
HXDLIN( 510)							if ((newByteLength7 < (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
            						else {
HXLINE( 510)							newByteLength7 = (len * _this8->bytesPerElement);
HXDLIN( 510)							if (((byte_offset + newByteLength7) > bufferByteLength7)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
HXDLIN( 510)						_this8->buffer = buffer11;
HXDLIN( 510)						_this8->byteOffset = byte_offset;
HXDLIN( 510)						_this8->byteLength = newByteLength7;
HXDLIN( 510)						Float _hx_tmp29 = ((Float)newByteLength7 / (Float)_this8->bytesPerElement);
HXDLIN( 510)						_this8->length = ::Std_obj::_hx_int(_hx_tmp29);
HXDLIN( 510)						this9 = _this8;
            					}
            					else {
HXLINE( 510)						HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            					}
HXDLIN( 510)					view = this9;
            				}
            				break;
            				case (int)9: {
HXLINE( 510)					HX_VARI_NAME(  ::haxe::io::Bytes,buffer12,"buffer") = this1->buffer;
HXDLIN( 510)					HX_VAR_NAME(  ::lime::utils::ArrayBufferView,this10,"this");
HXDLIN( 510)					Bool _hx_tmp30 = hx::IsNotNull( buffer12 );
HXDLIN( 510)					if (_hx_tmp30) {
HXLINE( 510)						HX_VARI_NAME(  ::lime::utils::ArrayBufferView,_this9,"_this") =  ::lime::utils::ArrayBufferView_obj::__new((int)0,(int)9);
HXDLIN( 510)						if ((byte_offset < (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						if ((hx::Mod(byte_offset,_this9->bytesPerElement) != (int)0)) {
HXLINE( 510)							HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            						}
HXDLIN( 510)						HX_VARI_NAME( Int,bufferByteLength8,"bufferByteLength") = buffer12->length;
HXDLIN( 510)						HX_VARI_NAME( Int,newByteLength8,"newByteLength") = bufferByteLength8;
HXDLIN( 510)						Bool _hx_tmp31 = hx::IsNull( len );
HXDLIN( 510)						if (_hx_tmp31) {
HXLINE( 510)							newByteLength8 = (bufferByteLength8 - byte_offset);
HXDLIN( 510)							if ((hx::Mod(bufferByteLength8,_this9->bytesPerElement) != (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
HXDLIN( 510)							if ((newByteLength8 < (int)0)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
            						else {
HXLINE( 510)							newByteLength8 = (len * _this9->bytesPerElement);
HXDLIN( 510)							if (((byte_offset + newByteLength8) > bufferByteLength8)) {
HXLINE( 510)								HX_STACK_DO_THROW(::lime::utils::TAError_obj::RangeError_dyn());
            							}
            						}
HXDLIN( 510)						_this9->buffer = buffer12;
HXDLIN( 510)						_this9->byteOffset = byte_offset;
HXDLIN( 510)						_this9->byteLength = newByteLength8;
HXDLIN( 510)						Float _hx_tmp32 = ((Float)newByteLength8 / (Float)_this9->bytesPerElement);
HXDLIN( 510)						_this9->length = ::Std_obj::_hx_int(_hx_tmp32);
HXDLIN( 510)						this10 = _this9;
            					}
            					else {
HXLINE( 510)						HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float64Array",8f,de,6b,1e));
            					}
HXDLIN( 510)					view = this10;
            				}
            				break;
            			}
HXLINE( 511)			this->vertexArray->upload(view);
            		}
HXLINE( 514)		HX_VAR(  ::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State,nextState);
HXLINE( 515)		HX_VARI( Int,batchSize) = (int)0;
HXLINE( 516)		HX_VARI( Int,start) = (int)0;
HXLINE( 518)		this->currentState->shader = null();
HXLINE( 519)		this->currentState->shaderData = null();
HXLINE( 520)		this->currentState->texture = null();
HXLINE( 521)		this->currentState->textureSmooth = false;
HXLINE( 522)		this->currentState->blendMode = this->renderSession->blendModeManager->currentBlendMode;
HXLINE( 523)		this->currentState->colorTransform = null();
HXLINE( 524)		this->currentState->skipColorTransformAlpha = false;
HXLINE( 526)		{
HXLINE( 526)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 526)			HX_VARI_NAME( Int,_g2,"_g") = this->batchedSprites;
HXDLIN( 526)			while((_g1 < _g2)){
HXLINE( 526)				HX_VARI( Int,i) = _g1++;
HXLINE( 528)				nextState = this->states->__get(i).StaticCast<  ::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State >();
HXLINE( 530)				this->currentState->skipColorTransformAlpha = nextState->skipColorTransformAlpha;
HXLINE( 532)				HX_VARI(  ::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State,other) = this->currentState;
HXDLIN( 532)				Bool _hx_tmp33;
HXDLIN( 532)				Bool _hx_tmp34;
HXDLIN( 532)				Bool _hx_tmp35;
HXDLIN( 532)				Bool _hx_tmp36;
HXDLIN( 532)				Bool _hx_tmp37;
HXDLIN( 532)				Bool _hx_tmp38;
HXDLIN( 532)				Bool _hx_tmp39 = hx::IsNull( nextState->shader );
HXDLIN( 532)				if (_hx_tmp39) {
HXLINE( 532)					_hx_tmp38 = hx::IsNull( other->shader );
            				}
            				else {
HXLINE( 532)					_hx_tmp38 = false;
            				}
HXDLIN( 532)				if (!(_hx_tmp38)) {
HXLINE( 532)					Bool _hx_tmp40;
HXDLIN( 532)					Bool _hx_tmp41 = hx::IsNotNull( nextState->shader );
HXDLIN( 532)					if (_hx_tmp41) {
HXLINE( 532)						_hx_tmp40 = hx::IsNotNull( other->shader );
            					}
            					else {
HXLINE( 532)						_hx_tmp40 = false;
            					}
HXDLIN( 532)					if (_hx_tmp40) {
HXLINE( 532)						_hx_tmp37 = (nextState->shader->ID == other->shader->ID);
            					}
            					else {
HXLINE( 532)						_hx_tmp37 = false;
            					}
            				}
            				else {
HXLINE( 532)					_hx_tmp37 = true;
            				}
HXDLIN( 532)				if (_hx_tmp37) {
HXLINE( 532)					_hx_tmp36 = hx::IsEq( nextState->texture,other->texture );
            				}
            				else {
HXLINE( 532)					_hx_tmp36 = false;
            				}
HXDLIN( 532)				if (_hx_tmp36) {
HXLINE( 532)					_hx_tmp35 = (nextState->textureSmooth == other->textureSmooth);
            				}
            				else {
HXLINE( 532)					_hx_tmp35 = false;
            				}
HXDLIN( 532)				if (_hx_tmp35) {
HXLINE( 532)					_hx_tmp34 = hx::IsEq( nextState->blendMode,other->blendMode );
            				}
            				else {
HXLINE( 532)					_hx_tmp34 = false;
            				}
HXDLIN( 532)				if (_hx_tmp34) {
HXLINE( 532)					Bool _hx_tmp42;
HXDLIN( 532)					if (nextState->skipColorTransform) {
HXLINE( 532)						_hx_tmp42 = other->skipColorTransform;
            					}
            					else {
HXLINE( 532)						_hx_tmp42 = false;
            					}
HXDLIN( 532)					if (!(_hx_tmp42)) {
HXLINE( 532)						Bool _hx_tmp43;
HXDLIN( 532)						if (!(nextState->skipColorTransform)) {
HXLINE( 532)							_hx_tmp43 = !(other->skipColorTransform);
            						}
            						else {
HXLINE( 532)							_hx_tmp43 = false;
            						}
HXDLIN( 532)						if (_hx_tmp43) {
HXLINE( 532)							_hx_tmp33 = nextState->colorTransform->_hx___equals(other->colorTransform,nextState->skipColorTransformAlpha);
            						}
            						else {
HXLINE( 532)							_hx_tmp33 = false;
            						}
            					}
            					else {
HXLINE( 532)						_hx_tmp33 = true;
            					}
            				}
            				else {
HXLINE( 532)					_hx_tmp33 = false;
            				}
HXDLIN( 532)				if (!(_hx_tmp33)) {
HXLINE( 534)					this->renderBatch(this->currentState,batchSize,start);
HXLINE( 536)					start = i;
HXLINE( 537)					batchSize = (int)0;
HXLINE( 539)					this->currentState->shader = nextState->shader;
HXLINE( 540)					this->currentState->shaderData = nextState->shaderData;
HXLINE( 541)					this->currentState->texture = nextState->texture;
HXLINE( 542)					this->currentState->textureSmooth = nextState->textureSmooth;
HXLINE( 543)					this->currentState->blendMode = nextState->blendMode;
HXLINE( 544)					this->currentState->skipColorTransform = nextState->skipColorTransform;
HXLINE( 545)					 ::openfl::geom::ColorTransform _hx_tmp44;
HXDLIN( 545)					if (this->currentState->skipColorTransform) {
HXLINE( 545)						_hx_tmp44 = null();
            					}
            					else {
HXLINE( 545)						_hx_tmp44 = nextState->colorTransform;
            					}
HXDLIN( 545)					this->currentState->colorTransform = _hx_tmp44;
            				}
HXLINE( 549)				++batchSize;
            			}
            		}
HXLINE( 552)		this->renderBatch(this->currentState,batchSize,start);
HXLINE( 553)		this->batchedSprites = (int)0;
HXLINE( 554)		this->writtenVertexBytes = (int)0;
HXLINE( 556)		Bool _hx_tmp45 = hx::IsNotNull( this->clipRect );
HXDLIN( 556)		if (_hx_tmp45) {
HXLINE( 557)			Int cap1 = this->gl->SCISSOR_TEST;
HXDLIN( 557)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_disable(cap1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(SpriteBatch_obj,flush,(void))

void SpriteBatch_obj::renderBatch( ::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State state,Int size,Int start){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.SpriteBatch","renderBatch",0x8edfd34a,"openfl._internal.renderer.opengl.utils.SpriteBatch.renderBatch","openfl/_internal/renderer/opengl/utils/SpriteBatch.hx",563,0x8289eb2d)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(state,"state")
            	HX_STACK_ARG(size,"size")
            	HX_STACK_ARG(start,"start")
HXLINE( 564)		Bool _hx_tmp;
HXDLIN( 564)		if ((size != (int)0)) {
HXLINE( 564)			_hx_tmp = hx::IsNull( state->texture );
            		}
            		else {
HXLINE( 564)			_hx_tmp = true;
            		}
HXDLIN( 564)		if (_hx_tmp) {
HXLINE( 564)			return;
            		}
HXLINE( 566)		HX_VAR(  ::openfl::_internal::renderer::opengl::shaders2::Shader,shader);
HXDLIN( 566)		Bool _hx_tmp1 = hx::IsNull( state->shader );
HXDLIN( 566)		if (_hx_tmp1) {
HXLINE( 566)			shader = this->renderSession->shaderManager->defaultShader;
            		}
            		else {
HXLINE( 566)			shader = state->shader;
            		}
HXLINE( 567)		this->renderSession->shaderManager->setShader(shader,null());
HXLINE( 570)		shader->bindVertexArray(this->vertexArray);
HXLINE( 572)		 ::Dynamic _hx_tmp2;
HXDLIN( 572)		Bool _hx_tmp3 = hx::IsNotNull( shader->blendMode );
HXDLIN( 572)		if (_hx_tmp3) {
HXLINE( 572)			_hx_tmp2 = shader->blendMode;
            		}
            		else {
HXLINE( 572)			_hx_tmp2 = state->blendMode;
            		}
HXDLIN( 572)		this->renderSession->blendModeManager->setBlendMode(_hx_tmp2,null());
HXLINE( 574)		{
HXLINE( 574)			Int location = shader->getUniformLocation(HX_("openfl_uProjectionMatrix",16,8b,ff,93));
HXDLIN( 574)			 ::lime::utils::ArrayBufferView v = this->renderSession->projectionMatrix->toArray(true);
HXDLIN( 574)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_uniform_matrix(location,false,hx::DynamicPtr(v->buffer),(int)3);
            		}
HXLINE( 576)		Bool _hx_tmp4 = hx::IsNotNull( state->colorTransform );
HXDLIN( 576)		if (_hx_tmp4) {
HXLINE( 577)			{
HXLINE( 577)				Int location1 = shader->getUniformLocation(HX_("openfl_uUseColorTransform",8a,6c,2b,8b));
HXDLIN( 577)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_uniform1i(location1,(int)1);
            			}
HXLINE( 578)			HX_VARI(  ::openfl::geom::ColorTransform,ct) = state->colorTransform;
HXLINE( 579)			{
HXLINE( 579)				Int location2 = shader->getUniformLocation(HX_("openfl_uColorMultiplier",9e,72,0d,28));
HXDLIN( 579)				Float x = ct->redMultiplier;
HXDLIN( 579)				Float y = ct->greenMultiplier;
HXDLIN( 579)				Float z = ct->blueMultiplier;
HXDLIN( 579)				Float w;
HXLINE( 580)				if (state->skipColorTransformAlpha) {
HXLINE( 579)					w = (int)1;
            				}
            				else {
HXLINE( 579)					w = ct->alphaMultiplier;
            				}
HXDLIN( 579)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_uniform4f(location2,x,y,z,w);
            			}
HXLINE( 581)			{
HXLINE( 581)				Int location3 = shader->getUniformLocation(HX_("openfl_uColorOffset",30,10,2f,e8));
HXDLIN( 581)				Float x1 = ((Float)ct->redOffset / (Float)((Float)255.));
HXDLIN( 581)				Float y1 = ((Float)ct->greenOffset / (Float)((Float)255.));
HXDLIN( 581)				Float z1 = ((Float)ct->blueOffset / (Float)((Float)255.));
HXDLIN( 581)				Float w1 = ((Float)ct->alphaOffset / (Float)((Float)255.));
HXDLIN( 581)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_uniform4f(location3,x1,y1,z1,w1);
            			}
            		}
            		else {
HXLINE( 584)			{
HXLINE( 584)				Int location4 = shader->getUniformLocation(HX_("openfl_uUseColorTransform",8a,6c,2b,8b));
HXDLIN( 584)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_uniform1i(location4,(int)0);
            			}
HXLINE( 585)			{
HXLINE( 585)				Int location5 = shader->getUniformLocation(HX_("openfl_uColorMultiplier",9e,72,0d,28));
HXDLIN( 585)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_uniform4f(location5,(int)1,(int)1,(int)1,(int)1);
            			}
HXLINE( 586)			{
HXLINE( 586)				Int location6 = shader->getUniformLocation(HX_("openfl_uColorOffset",30,10,2f,e8));
HXDLIN( 586)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_uniform4f(location6,(int)0,(int)0,(int)0,(int)0);
            			}
            		}
HXLINE( 589)		{
HXLINE( 589)			Int texture = this->gl->TEXTURE0;
HXDLIN( 589)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_active_texture(texture);
            		}
HXLINE( 590)		{
HXLINE( 590)			Int target = this->gl->TEXTURE_2D;
HXDLIN( 590)			HX_VARI_NAME(  ::lime::graphics::opengl::GLTexture,texture1,"texture") = state->texture;
HXDLIN( 590)			{
HXLINE( 590)				Int texture2;
HXDLIN( 590)				Bool _hx_tmp5 = hx::IsNull( texture1 );
HXDLIN( 590)				if (_hx_tmp5) {
HXLINE( 590)					texture2 = (int)0;
            				}
            				else {
HXLINE( 590)					texture2 = texture1->id;
            				}
HXDLIN( 590)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_bind_texture(target,texture2);
            			}
            		}
HXLINE( 591)		{
HXLINE( 591)			Int location7 = shader->getUniformLocation(HX_("openfl_uSampler0",0e,4f,96,4d));
HXDLIN( 591)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_uniform1i(location7,(int)0);
            		}
HXLINE( 593)		Bool _hx_tmp6;
HXDLIN( 593)		Bool _hx_tmp7;
HXDLIN( 593)		Bool _hx_tmp8 = hx::IsNotNull( shader->smooth );
HXDLIN( 593)		if (_hx_tmp8) {
HXLINE( 593)			_hx_tmp7 = shader->smooth;
            		}
            		else {
HXLINE( 593)			_hx_tmp7 = false;
            		}
HXDLIN( 593)		if (!(_hx_tmp7)) {
HXLINE( 593)			_hx_tmp6 = state->textureSmooth;
            		}
            		else {
HXLINE( 593)			_hx_tmp6 = true;
            		}
HXDLIN( 593)		if (_hx_tmp6) {
HXLINE( 594)			{
HXLINE( 594)				Int target1 = this->gl->TEXTURE_2D;
HXDLIN( 594)				Int pname = this->gl->TEXTURE_MAG_FILTER;
HXDLIN( 594)				Int param = this->gl->LINEAR;
HXDLIN( 594)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_tex_parameteri(target1,pname,param);
            			}
HXLINE( 595)			{
HXLINE( 595)				Int target2 = this->gl->TEXTURE_2D;
HXDLIN( 595)				Int pname1 = this->gl->TEXTURE_MIN_FILTER;
HXDLIN( 595)				Int param1 = this->gl->LINEAR;
HXDLIN( 595)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_tex_parameteri(target2,pname1,param1);
            			}
            		}
            		else {
HXLINE( 597)			{
HXLINE( 597)				Int target3 = this->gl->TEXTURE_2D;
HXDLIN( 597)				Int pname2 = this->gl->TEXTURE_MAG_FILTER;
HXDLIN( 597)				Int param2 = this->gl->NEAREST;
HXDLIN( 597)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_tex_parameteri(target3,pname2,param2);
            			}
HXLINE( 598)			{
HXLINE( 598)				Int target4 = this->gl->TEXTURE_2D;
HXDLIN( 598)				Int pname3 = this->gl->TEXTURE_MIN_FILTER;
HXDLIN( 598)				Int param3 = this->gl->NEAREST;
HXDLIN( 598)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_tex_parameteri(target4,pname3,param3);
            			}
            		}
HXLINE( 601)		{
HXLINE( 601)			Int target5 = this->gl->TEXTURE_2D;
HXDLIN( 601)			Int pname4 = this->gl->TEXTURE_WRAP_S;
HXDLIN( 601)			Int param4 = shader->wrapS;
HXDLIN( 601)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_tex_parameteri(target5,pname4,param4);
            		}
HXLINE( 602)		{
HXLINE( 602)			Int target6 = this->gl->TEXTURE_2D;
HXDLIN( 602)			Int pname5 = this->gl->TEXTURE_WRAP_T;
HXDLIN( 602)			Int param5 = shader->wrapT;
HXDLIN( 602)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_tex_parameteri(target6,pname5,param5);
            		}
HXLINE( 604)		shader->applyData(state->shaderData,this->renderSession);
HXLINE( 606)		{
HXLINE( 606)			Int mode = this->gl->TRIANGLES;
HXDLIN( 606)			Int type = this->gl->UNSIGNED_SHORT;
HXDLIN( 606)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_draw_elements(mode,(size * (int)6),type,((start * (int)6) * (int)2));
            		}
HXLINE( 608)		this->renderSession->drawCount++;
            	}


HX_DEFINE_DYNAMIC_FUNC3(SpriteBatch_obj,renderBatch,(void))

void SpriteBatch_obj::setState(Int index, ::lime::graphics::opengl::GLTexture texture, ::Dynamic __o_smooth, ::Dynamic blendMode, ::openfl::geom::ColorTransform colorTransform, ::openfl::display::Shader shader, ::Dynamic __o_skipAlpha){
 ::Dynamic smooth = __o_smooth.Default(false);
 ::Dynamic skipAlpha = __o_skipAlpha.Default(false);
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.SpriteBatch","setState",0x7687c889,"openfl._internal.renderer.opengl.utils.SpriteBatch.setState","openfl/_internal/renderer/opengl/utils/SpriteBatch.hx",612,0x8289eb2d)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(index,"index")
            	HX_STACK_ARG(texture,"texture")
            	HX_STACK_ARG(smooth,"smooth")
            	HX_STACK_ARG(blendMode,"blendMode")
            	HX_STACK_ARG(colorTransform,"colorTransform")
            	HX_STACK_ARG(shader,"shader")
            	HX_STACK_ARG(skipAlpha,"skipAlpha")
HXLINE( 614)		HX_VARI(  ::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State,state) = this->states->__get(index).StaticCast<  ::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State >();
HXLINE( 615)		Bool _hx_tmp = hx::IsNull( state );
HXDLIN( 615)		if (_hx_tmp) {
HXLINE( 616)			state = (this->states[index] =  ::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State_obj::__new());
            		}
HXLINE( 618)		state->texture = texture;
HXLINE( 619)		state->textureSmooth = smooth;
HXLINE( 620)		state->blendMode = blendMode;
HXLINE( 623)		Bool _hx_tmp1;
HXDLIN( 623)		Bool _hx_tmp2 = hx::IsNotNull( colorTransform );
HXDLIN( 623)		if (_hx_tmp2) {
HXLINE( 623)			_hx_tmp1 = colorTransform->_hx___isDefault();
            		}
            		else {
HXLINE( 623)			_hx_tmp1 = false;
            		}
HXDLIN( 623)		state->skipColorTransform = _hx_tmp1;
HXLINE( 625)		Bool _hx_tmp3 = !(state->skipColorTransform);
HXDLIN( 625)		if (_hx_tmp3) {
HXLINE( 626)			state->colorTransform->redMultiplier = colorTransform->redMultiplier;
HXLINE( 627)			state->colorTransform->greenMultiplier = colorTransform->greenMultiplier;
HXLINE( 628)			state->colorTransform->blueMultiplier = colorTransform->blueMultiplier;
HXLINE( 629)			state->colorTransform->alphaMultiplier = colorTransform->alphaMultiplier;
HXLINE( 630)			state->colorTransform->redOffset = colorTransform->redOffset;
HXLINE( 631)			state->colorTransform->greenOffset = colorTransform->greenOffset;
HXLINE( 632)			state->colorTransform->blueOffset = colorTransform->blueOffset;
HXLINE( 633)			state->colorTransform->alphaOffset = colorTransform->alphaOffset;
            		}
HXLINE( 636)		state->skipColorTransformAlpha = skipAlpha;
HXLINE( 637)		Bool _hx_tmp4 = hx::IsNull( shader );
HXDLIN( 637)		if (_hx_tmp4) {
HXLINE( 638)			state->shader = null();
HXLINE( 639)			state->shaderData = null();
            		}
            		else {
HXLINE( 641)			state->shader = shader->_hx___shader;
HXLINE( 642)			state->shaderData = shader->data;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC7(SpriteBatch_obj,setState,(void))

void SpriteBatch_obj::setContext( ::lime::graphics::GLRenderContext gl){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.SpriteBatch","setContext",0xe1877667,"openfl._internal.renderer.opengl.utils.SpriteBatch.setContext","openfl/_internal/renderer/opengl/utils/SpriteBatch.hx",646,0x8289eb2d)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(gl,"gl")
HXLINE( 647)		this->gl = gl;
HXLINE( 649)		this->vertexArray->setContext(gl,this->positions);
HXLINE( 651)		Int _hx_tmp = ::lime::graphics::opengl::GL_obj::get_version();
HXDLIN( 651)		Int _hx_tmp1 = ( (Int)(::lime::graphics::opengl::GL_obj::cffi_lime_gl_create_buffer()) );
HXDLIN( 651)		this->indexBuffer =  ::lime::graphics::opengl::GLBuffer_obj::__new(_hx_tmp,_hx_tmp1);
HXLINE( 652)		{
HXLINE( 652)			Int target = gl->ELEMENT_ARRAY_BUFFER;
HXDLIN( 652)			HX_VARI(  ::lime::graphics::opengl::GLBuffer,buffer) = this->indexBuffer;
HXDLIN( 652)			{
HXLINE( 652)				Int buffer1;
HXDLIN( 652)				Bool _hx_tmp2 = hx::IsNull( buffer );
HXDLIN( 652)				if (_hx_tmp2) {
HXLINE( 652)					buffer1 = (int)0;
            				}
            				else {
HXLINE( 652)					buffer1 = buffer->id;
            				}
HXDLIN( 652)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_bind_buffer(target,buffer1);
            			}
            		}
HXLINE( 653)		{
HXLINE( 653)			Int target1 = gl->ELEMENT_ARRAY_BUFFER;
HXDLIN( 653)			HX_VARI(  ::lime::utils::ArrayBufferView,data) = this->indices;
HXDLIN( 653)			Int usage = gl->STATIC_DRAW;
HXDLIN( 653)			{
HXLINE( 653)				Int byteOffset = data->byteOffset;
HXDLIN( 653)				Int size = data->byteLength;
HXDLIN( 653)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_buffer_data(target1,hx::DynamicPtr(data->buffer),byteOffset,size,usage);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(SpriteBatch_obj,setContext,(void))

void SpriteBatch_obj::prepareShader( ::openfl::display::Shader flashShader, ::openfl::display::BitmapData bd){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.SpriteBatch","prepareShader",0x0c5ca052,"openfl._internal.renderer.opengl.utils.SpriteBatch.prepareShader","openfl/_internal/renderer/opengl/utils/SpriteBatch.hx",658,0x8289eb2d)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(flashShader,"flashShader")
            	HX_STACK_ARG(bd,"bd")
HXLINE( 658)		Bool _hx_tmp = hx::IsNotNull( flashShader );
HXDLIN( 658)		if (_hx_tmp) {
HXLINE( 659)			flashShader->_hx___init(this->gl);
HXLINE( 660)			flashShader->_hx___shader->wrapS = flashShader->repeatX;
HXLINE( 661)			flashShader->_hx___shader->wrapT = flashShader->repeatY;
HXLINE( 662)			flashShader->_hx___shader->smooth = flashShader->smooth;
HXLINE( 663)			flashShader->_hx___shader->blendMode = flashShader->blendMode;
HXLINE( 665)			HX_VARI(  ::openfl::display::GLShaderParameter,objSize) = flashShader->data->get(::openfl::display::Shader_obj::uObjectSize).StaticCast<  ::openfl::display::GLShaderParameter >();
HXLINE( 666)			HX_VARI(  ::openfl::display::GLShaderParameter,texSize) = flashShader->data->get(::openfl::display::Shader_obj::uTextureSize).StaticCast<  ::openfl::display::GLShaderParameter >();
HXLINE( 667)			Bool _hx_tmp1 = hx::IsNotNull( bd );
HXDLIN( 667)			if (_hx_tmp1) {
HXLINE( 668)				objSize->value[(int)0] = bd->width;
HXLINE( 669)				objSize->value[(int)1] = bd->height;
HXLINE( 670)				Bool _hx_tmp2 = hx::IsNotNull( bd->_hx___pingPongTexture );
HXDLIN( 670)				if (_hx_tmp2) {
HXLINE( 671)					HX_VARI(  ::openfl::_internal::renderer::opengl::utils::PingPongTexture,_this) = bd->_hx___pingPongTexture;
HXDLIN( 671)					 ::openfl::_internal::renderer::opengl::utils::RenderTexture _hx_tmp3;
HXDLIN( 671)					if (_this->_hx___swapped) {
HXLINE( 671)						_hx_tmp3 = _this->_hx___texture1;
            					}
            					else {
HXLINE( 671)						_hx_tmp3 = _this->_hx___texture0;
            					}
HXDLIN( 671)					texSize->value[(int)0] = _hx_tmp3->_hx___width;
HXLINE( 672)					HX_VARI_NAME(  ::openfl::_internal::renderer::opengl::utils::PingPongTexture,_this1,"_this") = bd->_hx___pingPongTexture;
HXDLIN( 672)					 ::openfl::_internal::renderer::opengl::utils::RenderTexture _hx_tmp4;
HXDLIN( 672)					if (_this1->_hx___swapped) {
HXLINE( 672)						_hx_tmp4 = _this1->_hx___texture1;
            					}
            					else {
HXLINE( 672)						_hx_tmp4 = _this1->_hx___texture0;
            					}
HXDLIN( 672)					texSize->value[(int)1] = _hx_tmp4->_hx___height;
            				}
            				else {
HXLINE( 674)					texSize->value[(int)0] = bd->width;
HXLINE( 675)					texSize->value[(int)1] = bd->height;
            				}
            			}
            			else {
HXLINE( 678)				objSize->value[(int)0] = (int)0;
HXLINE( 679)				objSize->value[(int)1] = (int)0;
HXLINE( 680)				texSize->value[(int)0] = (int)0;
HXLINE( 681)				texSize->value[(int)1] = (int)0;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(SpriteBatch_obj,prepareShader,(void))

Int SpriteBatch_obj::getElementsPerVertex(){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.SpriteBatch","getElementsPerVertex",0x09fa41ee,"openfl._internal.renderer.opengl.utils.SpriteBatch.getElementsPerVertex","openfl/_internal/renderer/opengl/utils/SpriteBatch.hx",686,0x8289eb2d)
            	HX_STACK_THIS(this)
HXLINE( 687)		HX_VARI( Int,r) = (int)0;
HXLINE( 689)		{
HXLINE( 689)			HX_VARI( Int,_g) = (int)0;
HXDLIN( 689)			HX_VARI( ::Array< ::Dynamic>,_g1) = this->attributes;
HXDLIN( 689)			while((_g < _g1->length)){
HXLINE( 689)				HX_VARI(  ::openfl::_internal::renderer::opengl::utils::VertexAttribute,a) = _g1->__get(_g).StaticCast<  ::openfl::_internal::renderer::opengl::utils::VertexAttribute >();
HXDLIN( 689)				++_g;
HXLINE( 690)				Bool _hx_tmp = a->enabled;
HXDLIN( 690)				if (_hx_tmp) {
HXLINE( 690)					HX_VARI_NAME( Int,_g2,"_g") = a->type;
HXDLIN( 690)					Int _hx_tmp1;
HXDLIN( 690)					switch((int)(_g2)){
            						case (int)5120: case (int)5121: {
HXLINE( 690)							_hx_tmp1 = (int)1;
            						}
            						break;
            						case (int)5122: case (int)5123: {
HXLINE( 690)							_hx_tmp1 = (int)2;
            						}
            						break;
            						default:{
HXLINE( 690)							_hx_tmp1 = (int)4;
            						}
            					}
HXDLIN( 690)					Float _hx_tmp2 = ((Float)(a->components * _hx_tmp1) / (Float)(int)4);
HXDLIN( 690)					Int _hx_tmp3 = ::Math_obj::floor(_hx_tmp2);
HXDLIN( 690)					hx::AddEq(r,_hx_tmp3);
            				}
            			}
            		}
HXLINE( 693)		return r;
            	}


HX_DEFINE_DYNAMIC_FUNC0(SpriteBatch_obj,getElementsPerVertex,return )

Int SpriteBatch_obj::VERTS_PER_SPRITE;


SpriteBatch_obj::SpriteBatch_obj()
{
}

void SpriteBatch_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(SpriteBatch);
	HX_MARK_MEMBER_NAME(gl,"gl");
	HX_MARK_MEMBER_NAME(renderSession,"renderSession");
	HX_MARK_MEMBER_NAME(states,"states");
	HX_MARK_MEMBER_NAME(currentState,"currentState");
	HX_MARK_MEMBER_NAME(vertexArray,"vertexArray");
	HX_MARK_MEMBER_NAME(positions,"positions");
	HX_MARK_MEMBER_NAME(colors,"colors");
	HX_MARK_MEMBER_NAME(indexBuffer,"indexBuffer");
	HX_MARK_MEMBER_NAME(indices,"indices");
	HX_MARK_MEMBER_NAME(dirty,"dirty");
	HX_MARK_MEMBER_NAME(drawing,"drawing");
	HX_MARK_MEMBER_NAME(clipRect,"clipRect");
	HX_MARK_MEMBER_NAME(maxSprites,"maxSprites");
	HX_MARK_MEMBER_NAME(batchedSprites,"batchedSprites");
	HX_MARK_MEMBER_NAME(vertexArraySize,"vertexArraySize");
	HX_MARK_MEMBER_NAME(indexArraySize,"indexArraySize");
	HX_MARK_MEMBER_NAME(maxElementsPerVertex,"maxElementsPerVertex");
	HX_MARK_MEMBER_NAME(elementsPerVertex,"elementsPerVertex");
	HX_MARK_MEMBER_NAME(writtenVertexBytes,"writtenVertexBytes");
	HX_MARK_MEMBER_NAME(shader,"shader");
	HX_MARK_MEMBER_NAME(attributes,"attributes");
	HX_MARK_MEMBER_NAME(enableColor,"enableColor");
	HX_MARK_MEMBER_NAME(lastEnableColor,"lastEnableColor");
	HX_MARK_MEMBER_NAME(matrix,"matrix");
	HX_MARK_MEMBER_NAME(uvs,"uvs");
	HX_MARK_MEMBER_NAME(colorTransform,"colorTransform");
	HX_MARK_END_CLASS();
}

void SpriteBatch_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(gl,"gl");
	HX_VISIT_MEMBER_NAME(renderSession,"renderSession");
	HX_VISIT_MEMBER_NAME(states,"states");
	HX_VISIT_MEMBER_NAME(currentState,"currentState");
	HX_VISIT_MEMBER_NAME(vertexArray,"vertexArray");
	HX_VISIT_MEMBER_NAME(positions,"positions");
	HX_VISIT_MEMBER_NAME(colors,"colors");
	HX_VISIT_MEMBER_NAME(indexBuffer,"indexBuffer");
	HX_VISIT_MEMBER_NAME(indices,"indices");
	HX_VISIT_MEMBER_NAME(dirty,"dirty");
	HX_VISIT_MEMBER_NAME(drawing,"drawing");
	HX_VISIT_MEMBER_NAME(clipRect,"clipRect");
	HX_VISIT_MEMBER_NAME(maxSprites,"maxSprites");
	HX_VISIT_MEMBER_NAME(batchedSprites,"batchedSprites");
	HX_VISIT_MEMBER_NAME(vertexArraySize,"vertexArraySize");
	HX_VISIT_MEMBER_NAME(indexArraySize,"indexArraySize");
	HX_VISIT_MEMBER_NAME(maxElementsPerVertex,"maxElementsPerVertex");
	HX_VISIT_MEMBER_NAME(elementsPerVertex,"elementsPerVertex");
	HX_VISIT_MEMBER_NAME(writtenVertexBytes,"writtenVertexBytes");
	HX_VISIT_MEMBER_NAME(shader,"shader");
	HX_VISIT_MEMBER_NAME(attributes,"attributes");
	HX_VISIT_MEMBER_NAME(enableColor,"enableColor");
	HX_VISIT_MEMBER_NAME(lastEnableColor,"lastEnableColor");
	HX_VISIT_MEMBER_NAME(matrix,"matrix");
	HX_VISIT_MEMBER_NAME(uvs,"uvs");
	HX_VISIT_MEMBER_NAME(colorTransform,"colorTransform");
}

hx::Val SpriteBatch_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { return hx::Val( gl); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"uvs") ) { return hx::Val( uvs); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"stop") ) { return hx::Val( stop_dyn()); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"dirty") ) { return hx::Val( dirty); }
		if (HX_FIELD_EQ(inName,"begin") ) { return hx::Val( begin_dyn()); }
		if (HX_FIELD_EQ(inName,"start") ) { return hx::Val( start_dyn()); }
		if (HX_FIELD_EQ(inName,"flush") ) { return hx::Val( flush_dyn()); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"states") ) { return hx::Val( states); }
		if (HX_FIELD_EQ(inName,"colors") ) { return hx::Val( colors); }
		if (HX_FIELD_EQ(inName,"shader") ) { return hx::Val( shader); }
		if (HX_FIELD_EQ(inName,"matrix") ) { return hx::Val( matrix); }
		if (HX_FIELD_EQ(inName,"finish") ) { return hx::Val( finish_dyn()); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"indices") ) { return hx::Val( indices); }
		if (HX_FIELD_EQ(inName,"drawing") ) { return hx::Val( drawing); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return hx::Val( destroy_dyn()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"clipRect") ) { return hx::Val( clipRect); }
		if (HX_FIELD_EQ(inName,"setState") ) { return hx::Val( setState_dyn()); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"positions") ) { return hx::Val( positions); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"maxSprites") ) { return hx::Val( maxSprites); }
		if (HX_FIELD_EQ(inName,"attributes") ) { return hx::Val( attributes); }
		if (HX_FIELD_EQ(inName,"setContext") ) { return hx::Val( setContext_dyn()); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"vertexArray") ) { return hx::Val( vertexArray); }
		if (HX_FIELD_EQ(inName,"indexBuffer") ) { return hx::Val( indexBuffer); }
		if (HX_FIELD_EQ(inName,"enableColor") ) { return hx::Val( enableColor); }
		if (HX_FIELD_EQ(inName,"renderTiles") ) { return hx::Val( renderTiles_dyn()); }
		if (HX_FIELD_EQ(inName,"renderBatch") ) { return hx::Val( renderBatch_dyn()); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"currentState") ) { return hx::Val( currentState); }
		if (HX_FIELD_EQ(inName,"fillVertices") ) { return hx::Val( fillVertices_dyn()); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"renderSession") ) { return hx::Val( renderSession); }
		if (HX_FIELD_EQ(inName,"prepareShader") ) { return hx::Val( prepareShader_dyn()); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"batchedSprites") ) { return hx::Val( batchedSprites); }
		if (HX_FIELD_EQ(inName,"indexArraySize") ) { return hx::Val( indexArraySize); }
		if (HX_FIELD_EQ(inName,"colorTransform") ) { return hx::Val( colorTransform); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"vertexArraySize") ) { return hx::Val( vertexArraySize); }
		if (HX_FIELD_EQ(inName,"lastEnableColor") ) { return hx::Val( lastEnableColor); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"renderBitmapData") ) { return hx::Val( renderBitmapData_dyn()); }
		if (HX_FIELD_EQ(inName,"enableAttributes") ) { return hx::Val( enableAttributes_dyn()); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"elementsPerVertex") ) { return hx::Val( elementsPerVertex); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"writtenVertexBytes") ) { return hx::Val( writtenVertexBytes); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"maxElementsPerVertex") ) { return hx::Val( maxElementsPerVertex); }
		if (HX_FIELD_EQ(inName,"getElementsPerVertex") ) { return hx::Val( getElementsPerVertex_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val SpriteBatch_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { gl=inValue.Cast<  ::lime::graphics::GLRenderContext >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"uvs") ) { uvs=inValue.Cast<  ::openfl::display::TextureUvs >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"dirty") ) { dirty=inValue.Cast< Bool >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"states") ) { states=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"colors") ) { colors=inValue.Cast<  ::lime::utils::ArrayBufferView >(); return inValue; }
		if (HX_FIELD_EQ(inName,"shader") ) { shader=inValue.Cast<  ::openfl::_internal::renderer::opengl::shaders2::Shader >(); return inValue; }
		if (HX_FIELD_EQ(inName,"matrix") ) { matrix=inValue.Cast<  ::openfl::geom::Matrix >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"indices") ) { indices=inValue.Cast<  ::lime::utils::ArrayBufferView >(); return inValue; }
		if (HX_FIELD_EQ(inName,"drawing") ) { drawing=inValue.Cast< Bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"clipRect") ) { clipRect=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"positions") ) { positions=inValue.Cast<  ::lime::utils::ArrayBufferView >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"maxSprites") ) { maxSprites=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"attributes") ) { attributes=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"vertexArray") ) { vertexArray=inValue.Cast<  ::openfl::_internal::renderer::opengl::utils::VertexArray >(); return inValue; }
		if (HX_FIELD_EQ(inName,"indexBuffer") ) { indexBuffer=inValue.Cast<  ::lime::graphics::opengl::GLBuffer >(); return inValue; }
		if (HX_FIELD_EQ(inName,"enableColor") ) { enableColor=inValue.Cast< Bool >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"currentState") ) { currentState=inValue.Cast<  ::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"renderSession") ) { renderSession=inValue.Cast<  ::openfl::_internal::renderer::RenderSession >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"batchedSprites") ) { batchedSprites=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"indexArraySize") ) { indexArraySize=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"colorTransform") ) { colorTransform=inValue.Cast<  ::openfl::geom::ColorTransform >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"vertexArraySize") ) { vertexArraySize=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastEnableColor") ) { lastEnableColor=inValue.Cast< Bool >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"elementsPerVertex") ) { elementsPerVertex=inValue.Cast< Int >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"writtenVertexBytes") ) { writtenVertexBytes=inValue.Cast< Int >(); return inValue; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"maxElementsPerVertex") ) { maxElementsPerVertex=inValue.Cast< Int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void SpriteBatch_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("gl","\x25","\x5a","\x00","\x00"));
	outFields->push(HX_HCSTRING("renderSession","\xa0","\x8a","\x85","\x8f"));
	outFields->push(HX_HCSTRING("states","\x42","\xd9","\xfb","\x05"));
	outFields->push(HX_HCSTRING("currentState","\x18","\x5b","\x17","\xcb"));
	outFields->push(HX_HCSTRING("vertexArray","\x95","\x37","\xcb","\x39"));
	outFields->push(HX_HCSTRING("positions","\xaa","\xf3","\x51","\xd0"));
	outFields->push(HX_HCSTRING("colors","\xb0","\xc5","\x86","\xc6"));
	outFields->push(HX_HCSTRING("indexBuffer","\xb2","\x65","\xa6","\xf5"));
	outFields->push(HX_HCSTRING("indices","\x27","\x47","\x54","\xe3"));
	outFields->push(HX_HCSTRING("dirty","\x12","\x50","\xd0","\xd9"));
	outFields->push(HX_HCSTRING("drawing","\x5e","\x3b","\xe8","\xfb"));
	outFields->push(HX_HCSTRING("clipRect","\x14","\x90","\x6a","\x58"));
	outFields->push(HX_HCSTRING("maxSprites","\x8a","\x22","\xaf","\xc9"));
	outFields->push(HX_HCSTRING("batchedSprites","\x35","\x23","\x1a","\x71"));
	outFields->push(HX_HCSTRING("vertexArraySize","\xf6","\xf2","\x13","\x87"));
	outFields->push(HX_HCSTRING("indexArraySize","\x88","\xcd","\xd4","\xb2"));
	outFields->push(HX_HCSTRING("maxElementsPerVertex","\xa6","\x4f","\xf4","\x82"));
	outFields->push(HX_HCSTRING("elementsPerVertex","\xea","\xd2","\xc7","\xbf"));
	outFields->push(HX_HCSTRING("writtenVertexBytes","\xd0","\x9e","\x8f","\xc3"));
	outFields->push(HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d"));
	outFields->push(HX_HCSTRING("attributes","\xd7","\xa8","\x71","\x97"));
	outFields->push(HX_HCSTRING("enableColor","\xe0","\xb7","\x2b","\x15"));
	outFields->push(HX_HCSTRING("lastEnableColor","\x2a","\x59","\x68","\xb7"));
	outFields->push(HX_HCSTRING("matrix","\x41","\x36","\xc8","\xbb"));
	outFields->push(HX_HCSTRING("uvs","\xf2","\x2e","\x59","\x00"));
	outFields->push(HX_HCSTRING("colorTransform","\x89","\xd7","\x3f","\xad"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo SpriteBatch_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::lime::graphics::GLRenderContext*/ ,(int)offsetof(SpriteBatch_obj,gl),HX_HCSTRING("gl","\x25","\x5a","\x00","\x00")},
	{hx::fsObject /*::openfl::_internal::renderer::RenderSession*/ ,(int)offsetof(SpriteBatch_obj,renderSession),HX_HCSTRING("renderSession","\xa0","\x8a","\x85","\x8f")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(SpriteBatch_obj,states),HX_HCSTRING("states","\x42","\xd9","\xfb","\x05")},
	{hx::fsObject /*::openfl::_internal::renderer::opengl::utils::_SpriteBatch::State*/ ,(int)offsetof(SpriteBatch_obj,currentState),HX_HCSTRING("currentState","\x18","\x5b","\x17","\xcb")},
	{hx::fsObject /*::openfl::_internal::renderer::opengl::utils::VertexArray*/ ,(int)offsetof(SpriteBatch_obj,vertexArray),HX_HCSTRING("vertexArray","\x95","\x37","\xcb","\x39")},
	{hx::fsObject /*::lime::utils::ArrayBufferView*/ ,(int)offsetof(SpriteBatch_obj,positions),HX_HCSTRING("positions","\xaa","\xf3","\x51","\xd0")},
	{hx::fsObject /*::lime::utils::ArrayBufferView*/ ,(int)offsetof(SpriteBatch_obj,colors),HX_HCSTRING("colors","\xb0","\xc5","\x86","\xc6")},
	{hx::fsObject /*::lime::graphics::opengl::GLBuffer*/ ,(int)offsetof(SpriteBatch_obj,indexBuffer),HX_HCSTRING("indexBuffer","\xb2","\x65","\xa6","\xf5")},
	{hx::fsObject /*::lime::utils::ArrayBufferView*/ ,(int)offsetof(SpriteBatch_obj,indices),HX_HCSTRING("indices","\x27","\x47","\x54","\xe3")},
	{hx::fsBool,(int)offsetof(SpriteBatch_obj,dirty),HX_HCSTRING("dirty","\x12","\x50","\xd0","\xd9")},
	{hx::fsBool,(int)offsetof(SpriteBatch_obj,drawing),HX_HCSTRING("drawing","\x5e","\x3b","\xe8","\xfb")},
	{hx::fsObject /*::openfl::geom::Rectangle*/ ,(int)offsetof(SpriteBatch_obj,clipRect),HX_HCSTRING("clipRect","\x14","\x90","\x6a","\x58")},
	{hx::fsInt,(int)offsetof(SpriteBatch_obj,maxSprites),HX_HCSTRING("maxSprites","\x8a","\x22","\xaf","\xc9")},
	{hx::fsInt,(int)offsetof(SpriteBatch_obj,batchedSprites),HX_HCSTRING("batchedSprites","\x35","\x23","\x1a","\x71")},
	{hx::fsInt,(int)offsetof(SpriteBatch_obj,vertexArraySize),HX_HCSTRING("vertexArraySize","\xf6","\xf2","\x13","\x87")},
	{hx::fsInt,(int)offsetof(SpriteBatch_obj,indexArraySize),HX_HCSTRING("indexArraySize","\x88","\xcd","\xd4","\xb2")},
	{hx::fsInt,(int)offsetof(SpriteBatch_obj,maxElementsPerVertex),HX_HCSTRING("maxElementsPerVertex","\xa6","\x4f","\xf4","\x82")},
	{hx::fsInt,(int)offsetof(SpriteBatch_obj,elementsPerVertex),HX_HCSTRING("elementsPerVertex","\xea","\xd2","\xc7","\xbf")},
	{hx::fsInt,(int)offsetof(SpriteBatch_obj,writtenVertexBytes),HX_HCSTRING("writtenVertexBytes","\xd0","\x9e","\x8f","\xc3")},
	{hx::fsObject /*::openfl::_internal::renderer::opengl::shaders2::Shader*/ ,(int)offsetof(SpriteBatch_obj,shader),HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(SpriteBatch_obj,attributes),HX_HCSTRING("attributes","\xd7","\xa8","\x71","\x97")},
	{hx::fsBool,(int)offsetof(SpriteBatch_obj,enableColor),HX_HCSTRING("enableColor","\xe0","\xb7","\x2b","\x15")},
	{hx::fsBool,(int)offsetof(SpriteBatch_obj,lastEnableColor),HX_HCSTRING("lastEnableColor","\x2a","\x59","\x68","\xb7")},
	{hx::fsObject /*::openfl::geom::Matrix*/ ,(int)offsetof(SpriteBatch_obj,matrix),HX_HCSTRING("matrix","\x41","\x36","\xc8","\xbb")},
	{hx::fsObject /*::openfl::display::TextureUvs*/ ,(int)offsetof(SpriteBatch_obj,uvs),HX_HCSTRING("uvs","\xf2","\x2e","\x59","\x00")},
	{hx::fsObject /*::openfl::geom::ColorTransform*/ ,(int)offsetof(SpriteBatch_obj,colorTransform),HX_HCSTRING("colorTransform","\x89","\xd7","\x3f","\xad")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo SpriteBatch_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &SpriteBatch_obj::VERTS_PER_SPRITE,HX_HCSTRING("VERTS_PER_SPRITE","\x64","\x04","\x57","\x9d")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String SpriteBatch_obj_sMemberFields[] = {
	HX_HCSTRING("gl","\x25","\x5a","\x00","\x00"),
	HX_HCSTRING("renderSession","\xa0","\x8a","\x85","\x8f"),
	HX_HCSTRING("states","\x42","\xd9","\xfb","\x05"),
	HX_HCSTRING("currentState","\x18","\x5b","\x17","\xcb"),
	HX_HCSTRING("vertexArray","\x95","\x37","\xcb","\x39"),
	HX_HCSTRING("positions","\xaa","\xf3","\x51","\xd0"),
	HX_HCSTRING("colors","\xb0","\xc5","\x86","\xc6"),
	HX_HCSTRING("indexBuffer","\xb2","\x65","\xa6","\xf5"),
	HX_HCSTRING("indices","\x27","\x47","\x54","\xe3"),
	HX_HCSTRING("dirty","\x12","\x50","\xd0","\xd9"),
	HX_HCSTRING("drawing","\x5e","\x3b","\xe8","\xfb"),
	HX_HCSTRING("clipRect","\x14","\x90","\x6a","\x58"),
	HX_HCSTRING("maxSprites","\x8a","\x22","\xaf","\xc9"),
	HX_HCSTRING("batchedSprites","\x35","\x23","\x1a","\x71"),
	HX_HCSTRING("vertexArraySize","\xf6","\xf2","\x13","\x87"),
	HX_HCSTRING("indexArraySize","\x88","\xcd","\xd4","\xb2"),
	HX_HCSTRING("maxElementsPerVertex","\xa6","\x4f","\xf4","\x82"),
	HX_HCSTRING("elementsPerVertex","\xea","\xd2","\xc7","\xbf"),
	HX_HCSTRING("writtenVertexBytes","\xd0","\x9e","\x8f","\xc3"),
	HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d"),
	HX_HCSTRING("attributes","\xd7","\xa8","\x71","\x97"),
	HX_HCSTRING("enableColor","\xe0","\xb7","\x2b","\x15"),
	HX_HCSTRING("lastEnableColor","\x2a","\x59","\x68","\xb7"),
	HX_HCSTRING("matrix","\x41","\x36","\xc8","\xbb"),
	HX_HCSTRING("uvs","\xf2","\x2e","\x59","\x00"),
	HX_HCSTRING("colorTransform","\x89","\xd7","\x3f","\xad"),
	HX_HCSTRING("destroy","\xfa","\x2c","\x86","\x24"),
	HX_HCSTRING("begin","\x29","\xea","\x55","\xb0"),
	HX_HCSTRING("finish","\x53","\x40","\x7f","\x86"),
	HX_HCSTRING("start","\x62","\x74","\x0b","\x84"),
	HX_HCSTRING("stop","\x02","\xf0","\x5b","\x4c"),
	HX_HCSTRING("renderBitmapData","\xaf","\xec","\x66","\xde"),
	HX_HCSTRING("renderTiles","\x4f","\x2a","\xe6","\xdb"),
	HX_HCSTRING("fillVertices","\x9c","\x05","\x8a","\x6e"),
	HX_HCSTRING("enableAttributes","\x3a","\xbd","\x20","\x34"),
	HX_HCSTRING("flush","\xc4","\x62","\x9b","\x02"),
	HX_HCSTRING("renderBatch","\x84","\x14","\x6c","\x79"),
	HX_HCSTRING("setState","\x0f","\xdf","\x3f","\x92"),
	HX_HCSTRING("setContext","\x6d","\xba","\x56","\x6c"),
	HX_HCSTRING("prepareShader","\x0c","\x24","\x67","\xe3"),
	HX_HCSTRING("getElementsPerVertex","\x74","\x09","\x3d","\xe7"),
	::String(null()) };

static void SpriteBatch_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(SpriteBatch_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(SpriteBatch_obj::VERTS_PER_SPRITE,"VERTS_PER_SPRITE");
};

#ifdef HXCPP_VISIT_ALLOCS
static void SpriteBatch_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(SpriteBatch_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(SpriteBatch_obj::VERTS_PER_SPRITE,"VERTS_PER_SPRITE");
};

#endif

hx::Class SpriteBatch_obj::__mClass;

static ::String SpriteBatch_obj_sStaticFields[] = {
	HX_HCSTRING("VERTS_PER_SPRITE","\x64","\x04","\x57","\x9d"),
	::String(null())
};

void SpriteBatch_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl._internal.renderer.opengl.utils.SpriteBatch","\x34","\x8e","\xd7","\x6d");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = SpriteBatch_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(SpriteBatch_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(SpriteBatch_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< SpriteBatch_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = SpriteBatch_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = SpriteBatch_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = SpriteBatch_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void SpriteBatch_obj::__boot()
{
{
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.SpriteBatch","boot",0x3c1ea8ac,"openfl._internal.renderer.opengl.utils.SpriteBatch.boot","openfl/_internal/renderer/opengl/utils/SpriteBatch.hx",33,0x8289eb2d)
HXLINE(  33)		VERTS_PER_SPRITE = (int)4;
            	}
}

} // end namespace openfl
} // end namespace _internal
} // end namespace renderer
} // end namespace opengl
} // end namespace utils
