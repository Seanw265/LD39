// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime_graphics_GLRenderContext
#include <lime/graphics/GLRenderContext.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GL
#include <lime/graphics/opengl/GL.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLBuffer
#include <lime/graphics/opengl/GLBuffer.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLObject
#include <lime/graphics/opengl/GLObject.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_AbstractRenderer
#include <openfl/_internal/renderer/AbstractRenderer.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_DrawCommandBuffer
#include <openfl/_internal/renderer/DrawCommandBuffer.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_RenderSession
#include <openfl/_internal/renderer/RenderSession.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_GLRenderer
#include <openfl/_internal/renderer/opengl/GLRenderer.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_shaders2_FillShader
#include <openfl/_internal/renderer/opengl/shaders2/FillShader.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_shaders2_Shader
#include <openfl/_internal/renderer/opengl/shaders2/Shader.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_BucketMode
#include <openfl/_internal/renderer/opengl/utils/BucketMode.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_GLBucket
#include <openfl/_internal/renderer/opengl/utils/GLBucket.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_GLBucketData
#include <openfl/_internal/renderer/opengl/utils/GLBucketData.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_GLGraphicsData
#include <openfl/_internal/renderer/opengl/utils/GLGraphicsData.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_GLStack
#include <openfl/_internal/renderer/opengl/utils/GLStack.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_GraphicsRenderer
#include <openfl/_internal/renderer/opengl/utils/GraphicsRenderer.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_ShaderManager
#include <openfl/_internal/renderer/opengl/utils/ShaderManager.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_StencilManager
#include <openfl/_internal/renderer/opengl/utils/StencilManager.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_VertexArray
#include <openfl/_internal/renderer/opengl/utils/VertexArray.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif

namespace openfl{
namespace _internal{
namespace renderer{
namespace opengl{
namespace utils{

void StencilManager_obj::__construct( ::lime::graphics::GLRenderContext gl){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.StencilManager","new",0x77733264,"openfl._internal.renderer.opengl.utils.StencilManager.new","openfl/_internal/renderer/opengl/utils/StencilManager.hx",22,0xffb0ff49)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(gl,"gl")
HXLINE(  29)		this->stencilMask = (int)0;
HXLINE(  34)		this->stencilStack = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  35)		this->setContext(gl);
HXLINE(  36)		this->reverse = true;
HXLINE(  37)		this->count = (int)0;
            	}

Dynamic StencilManager_obj::__CreateEmpty() { return new StencilManager_obj; }

hx::ObjectPtr< StencilManager_obj > StencilManager_obj::__new( ::lime::graphics::GLRenderContext gl)
{
	hx::ObjectPtr< StencilManager_obj > _hx_result = new StencilManager_obj();
	_hx_result->__construct(gl);
	return _hx_result;
}

Dynamic StencilManager_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< StencilManager_obj > _hx_result = new StencilManager_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

void StencilManager_obj::prepareGraphics( ::openfl::_internal::renderer::opengl::utils::GLBucketData fill, ::openfl::_internal::renderer::RenderSession renderSession, ::lime::utils::ArrayBufferView translationMatrix){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.StencilManager","prepareGraphics",0xb36afd76,"openfl._internal.renderer.opengl.utils.StencilManager.prepareGraphics","openfl/_internal/renderer/opengl/utils/StencilManager.hx",41,0xffb0ff49)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(fill,"fill")
            	HX_STACK_ARG(renderSession,"renderSession")
            	HX_STACK_ARG(translationMatrix,"translationMatrix")
HXLINE(  42)		HX_VARI(  ::openfl::_internal::renderer::opengl::shaders2::FillShader,shader) = renderSession->shaderManager->fillShader;
HXLINE(  44)		renderSession->shaderManager->setShader(shader,null());
HXLINE(  45)		{
HXLINE(  45)			Int location = shader->getUniformLocation(HX_("openfl_uTranslationMatrix",6c,2c,b6,64));
HXDLIN(  45)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_uniform_matrix(location,false,hx::DynamicPtr(translationMatrix->buffer),(int)3);
            		}
HXLINE(  46)		{
HXLINE(  46)			Int location1 = shader->getUniformLocation(HX_("openfl_uProjectionMatrix",16,8b,ff,93));
HXDLIN(  46)			 ::lime::utils::ArrayBufferView v = renderSession->projectionMatrix->toArray(true);
HXDLIN(  46)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_uniform_matrix(location1,false,hx::DynamicPtr(v->buffer),(int)3);
            		}
HXLINE(  48)		{
HXLINE(  48)			HX_VARI(  ::openfl::_internal::renderer::opengl::utils::VertexArray,_this) = fill->vertexArray;
HXDLIN(  48)			{
HXLINE(  48)				Int target = _this->gl->ARRAY_BUFFER;
HXDLIN(  48)				HX_VARI(  ::lime::graphics::opengl::GLBuffer,buffer) = _this->glBuffer;
HXDLIN(  48)				{
HXLINE(  48)					Int buffer1;
HXDLIN(  48)					Bool _hx_tmp = hx::IsNull( buffer );
HXDLIN(  48)					if (_hx_tmp) {
HXLINE(  48)						buffer1 = (int)0;
            					}
            					else {
HXLINE(  48)						buffer1 = buffer->id;
            					}
HXDLIN(  48)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_bind_buffer(target,buffer1);
            				}
            			}
            		}
HXLINE(  49)		shader->bindVertexArray(fill->vertexArray);
HXLINE(  50)		{
HXLINE(  50)			Int target1 = this->gl->ELEMENT_ARRAY_BUFFER;
HXDLIN(  50)			HX_VARI_NAME(  ::lime::graphics::opengl::GLBuffer,buffer2,"buffer") = fill->indexBuffer;
HXDLIN(  50)			{
HXLINE(  50)				Int buffer3;
HXDLIN(  50)				Bool _hx_tmp1 = hx::IsNull( buffer2 );
HXDLIN(  50)				if (_hx_tmp1) {
HXLINE(  50)					buffer3 = (int)0;
            				}
            				else {
HXLINE(  50)					buffer3 = buffer2->id;
            				}
HXDLIN(  50)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_bind_buffer(target1,buffer3);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(StencilManager_obj,prepareGraphics,(void))

void StencilManager_obj::pushBucket( ::openfl::_internal::renderer::opengl::utils::GLBucket bucket, ::openfl::_internal::renderer::RenderSession renderSession, ::lime::utils::ArrayBufferView translationMatrix, ::Dynamic __o_isMask){
 ::Dynamic isMask = __o_isMask.Default(false);
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.StencilManager","pushBucket",0x91b6f060,"openfl._internal.renderer.opengl.utils.StencilManager.pushBucket","openfl/_internal/renderer/opengl/utils/StencilManager.hx",53,0xffb0ff49)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(bucket,"bucket")
            	HX_STACK_ARG(renderSession,"renderSession")
            	HX_STACK_ARG(translationMatrix,"translationMatrix")
            	HX_STACK_ARG(isMask,"isMask")
HXLINE(  55)		if (!(isMask)) {
HXLINE(  56)			{
HXLINE(  56)				Int cap = this->gl->STENCIL_TEST;
HXDLIN(  56)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_enable(cap);
            			}
HXLINE(  57)			{
HXLINE(  57)				Int mask = this->gl->STENCIL_BUFFER_BIT;
HXDLIN(  57)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_clear(mask);
            			}
HXLINE(  58)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_mask((int)255);
HXLINE(  60)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_color_mask(false,false,false,false);
HXLINE(  61)			{
HXLINE(  61)				Int func = this->gl->NEVER;
HXDLIN(  61)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func,(int)1,(int)255);
            			}
HXLINE(  62)			{
HXLINE(  62)				Int fail = this->gl->INVERT;
HXDLIN(  62)				Int zfail = this->gl->KEEP;
HXDLIN(  62)				Int zpass = this->gl->KEEP;
HXDLIN(  62)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_op(fail,zfail,zpass);
            			}
HXLINE(  64)			{
HXLINE(  64)				Int mask1 = this->gl->STENCIL_BUFFER_BIT;
HXDLIN(  64)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_clear(mask1);
            			}
            		}
HXLINE(  67)		{
HXLINE(  67)			HX_VARI( Int,_g) = (int)0;
HXDLIN(  67)			HX_VARI( ::Array< ::Dynamic>,_g1) = bucket->fills;
HXDLIN(  67)			while((_g < _g1->length)){
HXLINE(  67)				HX_VARI(  ::openfl::_internal::renderer::opengl::utils::GLBucketData,fill) = _g1->__get(_g).StaticCast<  ::openfl::_internal::renderer::opengl::utils::GLBucketData >();
HXDLIN(  67)				++_g;
HXLINE(  68)				if (fill->available) {
HXLINE(  68)					continue;
            				}
HXLINE(  69)				{
HXLINE(  69)					HX_VARI(  ::openfl::_internal::renderer::opengl::shaders2::FillShader,shader) = renderSession->shaderManager->fillShader;
HXDLIN(  69)					renderSession->shaderManager->setShader(shader,null());
HXDLIN(  69)					{
HXLINE(  69)						Int location = shader->getUniformLocation(HX_("openfl_uTranslationMatrix",6c,2c,b6,64));
HXDLIN(  69)						::lime::graphics::opengl::GL_obj::cffi_lime_gl_uniform_matrix(location,false,hx::DynamicPtr(translationMatrix->buffer),(int)3);
            					}
HXDLIN(  69)					{
HXLINE(  69)						Int location1 = shader->getUniformLocation(HX_("openfl_uProjectionMatrix",16,8b,ff,93));
HXDLIN(  69)						 ::lime::utils::ArrayBufferView v = renderSession->projectionMatrix->toArray(true);
HXDLIN(  69)						::lime::graphics::opengl::GL_obj::cffi_lime_gl_uniform_matrix(location1,false,hx::DynamicPtr(v->buffer),(int)3);
            					}
HXDLIN(  69)					{
HXLINE(  69)						HX_VARI(  ::openfl::_internal::renderer::opengl::utils::VertexArray,_this) = fill->vertexArray;
HXDLIN(  69)						{
HXLINE(  69)							Int target = _this->gl->ARRAY_BUFFER;
HXDLIN(  69)							HX_VARI(  ::lime::graphics::opengl::GLBuffer,buffer) = _this->glBuffer;
HXDLIN(  69)							{
HXLINE(  69)								Int buffer1;
HXDLIN(  69)								Bool _hx_tmp = hx::IsNull( buffer );
HXDLIN(  69)								if (_hx_tmp) {
HXLINE(  69)									buffer1 = (int)0;
            								}
            								else {
HXLINE(  69)									buffer1 = buffer->id;
            								}
HXDLIN(  69)								::lime::graphics::opengl::GL_obj::cffi_lime_gl_bind_buffer(target,buffer1);
            							}
            						}
            					}
HXDLIN(  69)					shader->bindVertexArray(fill->vertexArray);
HXDLIN(  69)					{
HXLINE(  69)						Int target1 = this->gl->ELEMENT_ARRAY_BUFFER;
HXDLIN(  69)						HX_VARI_NAME(  ::lime::graphics::opengl::GLBuffer,buffer2,"buffer") = fill->indexBuffer;
HXDLIN(  69)						{
HXLINE(  69)							Int buffer3;
HXDLIN(  69)							Bool _hx_tmp1 = hx::IsNull( buffer2 );
HXDLIN(  69)							if (_hx_tmp1) {
HXLINE(  69)								buffer3 = (int)0;
            							}
            							else {
HXLINE(  69)								buffer3 = buffer2->id;
            							}
HXDLIN(  69)							::lime::graphics::opengl::GL_obj::cffi_lime_gl_bind_buffer(target1,buffer3);
            						}
            					}
            				}
HXLINE(  70)				{
HXLINE(  70)					Int mode = fill->drawMode;
HXDLIN(  70)					Int count = fill->glIndices->length;
HXDLIN(  70)					Int type = this->gl->UNSIGNED_SHORT;
HXDLIN(  70)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_draw_elements(mode,count,type,(int)0);
            				}
            			}
            		}
HXLINE(  74)		if (!(isMask)) {
HXLINE(  75)			{
HXLINE(  75)				Bool alpha = renderSession->renderer->transparent;
HXDLIN(  75)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_color_mask(true,true,true,alpha);
            			}
HXLINE(  76)			{
HXLINE(  76)				Int fail1 = this->gl->KEEP;
HXDLIN(  76)				Int zfail1 = this->gl->KEEP;
HXDLIN(  76)				Int zpass1 = this->gl->KEEP;
HXDLIN(  76)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_op(fail1,zfail1,zpass1);
            			}
HXLINE(  77)			{
HXLINE(  77)				Int func1 = this->gl->EQUAL;
HXDLIN(  77)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func1,(int)255,(int)255);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(StencilManager_obj,pushBucket,(void))

void StencilManager_obj::popBucket( ::openfl::display::DisplayObject object, ::openfl::_internal::renderer::opengl::utils::GLBucket bucket, ::openfl::_internal::renderer::RenderSession renderSession){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.StencilManager","popBucket",0x413d75df,"openfl._internal.renderer.opengl.utils.StencilManager.popBucket","openfl/_internal/renderer/opengl/utils/StencilManager.hx",82,0xffb0ff49)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(object,"object")
            	HX_STACK_ARG(bucket,"bucket")
            	HX_STACK_ARG(renderSession,"renderSession")
HXLINE(  82)		Int cap = this->gl->STENCIL_TEST;
HXDLIN(  82)		::lime::graphics::opengl::GL_obj::cffi_lime_gl_disable(cap);
            	}


HX_DEFINE_DYNAMIC_FUNC3(StencilManager_obj,popBucket,(void))

void StencilManager_obj::pushMask( ::openfl::display::DisplayObject object, ::openfl::_internal::renderer::RenderSession renderSession){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.StencilManager","pushMask",0x02924362,"openfl._internal.renderer.opengl.utils.StencilManager.pushMask","openfl/_internal/renderer/opengl/utils/StencilManager.hx",85,0xffb0ff49)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(object,"object")
            	HX_STACK_ARG(renderSession,"renderSession")
HXLINE(  87)		HX_VARI(  ::openfl::display::Graphics,maskGraphics) = object->_hx___maskGraphics;
HXLINE(  88)		Bool _hx_tmp;
HXDLIN(  88)		Bool _hx_tmp1 = hx::IsNotNull( maskGraphics );
HXDLIN(  88)		if (_hx_tmp1) {
HXLINE(  88)			Int _hx_tmp2 = maskGraphics->_hx___commands->get_length();
HXDLIN(  88)			_hx_tmp = (_hx_tmp2 <= (int)0);
            		}
            		else {
HXLINE(  88)			_hx_tmp = true;
            		}
HXDLIN(  88)		if (_hx_tmp) {
HXLINE(  89)			return;
            		}
HXLINE(  92)		Bool _hx_tmp3 = (this->stencilMask == (int)0);
HXDLIN(  92)		if (_hx_tmp3) {
HXLINE(  93)			{
HXLINE(  93)				Int cap = this->gl->STENCIL_TEST;
HXDLIN(  93)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_enable(cap);
            			}
HXLINE(  94)			{
HXLINE(  94)				Int mask = this->gl->STENCIL_BUFFER_BIT;
HXDLIN(  94)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_clear(mask);
            			}
            		}
HXLINE(  97)		this->stencilMask++;
HXLINE(  99)		Bool _hx_tmp4 = maskGraphics->_hx___dirty;
HXDLIN(  99)		if (_hx_tmp4) {
HXLINE( 100)			::openfl::_internal::renderer::opengl::utils::GraphicsRenderer_obj::updateGraphics(object,maskGraphics,renderSession->gl,null());
            		}
HXLINE( 103)		HX_VAR( Int,func);
HXDLIN( 103)		if ((this->stencilMask == (int)1)) {
HXLINE( 103)			func = this->gl->NEVER;
            		}
            		else {
HXLINE( 103)			func = this->gl->EQUAL;
            		}
HXLINE( 104)		HX_VARI( Int,ref) = this->stencilMask;
HXLINE( 105)		HX_VARI_NAME( Int,mask1,"mask") = ((int)255 - this->stencilMask);
HXLINE( 107)		::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_mask((int)255);
HXLINE( 108)		::lime::graphics::opengl::GL_obj::cffi_lime_gl_color_mask(false,false,false,false);
HXLINE( 109)		::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func,ref,mask1);
HXLINE( 110)		{
HXLINE( 110)			Int fail = this->gl->REPLACE;
HXDLIN( 110)			Int zfail = this->gl->KEEP;
HXDLIN( 110)			Int zpass = this->gl->KEEP;
HXDLIN( 110)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_op(fail,zfail,zpass);
            		}
HXLINE( 113)		HX_VARI(  ::openfl::_internal::renderer::opengl::utils::GLStack,glStack) = maskGraphics->_hx___glStack->__get(::openfl::_internal::renderer::opengl::GLRenderer_obj::glContextId).StaticCast<  ::openfl::_internal::renderer::opengl::utils::GLStack >();
HXLINE( 114)		HX_VAR(  ::openfl::_internal::renderer::opengl::utils::GLBucket,bucket);
HXLINE( 115)		HX_VARI(  ::openfl::geom::Matrix,translationMatrix) = object->_hx___worldTransform;
HXLINE( 116)		{
HXLINE( 116)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 116)			HX_VARI( Int,_g) = glStack->buckets->length;
HXDLIN( 116)			while((_g1 < _g)){
HXLINE( 116)				HX_VARI( Int,i) = _g1++;
HXLINE( 117)				bucket = glStack->buckets->__get(i).StaticCast<  ::openfl::_internal::renderer::opengl::utils::GLBucket >();
HXLINE( 119)				Bool _hx_tmp5 = hx::IsNotNull( bucket->overrideMatrix );
HXDLIN( 119)				if (_hx_tmp5) {
HXLINE( 120)					translationMatrix = bucket->overrideMatrix;
            				}
            				else {
HXLINE( 122)					translationMatrix = object->_hx___worldTransform;
            				}
HXLINE( 125)				{
HXLINE( 125)					Int _hx_tmp6 = ( ( ::hx::EnumBase)(bucket->mode) )->_hx_getIndex();
HXDLIN( 125)					switch((int)(_hx_tmp6)){
            						case (int)1: case (int)2: {
HXLINE( 127)							 ::lime::utils::ArrayBufferView _hx_tmp7 = translationMatrix->toArray(true);
HXDLIN( 127)							this->pushBucket(bucket,renderSession,_hx_tmp7,true);
            						}
            						break;
            						default:{
            						}
            					}
            				}
            			}
            		}
HXLINE( 133)		{
HXLINE( 133)			Bool alpha = renderSession->renderer->transparent;
HXDLIN( 133)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_color_mask(true,true,true,alpha);
            		}
HXLINE( 134)		{
HXLINE( 134)			Int fail1 = this->gl->KEEP;
HXDLIN( 134)			Int zfail1 = this->gl->KEEP;
HXDLIN( 134)			Int zpass1 = this->gl->KEEP;
HXDLIN( 134)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_op(fail1,zfail1,zpass1);
            		}
HXLINE( 135)		{
HXLINE( 135)			Int func1 = this->gl->EQUAL;
HXDLIN( 135)			Int ref1 = this->stencilMask;
HXDLIN( 135)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func1,ref1,(int)255);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(StencilManager_obj,pushMask,(void))

void StencilManager_obj::popMask( ::openfl::display::DisplayObject object, ::openfl::_internal::renderer::RenderSession renderSession){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.StencilManager","popMask",0xc8241b21,"openfl._internal.renderer.opengl.utils.StencilManager.popMask","openfl/_internal/renderer/opengl/utils/StencilManager.hx",138,0xffb0ff49)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(object,"object")
            	HX_STACK_ARG(renderSession,"renderSession")
HXLINE( 145)		this->stencilMask--;
HXLINE( 147)		Bool _hx_tmp = (this->stencilMask <= (int)0);
HXDLIN( 147)		if (_hx_tmp) {
HXLINE( 148)			{
HXLINE( 148)				Int cap = this->gl->STENCIL_TEST;
HXDLIN( 148)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_disable(cap);
            			}
HXLINE( 149)			this->stencilMask = (int)0;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(StencilManager_obj,popMask,(void))

void StencilManager_obj::bindGraphics( ::openfl::display::DisplayObject object, ::openfl::_internal::renderer::opengl::utils::GLGraphicsData glData, ::openfl::_internal::renderer::RenderSession renderSession){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.StencilManager","bindGraphics",0xa8f66d24,"openfl._internal.renderer.opengl.utils.StencilManager.bindGraphics","openfl/_internal/renderer/opengl/utils/StencilManager.hx",153,0xffb0ff49)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(object,"object")
            	HX_STACK_ARG(glData,"glData")
            	HX_STACK_ARG(renderSession,"renderSession")
            	}


HX_DEFINE_DYNAMIC_FUNC3(StencilManager_obj,bindGraphics,(void))

void StencilManager_obj::destroy(){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.StencilManager","destroy",0xa998e0fe,"openfl._internal.renderer.opengl.utils.StencilManager.destroy","openfl/_internal/renderer/opengl/utils/StencilManager.hx",209,0xffb0ff49)
            	HX_STACK_THIS(this)
HXLINE( 211)		this->stencilStack = null();
HXLINE( 212)		this->gl = null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(StencilManager_obj,destroy,(void))

void StencilManager_obj::popStencil( ::openfl::display::DisplayObject object, ::openfl::_internal::renderer::opengl::utils::GLGraphicsData glData, ::openfl::_internal::renderer::RenderSession renderSession){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.StencilManager","popStencil",0x59e272e7,"openfl._internal.renderer.opengl.utils.StencilManager.popStencil","openfl/_internal/renderer/opengl/utils/StencilManager.hx",217,0xffb0ff49)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(object,"object")
            	HX_STACK_ARG(glData,"glData")
            	HX_STACK_ARG(renderSession,"renderSession")
HXLINE( 219)		this->stencilStack->pop().StaticCast<  ::openfl::_internal::renderer::opengl::utils::GLGraphicsData >();
HXLINE( 221)		this->count--;
HXLINE( 223)		Bool _hx_tmp = (this->stencilStack->length == (int)0);
HXDLIN( 223)		if (_hx_tmp) {
HXLINE( 225)			Int cap = this->gl->STENCIL_TEST;
HXDLIN( 225)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_disable(cap);
            		}
            		else {
HXLINE( 229)			HX_VARI( Int,level) = this->count;
HXLINE( 230)			this->bindGraphics(object,glData,renderSession);
HXLINE( 232)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_color_mask(false,false,false,false);
HXLINE( 234)			Bool _hx_tmp1 = (glData->mode == (int)1);
HXDLIN( 234)			if (_hx_tmp1) {
HXLINE( 236)				this->reverse = !(this->reverse);
HXLINE( 238)				Bool _hx_tmp2 = this->reverse;
HXDLIN( 238)				if (_hx_tmp2) {
HXLINE( 240)					{
HXLINE( 240)						Int func = this->gl->EQUAL;
HXDLIN( 240)						::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func,((int)255 - (level + (int)1)),(int)255);
            					}
HXLINE( 241)					{
HXLINE( 241)						Int fail = this->gl->KEEP;
HXDLIN( 241)						Int zfail = this->gl->KEEP;
HXDLIN( 241)						Int zpass = this->gl->INCR;
HXDLIN( 241)						::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_op(fail,zfail,zpass);
            					}
            				}
            				else {
HXLINE( 245)					{
HXLINE( 245)						Int func1 = this->gl->EQUAL;
HXDLIN( 245)						::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func1,(level + (int)1),(int)255);
            					}
HXLINE( 246)					{
HXLINE( 246)						Int fail1 = this->gl->KEEP;
HXDLIN( 246)						Int zfail1 = this->gl->KEEP;
HXDLIN( 246)						Int zpass1 = this->gl->DECR;
HXDLIN( 246)						::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_op(fail1,zfail1,zpass1);
            					}
            				}
HXLINE( 250)				{
HXLINE( 250)					Int mode = this->gl->TRIANGLE_FAN;
HXDLIN( 250)					Int type = this->gl->UNSIGNED_SHORT;
HXDLIN( 250)					Int offset = ((glData->indices->length - (int)4) * (int)2);
HXDLIN( 250)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_draw_elements(mode,(int)4,type,offset);
            				}
HXLINE( 252)				{
HXLINE( 252)					Int func2 = this->gl->ALWAYS;
HXDLIN( 252)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func2,(int)0,(int)255);
            				}
HXLINE( 253)				{
HXLINE( 253)					Int fail2 = this->gl->KEEP;
HXDLIN( 253)					Int zfail2 = this->gl->KEEP;
HXDLIN( 253)					Int zpass2 = this->gl->INVERT;
HXDLIN( 253)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_op(fail2,zfail2,zpass2);
            				}
HXLINE( 255)				{
HXLINE( 255)					Int mode1 = this->gl->TRIANGLE_FAN;
HXDLIN( 255)					Int count = (glData->indices->length - (int)4);
HXDLIN( 255)					Int type1 = this->gl->UNSIGNED_SHORT;
HXDLIN( 255)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_draw_elements(mode1,count,type1,(int)0);
            				}
HXLINE( 257)				Bool _hx_tmp3 = !(this->reverse);
HXDLIN( 257)				if (_hx_tmp3) {
HXLINE( 259)					Int func3 = this->gl->EQUAL;
HXDLIN( 259)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func3,((int)255 - level),(int)255);
            				}
            				else {
HXLINE( 263)					Int func4 = this->gl->EQUAL;
HXDLIN( 263)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func4,level,(int)255);
            				}
            			}
            			else {
HXLINE( 269)				Bool _hx_tmp4 = !(this->reverse);
HXDLIN( 269)				if (_hx_tmp4) {
HXLINE( 271)					{
HXLINE( 271)						Int func5 = this->gl->EQUAL;
HXDLIN( 271)						::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func5,((int)255 - (level + (int)1)),(int)255);
            					}
HXLINE( 272)					{
HXLINE( 272)						Int fail3 = this->gl->KEEP;
HXDLIN( 272)						Int zfail3 = this->gl->KEEP;
HXDLIN( 272)						Int zpass3 = this->gl->INCR;
HXDLIN( 272)						::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_op(fail3,zfail3,zpass3);
            					}
            				}
            				else {
HXLINE( 276)					{
HXLINE( 276)						Int func6 = this->gl->EQUAL;
HXDLIN( 276)						::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func6,(level + (int)1),(int)255);
            					}
HXLINE( 277)					{
HXLINE( 277)						Int fail4 = this->gl->KEEP;
HXDLIN( 277)						Int zfail4 = this->gl->KEEP;
HXDLIN( 277)						Int zpass4 = this->gl->DECR;
HXDLIN( 277)						::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_op(fail4,zfail4,zpass4);
            					}
            				}
HXLINE( 281)				{
HXLINE( 281)					Int mode2 = this->gl->TRIANGLE_STRIP;
HXDLIN( 281)					Int count1 = glData->indices->length;
HXDLIN( 281)					Int type2 = this->gl->UNSIGNED_SHORT;
HXDLIN( 281)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_draw_elements(mode2,count1,type2,(int)0);
            				}
HXLINE( 283)				Bool _hx_tmp5 = !(this->reverse);
HXDLIN( 283)				if (_hx_tmp5) {
HXLINE( 285)					Int func7 = this->gl->EQUAL;
HXDLIN( 285)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func7,((int)255 - level),(int)255);
            				}
            				else {
HXLINE( 289)					Int func8 = this->gl->EQUAL;
HXDLIN( 289)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func8,level,(int)255);
            				}
            			}
HXLINE( 295)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_color_mask(true,true,true,true);
HXLINE( 296)			{
HXLINE( 296)				Int fail5 = this->gl->KEEP;
HXDLIN( 296)				Int zfail5 = this->gl->KEEP;
HXDLIN( 296)				Int zpass5 = this->gl->KEEP;
HXDLIN( 296)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_op(fail5,zfail5,zpass5);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(StencilManager_obj,popStencil,(void))

void StencilManager_obj::pushStencil( ::openfl::display::DisplayObject object, ::openfl::_internal::renderer::opengl::utils::GLGraphicsData glData, ::openfl::_internal::renderer::RenderSession renderSession){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.StencilManager","pushStencil",0x73b42946,"openfl._internal.renderer.opengl.utils.StencilManager.pushStencil","openfl/_internal/renderer/opengl/utils/StencilManager.hx",303,0xffb0ff49)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(object,"object")
            	HX_STACK_ARG(glData,"glData")
            	HX_STACK_ARG(renderSession,"renderSession")
HXLINE( 305)		this->bindGraphics(object,glData,renderSession);
HXLINE( 307)		Bool _hx_tmp = (this->stencilStack->length == (int)0);
HXDLIN( 307)		if (_hx_tmp) {
HXLINE( 309)			{
HXLINE( 309)				Int cap = this->gl->STENCIL_TEST;
HXDLIN( 309)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_enable(cap);
            			}
HXLINE( 310)			{
HXLINE( 310)				Int mask = this->gl->STENCIL_BUFFER_BIT;
HXDLIN( 310)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_clear(mask);
            			}
HXLINE( 311)			this->reverse = true;
HXLINE( 312)			this->count = (int)0;
            		}
HXLINE( 316)		this->stencilStack->push(glData);
HXLINE( 318)		HX_VARI( Int,level) = this->count;
HXLINE( 321)		::lime::graphics::opengl::GL_obj::cffi_lime_gl_color_mask(false,false,false,false);
HXLINE( 323)		{
HXLINE( 323)			Int func = this->gl->ALWAYS;
HXDLIN( 323)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func,(int)0,(int)255);
            		}
HXLINE( 324)		{
HXLINE( 324)			Int fail = this->gl->KEEP;
HXDLIN( 324)			Int zfail = this->gl->KEEP;
HXDLIN( 324)			Int zpass = this->gl->INVERT;
HXDLIN( 324)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_op(fail,zfail,zpass);
            		}
HXLINE( 326)		Bool _hx_tmp1 = (glData->mode == (int)1);
HXDLIN( 326)		if (_hx_tmp1) {
HXLINE( 328)			{
HXLINE( 328)				Int mode = this->gl->TRIANGLE_FAN;
HXDLIN( 328)				Int count = (glData->indices->length - (int)4);
HXDLIN( 328)				Int type = this->gl->UNSIGNED_SHORT;
HXDLIN( 328)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_draw_elements(mode,count,type,(int)0);
            			}
HXLINE( 330)			Bool _hx_tmp2 = this->reverse;
HXDLIN( 330)			if (_hx_tmp2) {
HXLINE( 332)				{
HXLINE( 332)					Int func1 = this->gl->EQUAL;
HXDLIN( 332)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func1,((int)255 - level),(int)255);
            				}
HXLINE( 333)				{
HXLINE( 333)					Int fail1 = this->gl->KEEP;
HXDLIN( 333)					Int zfail1 = this->gl->KEEP;
HXDLIN( 333)					Int zpass1 = this->gl->DECR;
HXDLIN( 333)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_op(fail1,zfail1,zpass1);
            				}
            			}
            			else {
HXLINE( 337)				{
HXLINE( 337)					Int func2 = this->gl->EQUAL;
HXDLIN( 337)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func2,level,(int)255);
            				}
HXLINE( 338)				{
HXLINE( 338)					Int fail2 = this->gl->KEEP;
HXDLIN( 338)					Int zfail2 = this->gl->KEEP;
HXDLIN( 338)					Int zpass2 = this->gl->INCR;
HXDLIN( 338)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_op(fail2,zfail2,zpass2);
            				}
            			}
HXLINE( 342)			{
HXLINE( 342)				Int mode1 = this->gl->TRIANGLE_FAN;
HXDLIN( 342)				Int type1 = this->gl->UNSIGNED_SHORT;
HXDLIN( 342)				Int offset = ((glData->indices->length - (int)4) * (int)2);
HXDLIN( 342)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_draw_elements(mode1,(int)4,type1,offset);
            			}
HXLINE( 344)			Bool _hx_tmp3 = this->reverse;
HXDLIN( 344)			if (_hx_tmp3) {
HXLINE( 346)				Int func3 = this->gl->EQUAL;
HXDLIN( 346)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func3,((int)255 - (level + (int)1)),(int)255);
            			}
            			else {
HXLINE( 350)				Int func4 = this->gl->EQUAL;
HXDLIN( 350)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func4,(level + (int)1),(int)255);
            			}
HXLINE( 354)			this->reverse = !(this->reverse);
            		}
            		else {
HXLINE( 358)			Bool _hx_tmp4 = !(this->reverse);
HXDLIN( 358)			if (_hx_tmp4) {
HXLINE( 360)				{
HXLINE( 360)					Int func5 = this->gl->EQUAL;
HXDLIN( 360)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func5,((int)255 - level),(int)255);
            				}
HXLINE( 361)				{
HXLINE( 361)					Int fail3 = this->gl->KEEP;
HXDLIN( 361)					Int zfail3 = this->gl->KEEP;
HXDLIN( 361)					Int zpass3 = this->gl->DECR;
HXDLIN( 361)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_op(fail3,zfail3,zpass3);
            				}
            			}
            			else {
HXLINE( 365)				{
HXLINE( 365)					Int func6 = this->gl->EQUAL;
HXDLIN( 365)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func6,level,(int)255);
            				}
HXLINE( 366)				{
HXLINE( 366)					Int fail4 = this->gl->KEEP;
HXDLIN( 366)					Int zfail4 = this->gl->KEEP;
HXDLIN( 366)					Int zpass4 = this->gl->INCR;
HXDLIN( 366)					::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_op(fail4,zfail4,zpass4);
            				}
            			}
HXLINE( 370)			{
HXLINE( 370)				Int mode2 = this->gl->TRIANGLE_STRIP;
HXDLIN( 370)				Int count1 = glData->indices->length;
HXDLIN( 370)				Int type2 = this->gl->UNSIGNED_SHORT;
HXDLIN( 370)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_draw_elements(mode2,count1,type2,(int)0);
            			}
HXLINE( 372)			Bool _hx_tmp5 = !(this->reverse);
HXDLIN( 372)			if (_hx_tmp5) {
HXLINE( 374)				Int func7 = this->gl->EQUAL;
HXDLIN( 374)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func7,((int)255 - (level + (int)1)),(int)255);
            			}
            			else {
HXLINE( 378)				Int func8 = this->gl->EQUAL;
HXDLIN( 378)				::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_func(func8,(level + (int)1),(int)255);
            			}
            		}
HXLINE( 384)		::lime::graphics::opengl::GL_obj::cffi_lime_gl_color_mask(true,true,true,true);
HXLINE( 386)		{
HXLINE( 386)			Int fail5 = this->gl->KEEP;
HXDLIN( 386)			Int zfail5 = this->gl->KEEP;
HXDLIN( 386)			Int zpass5 = this->gl->KEEP;
HXDLIN( 386)			::lime::graphics::opengl::GL_obj::cffi_lime_gl_stencil_op(fail5,zfail5,zpass5);
            		}
HXLINE( 388)		this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC3(StencilManager_obj,pushStencil,(void))

void StencilManager_obj::setContext( ::lime::graphics::GLRenderContext gl){
            	HX_STACK_FRAME("openfl._internal.renderer.opengl.utils.StencilManager","setContext",0xdb9160e9,"openfl._internal.renderer.opengl.utils.StencilManager.setContext","openfl/_internal/renderer/opengl/utils/StencilManager.hx",395,0xffb0ff49)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(gl,"gl")
HXLINE( 395)		this->gl = gl;
            	}


HX_DEFINE_DYNAMIC_FUNC1(StencilManager_obj,setContext,(void))


StencilManager_obj::StencilManager_obj()
{
}

void StencilManager_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(StencilManager);
	HX_MARK_MEMBER_NAME(count,"count");
	HX_MARK_MEMBER_NAME(gl,"gl");
	HX_MARK_MEMBER_NAME(reverse,"reverse");
	HX_MARK_MEMBER_NAME(stencilStack,"stencilStack");
	HX_MARK_MEMBER_NAME(stencilMask,"stencilMask");
	HX_MARK_END_CLASS();
}

void StencilManager_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(count,"count");
	HX_VISIT_MEMBER_NAME(gl,"gl");
	HX_VISIT_MEMBER_NAME(reverse,"reverse");
	HX_VISIT_MEMBER_NAME(stencilStack,"stencilStack");
	HX_VISIT_MEMBER_NAME(stencilMask,"stencilMask");
}

hx::Val StencilManager_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { return hx::Val( gl); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"count") ) { return hx::Val( count); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"reverse") ) { return hx::Val( reverse); }
		if (HX_FIELD_EQ(inName,"popMask") ) { return hx::Val( popMask_dyn()); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return hx::Val( destroy_dyn()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"pushMask") ) { return hx::Val( pushMask_dyn()); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"popBucket") ) { return hx::Val( popBucket_dyn()); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"pushBucket") ) { return hx::Val( pushBucket_dyn()); }
		if (HX_FIELD_EQ(inName,"popStencil") ) { return hx::Val( popStencil_dyn()); }
		if (HX_FIELD_EQ(inName,"setContext") ) { return hx::Val( setContext_dyn()); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"stencilMask") ) { return hx::Val( stencilMask); }
		if (HX_FIELD_EQ(inName,"pushStencil") ) { return hx::Val( pushStencil_dyn()); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"stencilStack") ) { return hx::Val( stencilStack); }
		if (HX_FIELD_EQ(inName,"bindGraphics") ) { return hx::Val( bindGraphics_dyn()); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"prepareGraphics") ) { return hx::Val( prepareGraphics_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val StencilManager_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { gl=inValue.Cast<  ::lime::graphics::GLRenderContext >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"count") ) { count=inValue.Cast< Int >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"reverse") ) { reverse=inValue.Cast< Bool >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"stencilMask") ) { stencilMask=inValue.Cast< Int >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"stencilStack") ) { stencilStack=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void StencilManager_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("count","\xcf","\x44","\x63","\x4a"));
	outFields->push(HX_HCSTRING("gl","\x25","\x5a","\x00","\x00"));
	outFields->push(HX_HCSTRING("reverse","\x22","\x39","\xfc","\x1a"));
	outFields->push(HX_HCSTRING("stencilStack","\xac","\xe7","\x76","\xe1"));
	outFields->push(HX_HCSTRING("stencilMask","\x08","\xd9","\x4f","\x45"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo StencilManager_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(StencilManager_obj,count),HX_HCSTRING("count","\xcf","\x44","\x63","\x4a")},
	{hx::fsObject /*::lime::graphics::GLRenderContext*/ ,(int)offsetof(StencilManager_obj,gl),HX_HCSTRING("gl","\x25","\x5a","\x00","\x00")},
	{hx::fsBool,(int)offsetof(StencilManager_obj,reverse),HX_HCSTRING("reverse","\x22","\x39","\xfc","\x1a")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(StencilManager_obj,stencilStack),HX_HCSTRING("stencilStack","\xac","\xe7","\x76","\xe1")},
	{hx::fsInt,(int)offsetof(StencilManager_obj,stencilMask),HX_HCSTRING("stencilMask","\x08","\xd9","\x4f","\x45")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *StencilManager_obj_sStaticStorageInfo = 0;
#endif

static ::String StencilManager_obj_sMemberFields[] = {
	HX_HCSTRING("count","\xcf","\x44","\x63","\x4a"),
	HX_HCSTRING("gl","\x25","\x5a","\x00","\x00"),
	HX_HCSTRING("reverse","\x22","\x39","\xfc","\x1a"),
	HX_HCSTRING("stencilStack","\xac","\xe7","\x76","\xe1"),
	HX_HCSTRING("stencilMask","\x08","\xd9","\x4f","\x45"),
	HX_HCSTRING("prepareGraphics","\x72","\xa5","\xbe","\xc2"),
	HX_HCSTRING("pushBucket","\xe4","\x49","\x7c","\x22"),
	HX_HCSTRING("popBucket","\xdb","\xb8","\x12","\x4b"),
	HX_HCSTRING("pushMask","\xe6","\x73","\x47","\x17"),
	HX_HCSTRING("popMask","\x1d","\x67","\x11","\x43"),
	HX_HCSTRING("bindGraphics","\xa8","\x2f","\xe8","\xf8"),
	HX_HCSTRING("destroy","\xfa","\x2c","\x86","\x24"),
	HX_HCSTRING("popStencil","\x6b","\xcc","\xa7","\xea"),
	HX_HCSTRING("pushStencil","\x42","\x23","\x9d","\x8f"),
	HX_HCSTRING("setContext","\x6d","\xba","\x56","\x6c"),
	::String(null()) };

static void StencilManager_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(StencilManager_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void StencilManager_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(StencilManager_obj::__mClass,"__mClass");
};

#endif

hx::Class StencilManager_obj::__mClass;

void StencilManager_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl._internal.renderer.opengl.utils.StencilManager","\x72","\x70","\x91","\x37");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = StencilManager_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(StencilManager_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< StencilManager_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = StencilManager_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = StencilManager_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = StencilManager_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace openfl
} // end namespace _internal
} // end namespace renderer
} // end namespace opengl
} // end namespace utils
