// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_GLShaderParameter
#include <openfl/display/GLShaderParameter.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif

static const Float _hx_array_data_3[] = {
	0.0,
};
static const Float _hx_array_data_4[] = {
	0.0,
};
static const Float _hx_array_data_5[] = {
	0.0,
};
static const Float _hx_array_data_6[] = {
	(Float)1,(Float)0,(Float)1,(Float)0,
};
static const Float _hx_array_data_7[] = {
	(Float)1,(Float)0,(Float)0,(Float)0,(Float)1,(Float)0,(Float)0,(Float)0,(Float)1,
};
static const Float _hx_array_data_8[] = {
	(Float)1,(Float)0,(Float)0,(Float)0,(Float)0,(Float)1,(Float)0,(Float)0,(Float)0,(Float)0,(Float)1,(Float)0,(Float)0,(Float)0,(Float)0,(Float)1,
};
static const Float _hx_array_data_9[] = {
	(Float)0,
};
static const Float _hx_array_data_10[] = {
	(Float)1,(Float)0,(Float)1,(Float)0,
};
static const Float _hx_array_data_11[] = {
	(Float)1,(Float)0,(Float)0,(Float)0,(Float)1,(Float)0,(Float)0,(Float)0,(Float)1,
};
static const Float _hx_array_data_12[] = {
	(Float)1,(Float)0,(Float)0,(Float)0,(Float)0,(Float)1,(Float)0,(Float)0,(Float)0,(Float)0,(Float)1,(Float)0,(Float)0,(Float)0,(Float)0,(Float)1,
};
static const Float _hx_array_data_13[] = {
	(Float)0,
};
namespace openfl{
namespace display{

void GLShaderParameter_obj::__construct(::String type, ::Dynamic arraySize){
            	HX_STACK_FRAME("openfl.display.GLShaderParameter","new",0xc4078907,"openfl.display.GLShaderParameter.new","openfl/display/Shader.hx",196,0xae8f5dcd)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(type,"type")
            	HX_STACK_ARG(arraySize,"arraySize")
HXLINE( 237)		this->internalType = (int)0;
HXLINE( 235)		this->transpose = false;
HXLINE( 231)		this->repeatY = (int)33071;
HXLINE( 227)		this->repeatX = (int)33071;
HXLINE( 223)		this->smooth = false;
HXLINE( 211)		this->arraySize = (int)0;
HXLINE( 206)		this->size = (int)0;
HXLINE( 240)		this->type = type;
HXLINE( 241)		Int _hx_tmp;
HXDLIN( 241)		Bool _hx_tmp1 = hx::IsNull( arraySize );
HXDLIN( 241)		if (_hx_tmp1) {
HXLINE( 241)			_hx_tmp = (int)0;
            		}
            		else {
HXLINE( 241)			_hx_tmp = arraySize;
            		}
HXDLIN( 241)		this->arraySize = _hx_tmp;
HXLINE( 243)		this->_hx___init();
            	}

Dynamic GLShaderParameter_obj::__CreateEmpty() { return new GLShaderParameter_obj; }

hx::ObjectPtr< GLShaderParameter_obj > GLShaderParameter_obj::__new(::String type, ::Dynamic arraySize)
{
	hx::ObjectPtr< GLShaderParameter_obj > _hx_result = new GLShaderParameter_obj();
	_hx_result->__construct(type,arraySize);
	return _hx_result;
}

Dynamic GLShaderParameter_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< GLShaderParameter_obj > _hx_result = new GLShaderParameter_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

void GLShaderParameter_obj::_hx___init(){
            	HX_STACK_FRAME("openfl.display.GLShaderParameter","__init",0x508587e9,"openfl.display.GLShaderParameter.__init","openfl/display/Shader.hx",247,0xae8f5dcd)
            	HX_STACK_THIS(this)
HXLINE( 247)		HX_VARI( ::String,_g) = this->type;
HXDLIN( 247)		::String _hx_switch_0 = _g;
            		if (  (_hx_switch_0==HX_("bool",2a,84,1b,41)) ){
HXLINE( 249)			this->internalType = (int)1;
HXLINE( 250)			this->size = (int)1;
HXLINE( 252)			{
HXLINE( 252)				if ((this->internalType == (int)4)) {
HXLINE( 252)					HX_STACK_DO_THROW(HX_("This parameter doesn't accept a value, use bitmap instead",ef,e0,bb,96));
            				}
HXDLIN( 252)				this->value = ::Array_obj< Float >::fromData( _hx_array_data_3,1);
            			}
HXLINE( 248)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("float",9c,c5,96,02)) ){
HXLINE( 261)			this->internalType = (int)2;
HXLINE( 262)			this->size = (int)1;
HXLINE( 264)			{
HXLINE( 264)				if ((this->internalType == (int)4)) {
HXLINE( 264)					HX_STACK_DO_THROW(HX_("This parameter doesn't accept a value, use bitmap instead",ef,e0,bb,96));
            				}
HXDLIN( 264)				this->value = ::Array_obj< Float >::fromData( _hx_array_data_4,1);
            			}
HXLINE( 260)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("int",ef,0c,50,00)) ){
HXLINE( 255)			this->internalType = (int)1;
HXLINE( 256)			this->size = (int)1;
HXLINE( 258)			{
HXLINE( 258)				if ((this->internalType == (int)4)) {
HXLINE( 258)					HX_STACK_DO_THROW(HX_("This parameter doesn't accept a value, use bitmap instead",ef,e0,bb,96));
            				}
HXDLIN( 258)				this->value = ::Array_obj< Float >::fromData( _hx_array_data_5,1);
            			}
HXLINE( 254)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("sampler2D",da,42,8b,5d)) ||  (_hx_switch_0==HX_("samplerCube",1d,52,67,54)) ){
HXLINE( 266)			Int _hx_tmp = _g.indexOf(HX_("vec",54,e2,59,00),null());
HXDLIN( 266)			if ((_hx_tmp > (int)-1)) {
HXLINE( 267)				Bool _hx_tmp1;
HXDLIN( 267)				Bool _hx_tmp2 = !(::StringTools_obj::startsWith(this->type,HX_("b",62,00,00,00)));
HXDLIN( 267)				if (_hx_tmp2) {
HXLINE( 267)					_hx_tmp1 = ::StringTools_obj::startsWith(this->type,HX_("i",69,00,00,00));
            				}
            				else {
HXLINE( 267)					_hx_tmp1 = true;
            				}
HXDLIN( 267)				if (_hx_tmp1) {
HXLINE( 268)					this->internalType = (int)1;
            				}
            				else {
HXLINE( 270)					this->internalType = (int)2;
            				}
HXLINE( 272)				Int _hx_tmp3 = (this->type.length - (int)1);
HXDLIN( 272)				::String _hx_tmp4 = this->type.charAt(_hx_tmp3);
HXDLIN( 272)				HX_VARI(  ::Dynamic,s) = ::Std_obj::parseInt(_hx_tmp4);
HXLINE( 273)				this->size = s;
HXLINE( 275)				{
HXLINE( 275)					HX_VARI_NAME( ::Array< Float >,_g1,"_g") = ::Array_obj< Float >::__new(0);
HXDLIN( 275)					{
HXLINE( 275)						HX_VARI( Int,_g2) = (int)0;
HXDLIN( 275)						HX_VARI_NAME( Int,_g11,"_g1") = this->size;
HXDLIN( 275)						while((_g2 < _g11)){
HXLINE( 275)							++_g2;
HXDLIN( 275)							_g1->push(((Float)0.0));
            						}
            					}
HXDLIN( 275)					if ((this->internalType == (int)4)) {
HXLINE( 275)						HX_STACK_DO_THROW(HX_("This parameter doesn't accept a value, use bitmap instead",ef,e0,bb,96));
            					}
HXDLIN( 275)					this->value = _g1;
            				}
            			}
            			else {
HXLINE( 277)				Int _hx_tmp5 = _g.indexOf(HX_("mat",a0,0a,53,00),null());
HXDLIN( 277)				if ((_hx_tmp5 > (int)-1)) {
HXLINE( 278)					this->internalType = (int)3;
HXLINE( 279)					Int _hx_tmp6 = (this->type.length - (int)1);
HXDLIN( 279)					::String _hx_tmp7 = this->type.charAt(_hx_tmp6);
HXDLIN( 279)					HX_VARI_NAME(  ::Dynamic,s1,"s") = ::Std_obj::parseInt(_hx_tmp7);
HXLINE( 280)					this->size = s1;
HXLINE( 282)					{
HXLINE( 282)						::Array< Float > v;
HXDLIN( 282)						switch((int)(this->size)){
            							case (int)2: {
HXLINE( 282)								v = ::Array_obj< Float >::fromData( _hx_array_data_6,4);
            							}
            							break;
            							case (int)3: {
HXLINE( 282)								v = ::Array_obj< Float >::fromData( _hx_array_data_7,9);
            							}
            							break;
            							case (int)4: {
HXLINE( 282)								v = ::Array_obj< Float >::fromData( _hx_array_data_8,16);
            							}
            							break;
            							default:{
HXLINE( 282)								v = ::Array_obj< Float >::fromData( _hx_array_data_9,1);
            							}
            						}
HXDLIN( 282)						if ((this->internalType == (int)4)) {
HXLINE( 282)							HX_STACK_DO_THROW(HX_("This parameter doesn't accept a value, use bitmap instead",ef,e0,bb,96));
            						}
HXDLIN( 282)						this->value = v;
            					}
            				}
            				else {
HXLINE( 303)					this->internalType = (int)4;
HXLINE( 304)					this->size = (int)0;
            				}
            			}
HXLINE( 266)			goto _hx_goto_1;
            		}
            		/* default */{
HXLINE( 266)			Int _hx_tmp8 = _g.indexOf(HX_("vec",54,e2,59,00),null());
HXDLIN( 266)			if ((_hx_tmp8 > (int)-1)) {
HXLINE( 267)				Bool _hx_tmp9;
HXDLIN( 267)				Bool _hx_tmp10 = !(::StringTools_obj::startsWith(this->type,HX_("b",62,00,00,00)));
HXDLIN( 267)				if (_hx_tmp10) {
HXLINE( 267)					_hx_tmp9 = ::StringTools_obj::startsWith(this->type,HX_("i",69,00,00,00));
            				}
            				else {
HXLINE( 267)					_hx_tmp9 = true;
            				}
HXDLIN( 267)				if (_hx_tmp9) {
HXLINE( 268)					this->internalType = (int)1;
            				}
            				else {
HXLINE( 270)					this->internalType = (int)2;
            				}
HXLINE( 272)				Int _hx_tmp11 = (this->type.length - (int)1);
HXDLIN( 272)				::String _hx_tmp12 = this->type.charAt(_hx_tmp11);
HXDLIN( 272)				HX_VARI_NAME(  ::Dynamic,s2,"s") = ::Std_obj::parseInt(_hx_tmp12);
HXLINE( 273)				this->size = s2;
HXLINE( 275)				{
HXLINE( 275)					HX_VARI_NAME( ::Array< Float >,_g3,"_g") = ::Array_obj< Float >::__new(0);
HXDLIN( 275)					{
HXLINE( 275)						HX_VARI_NAME( Int,_g21,"_g2") = (int)0;
HXDLIN( 275)						HX_VARI_NAME( Int,_g12,"_g1") = this->size;
HXDLIN( 275)						while((_g21 < _g12)){
HXLINE( 275)							++_g21;
HXDLIN( 275)							_g3->push(((Float)0.0));
            						}
            					}
HXDLIN( 275)					if ((this->internalType == (int)4)) {
HXLINE( 275)						HX_STACK_DO_THROW(HX_("This parameter doesn't accept a value, use bitmap instead",ef,e0,bb,96));
            					}
HXDLIN( 275)					this->value = _g3;
            				}
            			}
            			else {
HXLINE( 277)				Int _hx_tmp13 = _g.indexOf(HX_("mat",a0,0a,53,00),null());
HXDLIN( 277)				if ((_hx_tmp13 > (int)-1)) {
HXLINE( 278)					this->internalType = (int)3;
HXLINE( 279)					Int _hx_tmp14 = (this->type.length - (int)1);
HXDLIN( 279)					::String _hx_tmp15 = this->type.charAt(_hx_tmp14);
HXDLIN( 279)					HX_VARI_NAME(  ::Dynamic,s3,"s") = ::Std_obj::parseInt(_hx_tmp15);
HXLINE( 280)					this->size = s3;
HXLINE( 282)					{
HXLINE( 282)						::Array< Float > v1;
HXDLIN( 282)						switch((int)(this->size)){
            							case (int)2: {
HXLINE( 282)								v1 = ::Array_obj< Float >::fromData( _hx_array_data_10,4);
            							}
            							break;
            							case (int)3: {
HXLINE( 282)								v1 = ::Array_obj< Float >::fromData( _hx_array_data_11,9);
            							}
            							break;
            							case (int)4: {
HXLINE( 282)								v1 = ::Array_obj< Float >::fromData( _hx_array_data_12,16);
            							}
            							break;
            							default:{
HXLINE( 282)								v1 = ::Array_obj< Float >::fromData( _hx_array_data_13,1);
            							}
            						}
HXDLIN( 282)						if ((this->internalType == (int)4)) {
HXLINE( 282)							HX_STACK_DO_THROW(HX_("This parameter doesn't accept a value, use bitmap instead",ef,e0,bb,96));
            						}
HXDLIN( 282)						this->value = v1;
            					}
            				}
            				else {
HXLINE( 306)					this->internalType = (int)0;
HXLINE( 307)					::haxe::Log_obj::trace((HX_("Can't initialize value for type ",73,3e,80,a4) + this->type),hx::SourceInfo(HX_("Shader.hx",99,a8,0b,d1),307,HX_("openfl.display.GLShaderParameter",95,f9,26,89),HX_("__init",30,9e,b3,f4)));
            				}
            			}
            		}
            		_hx_goto_1:;
            	}


HX_DEFINE_DYNAMIC_FUNC0(GLShaderParameter_obj,_hx___init,(void))

::Array< Float > GLShaderParameter_obj::set_value(::Array< Float > v){
            	HX_STACK_FRAME("openfl.display.GLShaderParameter","set_value",0xf280f7bb,"openfl.display.GLShaderParameter.set_value","openfl/display/Shader.hx",311,0xae8f5dcd)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(v,"v")
HXLINE( 312)		if ((this->internalType == (int)4)) {
HXLINE( 312)			HX_STACK_DO_THROW(HX_("This parameter doesn't accept a value, use bitmap instead",ef,e0,bb,96));
            		}
HXLINE( 313)		return (this->value = v);
            	}


HX_DEFINE_DYNAMIC_FUNC1(GLShaderParameter_obj,set_value,return )

 ::openfl::display::BitmapData GLShaderParameter_obj::set_bitmap( ::openfl::display::BitmapData v){
            	HX_STACK_FRAME("openfl.display.GLShaderParameter","set_bitmap",0xdfacd865,"openfl.display.GLShaderParameter.set_bitmap","openfl/display/Shader.hx",315,0xae8f5dcd)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(v,"v")
HXLINE( 316)		if ((this->internalType != (int)4)) {
HXLINE( 316)			HX_STACK_DO_THROW(HX_("This parameter doesn't accept a bitmap, use value instead",37,1c,84,b0));
            		}
HXLINE( 317)		return (this->bitmap = v);
            	}


HX_DEFINE_DYNAMIC_FUNC1(GLShaderParameter_obj,set_bitmap,return )


GLShaderParameter_obj::GLShaderParameter_obj()
{
}

void GLShaderParameter_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(GLShaderParameter);
	HX_MARK_MEMBER_NAME(type,"type");
	HX_MARK_MEMBER_NAME(size,"size");
	HX_MARK_MEMBER_NAME(arraySize,"arraySize");
	HX_MARK_MEMBER_NAME(value,"value");
	HX_MARK_MEMBER_NAME(bitmap,"bitmap");
	HX_MARK_MEMBER_NAME(smooth,"smooth");
	HX_MARK_MEMBER_NAME(repeatX,"repeatX");
	HX_MARK_MEMBER_NAME(repeatY,"repeatY");
	HX_MARK_MEMBER_NAME(transpose,"transpose");
	HX_MARK_MEMBER_NAME(internalType,"internalType");
	HX_MARK_END_CLASS();
}

void GLShaderParameter_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(type,"type");
	HX_VISIT_MEMBER_NAME(size,"size");
	HX_VISIT_MEMBER_NAME(arraySize,"arraySize");
	HX_VISIT_MEMBER_NAME(value,"value");
	HX_VISIT_MEMBER_NAME(bitmap,"bitmap");
	HX_VISIT_MEMBER_NAME(smooth,"smooth");
	HX_VISIT_MEMBER_NAME(repeatX,"repeatX");
	HX_VISIT_MEMBER_NAME(repeatY,"repeatY");
	HX_VISIT_MEMBER_NAME(transpose,"transpose");
	HX_VISIT_MEMBER_NAME(internalType,"internalType");
}

hx::Val GLShaderParameter_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { return hx::Val( type); }
		if (HX_FIELD_EQ(inName,"size") ) { return hx::Val( size); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"value") ) { return hx::Val( value); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"bitmap") ) { return hx::Val( bitmap); }
		if (HX_FIELD_EQ(inName,"smooth") ) { return hx::Val( smooth); }
		if (HX_FIELD_EQ(inName,"__init") ) { return hx::Val( _hx___init_dyn()); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"repeatX") ) { return hx::Val( repeatX); }
		if (HX_FIELD_EQ(inName,"repeatY") ) { return hx::Val( repeatY); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"arraySize") ) { return hx::Val( arraySize); }
		if (HX_FIELD_EQ(inName,"transpose") ) { return hx::Val( transpose); }
		if (HX_FIELD_EQ(inName,"set_value") ) { return hx::Val( set_value_dyn()); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"set_bitmap") ) { return hx::Val( set_bitmap_dyn()); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"internalType") ) { return hx::Val( internalType); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val GLShaderParameter_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { type=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"size") ) { size=inValue.Cast< Int >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"value") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_value(inValue) );value=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"bitmap") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_bitmap(inValue) );bitmap=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"smooth") ) { smooth=inValue.Cast< Bool >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"repeatX") ) { repeatX=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"repeatY") ) { repeatY=inValue.Cast< Int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"arraySize") ) { arraySize=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"transpose") ) { transpose=inValue.Cast< Bool >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"internalType") ) { internalType=inValue.Cast< Int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void GLShaderParameter_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("type","\xba","\xf2","\x08","\x4d"));
	outFields->push(HX_HCSTRING("size","\xc1","\xa0","\x53","\x4c"));
	outFields->push(HX_HCSTRING("arraySize","\xfa","\x7a","\xc5","\x95"));
	outFields->push(HX_HCSTRING("value","\x71","\x7f","\xb8","\x31"));
	outFields->push(HX_HCSTRING("bitmap","\xef","\x0f","\x0c","\xf1"));
	outFields->push(HX_HCSTRING("smooth","\x2e","\x08","\x6b","\x07"));
	outFields->push(HX_HCSTRING("repeatX","\x9d","\xd8","\x87","\xa6"));
	outFields->push(HX_HCSTRING("repeatY","\x9e","\xd8","\x87","\xa6"));
	outFields->push(HX_HCSTRING("transpose","\x79","\x50","\x2f","\x4c"));
	outFields->push(HX_HCSTRING("internalType","\x97","\x68","\x89","\x38"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo GLShaderParameter_obj_sMemberStorageInfo[] = {
	{hx::fsString,(int)offsetof(GLShaderParameter_obj,type),HX_HCSTRING("type","\xba","\xf2","\x08","\x4d")},
	{hx::fsInt,(int)offsetof(GLShaderParameter_obj,size),HX_HCSTRING("size","\xc1","\xa0","\x53","\x4c")},
	{hx::fsInt,(int)offsetof(GLShaderParameter_obj,arraySize),HX_HCSTRING("arraySize","\xfa","\x7a","\xc5","\x95")},
	{hx::fsObject /*Array< Float >*/ ,(int)offsetof(GLShaderParameter_obj,value),HX_HCSTRING("value","\x71","\x7f","\xb8","\x31")},
	{hx::fsObject /*::openfl::display::BitmapData*/ ,(int)offsetof(GLShaderParameter_obj,bitmap),HX_HCSTRING("bitmap","\xef","\x0f","\x0c","\xf1")},
	{hx::fsBool,(int)offsetof(GLShaderParameter_obj,smooth),HX_HCSTRING("smooth","\x2e","\x08","\x6b","\x07")},
	{hx::fsInt,(int)offsetof(GLShaderParameter_obj,repeatX),HX_HCSTRING("repeatX","\x9d","\xd8","\x87","\xa6")},
	{hx::fsInt,(int)offsetof(GLShaderParameter_obj,repeatY),HX_HCSTRING("repeatY","\x9e","\xd8","\x87","\xa6")},
	{hx::fsBool,(int)offsetof(GLShaderParameter_obj,transpose),HX_HCSTRING("transpose","\x79","\x50","\x2f","\x4c")},
	{hx::fsInt,(int)offsetof(GLShaderParameter_obj,internalType),HX_HCSTRING("internalType","\x97","\x68","\x89","\x38")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *GLShaderParameter_obj_sStaticStorageInfo = 0;
#endif

static ::String GLShaderParameter_obj_sMemberFields[] = {
	HX_HCSTRING("type","\xba","\xf2","\x08","\x4d"),
	HX_HCSTRING("size","\xc1","\xa0","\x53","\x4c"),
	HX_HCSTRING("arraySize","\xfa","\x7a","\xc5","\x95"),
	HX_HCSTRING("value","\x71","\x7f","\xb8","\x31"),
	HX_HCSTRING("bitmap","\xef","\x0f","\x0c","\xf1"),
	HX_HCSTRING("smooth","\x2e","\x08","\x6b","\x07"),
	HX_HCSTRING("repeatX","\x9d","\xd8","\x87","\xa6"),
	HX_HCSTRING("repeatY","\x9e","\xd8","\x87","\xa6"),
	HX_HCSTRING("transpose","\x79","\x50","\x2f","\x4c"),
	HX_HCSTRING("internalType","\x97","\x68","\x89","\x38"),
	HX_HCSTRING("__init","\x30","\x9e","\xb3","\xf4"),
	HX_HCSTRING("set_value","\xd4","\xc7","\xb2","\x58"),
	HX_HCSTRING("set_bitmap","\x2c","\x1e","\x11","\xe5"),
	::String(null()) };

static void GLShaderParameter_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(GLShaderParameter_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void GLShaderParameter_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(GLShaderParameter_obj::__mClass,"__mClass");
};

#endif

hx::Class GLShaderParameter_obj::__mClass;

void GLShaderParameter_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl.display.GLShaderParameter","\x95","\xf9","\x26","\x89");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = GLShaderParameter_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(GLShaderParameter_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< GLShaderParameter_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = GLShaderParameter_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = GLShaderParameter_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = GLShaderParameter_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace openfl
} // end namespace display
