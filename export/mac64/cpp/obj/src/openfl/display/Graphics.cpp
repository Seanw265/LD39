// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_lime_graphics_Image
#include <lime/graphics/Image.h>
#endif
#ifndef INCLUDED_lime_graphics_cairo_Cairo
#include <lime/graphics/cairo/Cairo.h>
#endif
#ifndef INCLUDED_openfl_Lib
#include <openfl/Lib.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_DrawCommandBuffer
#include <openfl/_internal/renderer/DrawCommandBuffer.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_cairo_CairoGraphics
#include <openfl/_internal/renderer/cairo/CairoGraphics.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_DrawPath
#include <openfl/_internal/renderer/opengl/utils/DrawPath.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_GLStack
#include <openfl/_internal/renderer/opengl/utils/GLStack.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_utils_RenderTexture
#include <openfl/_internal/renderer/opengl/utils/RenderTexture.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsBitmapFill
#include <openfl/display/GraphicsBitmapFill.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsEndFill
#include <openfl/display/GraphicsEndFill.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsGradientFill
#include <openfl/display/GraphicsGradientFill.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsPath
#include <openfl/display/GraphicsPath.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsSolidFill
#include <openfl/display/GraphicsSolidFill.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsStroke
#include <openfl/display/GraphicsStroke.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_IGraphicsData
#include <openfl/display/IGraphicsData.h>
#endif
#ifndef INCLUDED_openfl_display_IGraphicsFill
#include <openfl/display/IGraphicsFill.h>
#endif
#ifndef INCLUDED_openfl_display_IGraphicsPath
#include <openfl/display/IGraphicsPath.h>
#endif
#ifndef INCLUDED_openfl_display_IGraphicsStroke
#include <openfl/display/IGraphicsStroke.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_Tilesheet
#include <openfl/display/Tilesheet.h>
#endif
#ifndef INCLUDED_openfl_errors_ArgumentError
#include <openfl/errors/ArgumentError.h>
#endif
#ifndef INCLUDED_openfl_errors_Error
#include <openfl/errors/Error.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_filters_BitmapFilter
#include <openfl/filters/BitmapFilter.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

namespace openfl{
namespace display{

void Graphics_obj::__construct(){
            	HX_STACK_FRAME("openfl.display.Graphics","new",0x7fd846a7,"openfl.display.Graphics.new","openfl/display/Graphics.hx",36,0x8d299ce7)
            	HX_STACK_THIS(this)
HXLINE(  64)		this->_hx___glStack = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  63)		this->_hx___dirty = true;
HXLINE(  87)		this->_hx___commands =  ::openfl::_internal::renderer::DrawCommandBuffer_obj::__new();
HXLINE(  88)		this->_hx___strokePadding = (int)0;
HXLINE(  89)		this->_hx___positionX = (int)0;
HXLINE(  90)		this->_hx___positionY = (int)0;
HXLINE(  91)		this->_hx___hardware = true;
            	}

Dynamic Graphics_obj::__CreateEmpty() { return new Graphics_obj; }

hx::ObjectPtr< Graphics_obj > Graphics_obj::__new()
{
	hx::ObjectPtr< Graphics_obj > _hx_result = new Graphics_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic Graphics_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Graphics_obj > _hx_result = new Graphics_obj();
	_hx_result->__construct();
	return _hx_result;
}

void Graphics_obj::beginBitmapFill( ::openfl::display::BitmapData bitmap, ::openfl::geom::Matrix matrix,hx::Null< Bool >  __o_repeat,hx::Null< Bool >  __o_smooth){
Bool repeat = __o_repeat.Default(true);
Bool smooth = __o_smooth.Default(false);
            	HX_STACK_FRAME("openfl.display.Graphics","beginBitmapFill",0x31c80e62,"openfl.display.Graphics.beginBitmapFill","openfl/display/Graphics.hx",100,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(bitmap,"bitmap")
            	HX_STACK_ARG(matrix,"matrix")
            	HX_STACK_ARG(repeat,"repeat")
            	HX_STACK_ARG(smooth,"smooth")
HXLINE( 102)		 ::openfl::geom::Matrix _hx_tmp;
HXDLIN( 102)		Bool _hx_tmp1 = hx::IsNotNull( matrix );
HXDLIN( 102)		if (_hx_tmp1) {
HXLINE( 102)			_hx_tmp = matrix->clone();
            		}
            		else {
HXLINE( 102)			_hx_tmp = null();
            		}
HXDLIN( 102)		this->_hx___commands->beginBitmapFill(bitmap,_hx_tmp,repeat,smooth);
HXLINE( 104)		this->_hx___visible = true;
            	}


HX_DEFINE_DYNAMIC_FUNC4(Graphics_obj,beginBitmapFill,(void))

void Graphics_obj::beginFill(hx::Null< Int >  __o_color,hx::Null< Float >  __o_alpha){
Int color = __o_color.Default(0);
Float alpha = __o_alpha.Default(1);
            	HX_STACK_FRAME("openfl.display.Graphics","beginFill",0xf44a92d3,"openfl.display.Graphics.beginFill","openfl/display/Graphics.hx",109,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(color,"color")
            	HX_STACK_ARG(alpha,"alpha")
HXLINE( 111)		this->_hx___commands->beginFill(((int)color & (int)(int)16777215),alpha);
HXLINE( 113)		if ((alpha > (int)0)) {
HXLINE( 113)			this->_hx___visible = true;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Graphics_obj,beginFill,(void))

void Graphics_obj::beginGradientFill( ::Dynamic type,::Array< Int > colors,::Array< Float > alphas,::Array< Int > ratios, ::openfl::geom::Matrix matrix, ::Dynamic __o_spreadMethod, ::Dynamic __o_interpolationMethod,hx::Null< Float >  __o_focalPointRatio){
 ::Dynamic spreadMethod = __o_spreadMethod.Default(0);
 ::Dynamic interpolationMethod = __o_interpolationMethod.Default(1);
Float focalPointRatio = __o_focalPointRatio.Default(0);
            	HX_STACK_FRAME("openfl.display.Graphics","beginGradientFill",0x99f380e3,"openfl.display.Graphics.beginGradientFill","openfl/display/Graphics.hx",118,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(type,"type")
            	HX_STACK_ARG(colors,"colors")
            	HX_STACK_ARG(alphas,"alphas")
            	HX_STACK_ARG(ratios,"ratios")
            	HX_STACK_ARG(matrix,"matrix")
            	HX_STACK_ARG(spreadMethod,"spreadMethod")
            	HX_STACK_ARG(interpolationMethod,"interpolationMethod")
            	HX_STACK_ARG(focalPointRatio,"focalPointRatio")
HXLINE( 120)		this->_hx___commands->beginGradientFill(type,colors,alphas,ratios,matrix,spreadMethod,interpolationMethod,focalPointRatio);
HXLINE( 121)		this->_hx___hardware = false;
HXLINE( 123)		{
HXLINE( 123)			HX_VARI( Int,_g) = (int)0;
HXDLIN( 123)			while((_g < alphas->length)){
HXLINE( 123)				HX_VARI( Float,alpha) = alphas->__get(_g);
HXDLIN( 123)				++_g;
HXLINE( 125)				if ((alpha > (int)0)) {
HXLINE( 127)					this->_hx___visible = true;
HXLINE( 128)					goto _hx_goto_0;
            				}
            			}
            			_hx_goto_0:;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC8(Graphics_obj,beginGradientFill,(void))

void Graphics_obj::clear(){
            	HX_STACK_FRAME("openfl.display.Graphics","clear",0x0a9f4794,"openfl.display.Graphics.clear","openfl/display/Graphics.hx",137,0x8d299ce7)
            	HX_STACK_THIS(this)
HXLINE( 139)		this->_hx___commands->clear();
HXLINE( 140)		this->_hx___strokePadding = (int)0;
HXLINE( 142)		Bool _hx_tmp = hx::IsNotNull( this->_hx___bounds );
HXDLIN( 142)		if (_hx_tmp) {
HXLINE( 144)			this->set___dirty(true);
HXLINE( 145)			this->_hx___transformDirty = true;
HXLINE( 146)			this->_hx___bounds = null();
            		}
HXLINE( 150)		this->_hx___visible = false;
HXLINE( 151)		this->_hx___hardware = true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Graphics_obj,clear,(void))

void Graphics_obj::copyFrom( ::openfl::display::Graphics sourceGraphics){
            	HX_STACK_FRAME("openfl.display.Graphics","copyFrom",0x0a477418,"openfl.display.Graphics.copyFrom","openfl/display/Graphics.hx",160,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(sourceGraphics,"sourceGraphics")
HXLINE( 162)		 ::openfl::geom::Rectangle _hx_tmp;
HXDLIN( 162)		Bool _hx_tmp1 = hx::IsNotNull( sourceGraphics->_hx___bounds );
HXDLIN( 162)		if (_hx_tmp1) {
HXLINE( 162)			_hx_tmp = sourceGraphics->_hx___bounds->clone();
            		}
            		else {
HXLINE( 162)			_hx_tmp = null();
            		}
HXDLIN( 162)		this->_hx___bounds = _hx_tmp;
HXLINE( 163)		this->_hx___commands = sourceGraphics->_hx___commands->copy();
HXLINE( 164)		this->set___dirty(true);
HXLINE( 165)		this->_hx___strokePadding = sourceGraphics->_hx___strokePadding;
HXLINE( 166)		this->_hx___positionX = sourceGraphics->_hx___positionX;
HXLINE( 167)		this->_hx___positionY = sourceGraphics->_hx___positionY;
HXLINE( 168)		this->_hx___transformDirty = true;
HXLINE( 169)		this->_hx___visible = sourceGraphics->_hx___visible;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Graphics_obj,copyFrom,(void))

void Graphics_obj::cubicCurveTo(Float controlX1,Float controlY1,Float controlX2,Float controlY2,Float anchorX,Float anchorY){
            	HX_STACK_FRAME("openfl.display.Graphics","cubicCurveTo",0x467410b9,"openfl.display.Graphics.cubicCurveTo","openfl/display/Graphics.hx",174,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(controlX1,"controlX1")
            	HX_STACK_ARG(controlY1,"controlY1")
            	HX_STACK_ARG(controlX2,"controlX2")
            	HX_STACK_ARG(controlY2,"controlY2")
            	HX_STACK_ARG(anchorX,"anchorX")
            	HX_STACK_ARG(anchorY,"anchorY")
HXLINE( 176)		Float _hx_tmp = (this->_hx___positionX - this->_hx___strokePadding);
HXDLIN( 176)		Float _hx_tmp1 = (this->_hx___positionY - this->_hx___strokePadding);
HXDLIN( 176)		this->_hx___inflateBounds(_hx_tmp,_hx_tmp1);
HXLINE( 177)		Float _hx_tmp2 = (this->_hx___positionX + this->_hx___strokePadding);
HXDLIN( 177)		Float _hx_tmp3 = (this->_hx___positionY + this->_hx___strokePadding);
HXDLIN( 177)		this->_hx___inflateBounds(_hx_tmp2,_hx_tmp3);
HXLINE( 179)		HX_VAR( Float,ix1);
HXDLIN( 179)		HX_VAR( Float,iy1);
HXDLIN( 179)		HX_VAR( Float,ix2);
HXDLIN( 179)		HX_VAR( Float,iy2);
HXLINE( 181)		ix1 = anchorX;
HXLINE( 182)		ix2 = anchorX;
HXLINE( 184)		Bool _hx_tmp4;
HXDLIN( 184)		Bool _hx_tmp5;
HXDLIN( 184)		Bool _hx_tmp6;
HXDLIN( 184)		if ((controlX1 < anchorX)) {
HXLINE( 184)			_hx_tmp6 = (controlX1 > this->_hx___positionX);
            		}
            		else {
HXLINE( 184)			_hx_tmp6 = false;
            		}
HXDLIN( 184)		if (!(_hx_tmp6)) {
HXLINE( 184)			if ((controlX1 > anchorX)) {
HXLINE( 184)				_hx_tmp5 = (controlX1 < this->_hx___positionX);
            			}
            			else {
HXLINE( 184)				_hx_tmp5 = false;
            			}
            		}
            		else {
HXLINE( 184)			_hx_tmp5 = true;
            		}
HXDLIN( 184)		if (_hx_tmp5) {
HXLINE( 184)			Bool _hx_tmp7;
HXDLIN( 184)			if ((controlX2 < anchorX)) {
HXLINE( 184)				_hx_tmp7 = (controlX2 > this->_hx___positionX);
            			}
            			else {
HXLINE( 184)				_hx_tmp7 = false;
            			}
HXDLIN( 184)			if (!(_hx_tmp7)) {
HXLINE( 184)				if ((controlX2 > anchorX)) {
HXLINE( 184)					_hx_tmp4 = (controlX2 < this->_hx___positionX);
            				}
            				else {
HXLINE( 184)					_hx_tmp4 = false;
            				}
            			}
            			else {
HXLINE( 184)				_hx_tmp4 = true;
            			}
            		}
            		else {
HXLINE( 184)			_hx_tmp4 = false;
            		}
HXDLIN( 184)		if (!(_hx_tmp4)) {
HXLINE( 186)			HX_VARI( Float,u) = ((((int)2 * this->_hx___positionX) - ((int)4 * controlX1)) + ((int)2 * controlX2));
HXLINE( 187)			HX_VARI( Float,v) = (controlX1 - this->_hx___positionX);
HXLINE( 188)			HX_VARI( Float,w) = (((-(this->_hx___positionX) + ((int)3 * controlX1)) + anchorX) - ((int)3 * controlX2));
HXLINE( 190)			Float _hx_tmp8 = ::Math_obj::sqrt(((u * u) - (((int)4 * v) * w)));
HXDLIN( 190)			HX_VARI( Float,t1) = ((Float)(-(u) + _hx_tmp8) / (Float)((int)2 * w));
HXLINE( 191)			Float _hx_tmp9 = ::Math_obj::sqrt(((u * u) - (((int)4 * v) * w)));
HXDLIN( 191)			HX_VARI( Float,t2) = ((Float)(-(u) - _hx_tmp9) / (Float)((int)2 * w));
HXLINE( 193)			Bool _hx_tmp10;
HXDLIN( 193)			if ((t1 > (int)0)) {
HXLINE( 193)				_hx_tmp10 = (t1 < (int)1);
            			}
            			else {
HXLINE( 193)				_hx_tmp10 = false;
            			}
HXDLIN( 193)			if (_hx_tmp10) {
HXLINE( 195)				ix1 = this->_hx___calculateBezierCubicPoint(t1,this->_hx___positionX,controlX1,controlX2,anchorX);
            			}
HXLINE( 199)			Bool _hx_tmp11;
HXDLIN( 199)			if ((t2 > (int)0)) {
HXLINE( 199)				_hx_tmp11 = (t2 < (int)1);
            			}
            			else {
HXLINE( 199)				_hx_tmp11 = false;
            			}
HXDLIN( 199)			if (_hx_tmp11) {
HXLINE( 201)				ix2 = this->_hx___calculateBezierCubicPoint(t2,this->_hx___positionX,controlX1,controlX2,anchorX);
            			}
            		}
HXLINE( 207)		iy1 = anchorY;
HXLINE( 208)		iy2 = anchorY;
HXLINE( 210)		Bool _hx_tmp12;
HXDLIN( 210)		Bool _hx_tmp13;
HXDLIN( 210)		Bool _hx_tmp14;
HXDLIN( 210)		if ((controlY1 < anchorY)) {
HXLINE( 210)			_hx_tmp14 = (controlY1 > this->_hx___positionX);
            		}
            		else {
HXLINE( 210)			_hx_tmp14 = false;
            		}
HXDLIN( 210)		if (!(_hx_tmp14)) {
HXLINE( 210)			if ((controlY1 > anchorY)) {
HXLINE( 210)				_hx_tmp13 = (controlY1 < this->_hx___positionX);
            			}
            			else {
HXLINE( 210)				_hx_tmp13 = false;
            			}
            		}
            		else {
HXLINE( 210)			_hx_tmp13 = true;
            		}
HXDLIN( 210)		if (_hx_tmp13) {
HXLINE( 210)			Bool _hx_tmp15;
HXDLIN( 210)			if ((controlY2 < anchorY)) {
HXLINE( 210)				_hx_tmp15 = (controlY2 > this->_hx___positionX);
            			}
            			else {
HXLINE( 210)				_hx_tmp15 = false;
            			}
HXDLIN( 210)			if (!(_hx_tmp15)) {
HXLINE( 210)				if ((controlY2 > anchorY)) {
HXLINE( 210)					_hx_tmp12 = (controlY2 < this->_hx___positionX);
            				}
            				else {
HXLINE( 210)					_hx_tmp12 = false;
            				}
            			}
            			else {
HXLINE( 210)				_hx_tmp12 = true;
            			}
            		}
            		else {
HXLINE( 210)			_hx_tmp12 = false;
            		}
HXDLIN( 210)		if (!(_hx_tmp12)) {
HXLINE( 212)			HX_VARI_NAME( Float,u1,"u") = ((((int)2 * this->_hx___positionX) - ((int)4 * controlY1)) + ((int)2 * controlY2));
HXLINE( 213)			HX_VARI_NAME( Float,v1,"v") = (controlY1 - this->_hx___positionX);
HXLINE( 214)			HX_VARI_NAME( Float,w1,"w") = (((-(this->_hx___positionX) + ((int)3 * controlY1)) + anchorY) - ((int)3 * controlY2));
HXLINE( 216)			Float _hx_tmp16 = ::Math_obj::sqrt(((u1 * u1) - (((int)4 * v1) * w1)));
HXDLIN( 216)			HX_VARI_NAME( Float,t11,"t1") = ((Float)(-(u1) + _hx_tmp16) / (Float)((int)2 * w1));
HXLINE( 217)			Float _hx_tmp17 = ::Math_obj::sqrt(((u1 * u1) - (((int)4 * v1) * w1)));
HXDLIN( 217)			HX_VARI_NAME( Float,t21,"t2") = ((Float)(-(u1) - _hx_tmp17) / (Float)((int)2 * w1));
HXLINE( 219)			Bool _hx_tmp18;
HXDLIN( 219)			if ((t11 > (int)0)) {
HXLINE( 219)				_hx_tmp18 = (t11 < (int)1);
            			}
            			else {
HXLINE( 219)				_hx_tmp18 = false;
            			}
HXDLIN( 219)			if (_hx_tmp18) {
HXLINE( 221)				iy1 = this->_hx___calculateBezierCubicPoint(t11,this->_hx___positionX,controlY1,controlY2,anchorY);
            			}
HXLINE( 225)			Bool _hx_tmp19;
HXDLIN( 225)			if ((t21 > (int)0)) {
HXLINE( 225)				_hx_tmp19 = (t21 < (int)1);
            			}
            			else {
HXLINE( 225)				_hx_tmp19 = false;
            			}
HXDLIN( 225)			if (_hx_tmp19) {
HXLINE( 227)				iy2 = this->_hx___calculateBezierCubicPoint(t21,this->_hx___positionX,controlY1,controlY2,anchorY);
            			}
            		}
HXLINE( 233)		Float _hx_tmp20 = (ix1 - this->_hx___strokePadding);
HXDLIN( 233)		Float _hx_tmp21 = (iy1 - this->_hx___strokePadding);
HXDLIN( 233)		this->_hx___inflateBounds(_hx_tmp20,_hx_tmp21);
HXLINE( 234)		Float _hx_tmp22 = (ix1 + this->_hx___strokePadding);
HXDLIN( 234)		Float _hx_tmp23 = (iy1 + this->_hx___strokePadding);
HXDLIN( 234)		this->_hx___inflateBounds(_hx_tmp22,_hx_tmp23);
HXLINE( 235)		Float _hx_tmp24 = (ix2 - this->_hx___strokePadding);
HXDLIN( 235)		Float _hx_tmp25 = (iy2 - this->_hx___strokePadding);
HXDLIN( 235)		this->_hx___inflateBounds(_hx_tmp24,_hx_tmp25);
HXLINE( 236)		Float _hx_tmp26 = (ix2 + this->_hx___strokePadding);
HXDLIN( 236)		Float _hx_tmp27 = (iy2 + this->_hx___strokePadding);
HXDLIN( 236)		this->_hx___inflateBounds(_hx_tmp26,_hx_tmp27);
HXLINE( 238)		this->_hx___positionX = anchorX;
HXLINE( 239)		this->_hx___positionY = anchorY;
HXLINE( 241)		this->_hx___commands->cubicCurveTo(controlX1,controlY1,controlX2,controlY2,anchorX,anchorY);
HXLINE( 243)		this->_hx___hardware = false;
HXLINE( 244)		this->set___dirty(true);
            	}


HX_DEFINE_DYNAMIC_FUNC6(Graphics_obj,cubicCurveTo,(void))

void Graphics_obj::curveTo(Float controlX,Float controlY,Float anchorX,Float anchorY){
            	HX_STACK_FRAME("openfl.display.Graphics","curveTo",0x89f305d1,"openfl.display.Graphics.curveTo","openfl/display/Graphics.hx",249,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(controlX,"controlX")
            	HX_STACK_ARG(controlY,"controlY")
            	HX_STACK_ARG(anchorX,"anchorX")
            	HX_STACK_ARG(anchorY,"anchorY")
HXLINE( 251)		Float _hx_tmp = (this->_hx___positionX - this->_hx___strokePadding);
HXDLIN( 251)		Float _hx_tmp1 = (this->_hx___positionY - this->_hx___strokePadding);
HXDLIN( 251)		this->_hx___inflateBounds(_hx_tmp,_hx_tmp1);
HXLINE( 252)		Float _hx_tmp2 = (this->_hx___positionX + this->_hx___strokePadding);
HXDLIN( 252)		Float _hx_tmp3 = (this->_hx___positionY + this->_hx___strokePadding);
HXDLIN( 252)		this->_hx___inflateBounds(_hx_tmp2,_hx_tmp3);
HXLINE( 254)		HX_VAR( Float,ix);
HXDLIN( 254)		HX_VAR( Float,iy);
HXLINE( 256)		Bool _hx_tmp4;
HXDLIN( 256)		Bool _hx_tmp5;
HXDLIN( 256)		if ((controlX < anchorX)) {
HXLINE( 256)			_hx_tmp5 = (controlX > this->_hx___positionX);
            		}
            		else {
HXLINE( 256)			_hx_tmp5 = false;
            		}
HXDLIN( 256)		if (!(_hx_tmp5)) {
HXLINE( 256)			if ((controlX > anchorX)) {
HXLINE( 256)				_hx_tmp4 = (controlX < this->_hx___positionX);
            			}
            			else {
HXLINE( 256)				_hx_tmp4 = false;
            			}
            		}
            		else {
HXLINE( 256)			_hx_tmp4 = true;
            		}
HXDLIN( 256)		if (_hx_tmp4) {
HXLINE( 258)			ix = anchorX;
            		}
            		else {
HXLINE( 262)			Float _hx_tmp6 = (this->_hx___positionX - controlX);
HXDLIN( 262)			Float _hx_tmp7 = (this->_hx___positionX - ((int)2 * controlX));
HXLINE( 263)			ix = this->_hx___calculateBezierQuadPoint(((Float)_hx_tmp6 / (Float)(_hx_tmp7 + anchorX)),this->_hx___positionX,controlX,anchorX);
            		}
HXLINE( 267)		Bool _hx_tmp8;
HXDLIN( 267)		Bool _hx_tmp9;
HXDLIN( 267)		if ((controlY < anchorY)) {
HXLINE( 267)			_hx_tmp9 = (controlY > this->_hx___positionY);
            		}
            		else {
HXLINE( 267)			_hx_tmp9 = false;
            		}
HXDLIN( 267)		if (!(_hx_tmp9)) {
HXLINE( 267)			if ((controlY > anchorY)) {
HXLINE( 267)				_hx_tmp8 = (controlY < this->_hx___positionY);
            			}
            			else {
HXLINE( 267)				_hx_tmp8 = false;
            			}
            		}
            		else {
HXLINE( 267)			_hx_tmp8 = true;
            		}
HXDLIN( 267)		if (_hx_tmp8) {
HXLINE( 269)			iy = anchorY;
            		}
            		else {
HXLINE( 273)			Float _hx_tmp10 = (this->_hx___positionY - controlY);
HXDLIN( 273)			Float _hx_tmp11 = (this->_hx___positionY - ((int)2 * controlY));
HXLINE( 274)			iy = this->_hx___calculateBezierQuadPoint(((Float)_hx_tmp10 / (Float)(_hx_tmp11 + anchorY)),this->_hx___positionY,controlY,anchorY);
            		}
HXLINE( 278)		Float _hx_tmp12 = (ix - this->_hx___strokePadding);
HXDLIN( 278)		Float _hx_tmp13 = (iy - this->_hx___strokePadding);
HXDLIN( 278)		this->_hx___inflateBounds(_hx_tmp12,_hx_tmp13);
HXLINE( 279)		Float _hx_tmp14 = (ix + this->_hx___strokePadding);
HXDLIN( 279)		Float _hx_tmp15 = (iy + this->_hx___strokePadding);
HXDLIN( 279)		this->_hx___inflateBounds(_hx_tmp14,_hx_tmp15);
HXLINE( 281)		this->_hx___positionX = anchorX;
HXLINE( 282)		this->_hx___positionY = anchorY;
HXLINE( 284)		this->_hx___commands->curveTo(controlX,controlY,anchorX,anchorY);
HXLINE( 286)		this->_hx___hardware = false;
HXLINE( 287)		this->set___dirty(true);
            	}


HX_DEFINE_DYNAMIC_FUNC4(Graphics_obj,curveTo,(void))

void Graphics_obj::drawCircle(Float x,Float y,Float radius){
            	HX_STACK_FRAME("openfl.display.Graphics","drawCircle",0xee64ddcd,"openfl.display.Graphics.drawCircle","openfl/display/Graphics.hx",292,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
            	HX_STACK_ARG(radius,"radius")
HXLINE( 294)		if ((radius <= (int)0)) {
HXLINE( 294)			return;
            		}
HXLINE( 296)		Float _hx_tmp = ((x - radius) - this->_hx___strokePadding);
HXDLIN( 296)		Float _hx_tmp1 = ((y - radius) - this->_hx___strokePadding);
HXDLIN( 296)		this->_hx___inflateBounds(_hx_tmp,_hx_tmp1);
HXLINE( 297)		Float _hx_tmp2 = ((x + radius) + this->_hx___strokePadding);
HXDLIN( 297)		Float _hx_tmp3 = ((y + radius) + this->_hx___strokePadding);
HXDLIN( 297)		this->_hx___inflateBounds(_hx_tmp2,_hx_tmp3);
HXLINE( 299)		this->_hx___commands->drawCircle(x,y,radius);
HXLINE( 301)		this->_hx___hardware = false;
HXLINE( 302)		this->set___dirty(true);
            	}


HX_DEFINE_DYNAMIC_FUNC3(Graphics_obj,drawCircle,(void))

void Graphics_obj::drawEllipse(Float x,Float y,Float width,Float height){
            	HX_STACK_FRAME("openfl.display.Graphics","drawEllipse",0xbfad1a81,"openfl.display.Graphics.drawEllipse","openfl/display/Graphics.hx",307,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
            	HX_STACK_ARG(width,"width")
            	HX_STACK_ARG(height,"height")
HXLINE( 309)		Bool _hx_tmp;
HXDLIN( 309)		if (!((width <= (int)0))) {
HXLINE( 309)			_hx_tmp = (height <= (int)0);
            		}
            		else {
HXLINE( 309)			_hx_tmp = true;
            		}
HXDLIN( 309)		if (_hx_tmp) {
HXLINE( 309)			return;
            		}
HXLINE( 311)		Float _hx_tmp1 = (x - this->_hx___strokePadding);
HXDLIN( 311)		Float _hx_tmp2 = (y - this->_hx___strokePadding);
HXDLIN( 311)		this->_hx___inflateBounds(_hx_tmp1,_hx_tmp2);
HXLINE( 312)		Float _hx_tmp3 = ((x + width) + this->_hx___strokePadding);
HXDLIN( 312)		Float _hx_tmp4 = ((y + height) + this->_hx___strokePadding);
HXDLIN( 312)		this->_hx___inflateBounds(_hx_tmp3,_hx_tmp4);
HXLINE( 314)		this->_hx___commands->drawEllipse(x,y,width,height);
HXLINE( 316)		this->_hx___hardware = false;
HXLINE( 317)		this->set___dirty(true);
            	}


HX_DEFINE_DYNAMIC_FUNC4(Graphics_obj,drawEllipse,(void))

void Graphics_obj::drawGraphicsData(::Array< ::Dynamic> graphicsData){
            	HX_STACK_FRAME("openfl.display.Graphics","drawGraphicsData",0x60ea9412,"openfl.display.Graphics.drawGraphicsData","openfl/display/Graphics.hx",322,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(graphicsData,"graphicsData")
HXLINE( 324)		HX_VAR(  ::openfl::display::GraphicsSolidFill,fill);
HXLINE( 325)		HX_VAR(  ::openfl::display::GraphicsBitmapFill,bitmapFill);
HXLINE( 326)		HX_VAR(  ::openfl::display::GraphicsGradientFill,gradientFill);
HXLINE( 327)		HX_VAR(  ::openfl::display::GraphicsStroke,stroke);
HXLINE( 328)		HX_VAR(  ::openfl::display::GraphicsPath,path);
HXLINE( 330)		{
HXLINE( 330)			HX_VARI( Int,_g) = (int)0;
HXDLIN( 330)			while((_g < graphicsData->length)){
HXLINE( 330)				HX_VARI( ::Dynamic,graphics) = graphicsData->__get(_g);
HXDLIN( 330)				++_g;
HXLINE( 332)				Bool _hx_tmp = ::Std_obj::is(graphics,hx::ClassOf< ::openfl::display::GraphicsSolidFill >());
HXDLIN( 332)				if (_hx_tmp) {
HXLINE( 334)					fill = ( ( ::openfl::display::GraphicsSolidFill)(graphics) );
HXLINE( 335)					this->beginFill(fill->color,fill->alpha);
            				}
            				else {
HXLINE( 337)					Bool _hx_tmp1 = ::Std_obj::is(graphics,hx::ClassOf< ::openfl::display::GraphicsBitmapFill >());
HXDLIN( 337)					if (_hx_tmp1) {
HXLINE( 339)						bitmapFill = ( ( ::openfl::display::GraphicsBitmapFill)(graphics) );
HXLINE( 340)						this->beginBitmapFill(bitmapFill->bitmapData,bitmapFill->matrix,bitmapFill->repeat,bitmapFill->smooth);
            					}
            					else {
HXLINE( 342)						Bool _hx_tmp2 = ::Std_obj::is(graphics,hx::ClassOf< ::openfl::display::GraphicsGradientFill >());
HXDLIN( 342)						if (_hx_tmp2) {
HXLINE( 344)							gradientFill = ( ( ::openfl::display::GraphicsGradientFill)(graphics) );
HXLINE( 345)							this->beginGradientFill(gradientFill->type,gradientFill->colors,gradientFill->alphas,gradientFill->ratios,gradientFill->matrix,gradientFill->spreadMethod,gradientFill->interpolationMethod,gradientFill->focalPointRatio);
            						}
            						else {
HXLINE( 347)							Bool _hx_tmp3 = ::Std_obj::is(graphics,hx::ClassOf< ::openfl::display::GraphicsStroke >());
HXDLIN( 347)							if (_hx_tmp3) {
HXLINE( 349)								stroke = ( ( ::openfl::display::GraphicsStroke)(graphics) );
HXLINE( 351)								Bool _hx_tmp4 = ::Std_obj::is(stroke->fill,hx::ClassOf< ::openfl::display::GraphicsSolidFill >());
HXDLIN( 351)								if (_hx_tmp4) {
HXLINE( 353)									fill = ( ( ::openfl::display::GraphicsSolidFill)(stroke->fill) );
HXLINE( 354)									this->lineStyle(stroke->thickness,fill->color,fill->alpha,stroke->pixelHinting,stroke->scaleMode,stroke->caps,stroke->joints,stroke->miterLimit);
            								}
            								else {
HXLINE( 358)									this->lineStyle(stroke->thickness,(int)0,(int)1,stroke->pixelHinting,stroke->scaleMode,stroke->caps,stroke->joints,stroke->miterLimit);
HXLINE( 360)									Bool _hx_tmp5 = ::Std_obj::is(stroke->fill,hx::ClassOf< ::openfl::display::GraphicsBitmapFill >());
HXDLIN( 360)									if (_hx_tmp5) {
HXLINE( 362)										bitmapFill = ( ( ::openfl::display::GraphicsBitmapFill)(stroke->fill) );
HXLINE( 363)										this->lineBitmapStyle(bitmapFill->bitmapData,bitmapFill->matrix,bitmapFill->repeat,bitmapFill->smooth);
            									}
            									else {
HXLINE( 365)										Bool _hx_tmp6 = ::Std_obj::is(stroke->fill,hx::ClassOf< ::openfl::display::GraphicsGradientFill >());
HXDLIN( 365)										if (_hx_tmp6) {
HXLINE( 367)											gradientFill = ( ( ::openfl::display::GraphicsGradientFill)(stroke->fill) );
HXLINE( 368)											this->lineGradientStyle(gradientFill->type,gradientFill->colors,gradientFill->alphas,gradientFill->ratios,gradientFill->matrix,gradientFill->spreadMethod,gradientFill->interpolationMethod,gradientFill->focalPointRatio);
            										}
            									}
            								}
            							}
            							else {
HXLINE( 374)								Bool _hx_tmp7 = ::Std_obj::is(graphics,hx::ClassOf< ::openfl::display::GraphicsPath >());
HXDLIN( 374)								if (_hx_tmp7) {
HXLINE( 376)									path = ( ( ::openfl::display::GraphicsPath)(graphics) );
HXLINE( 377)									this->drawPath(path->commands,path->data,path->winding);
            								}
            								else {
HXLINE( 379)									Bool _hx_tmp8 = ::Std_obj::is(graphics,hx::ClassOf< ::openfl::display::GraphicsEndFill >());
HXDLIN( 379)									if (_hx_tmp8) {
HXLINE( 381)										this->endFill();
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Graphics_obj,drawGraphicsData,(void))

void Graphics_obj::drawPath(::Array< Int > commands,::Array< Float > data,::String __o_winding){
::String winding = __o_winding.Default(HX_HCSTRING("evenOdd","\xb5","\xc6","\x7e","\x06"));
            	HX_STACK_FRAME("openfl.display.Graphics","drawPath",0xa0a1f822,"openfl.display.Graphics.drawPath","openfl/display/Graphics.hx",390,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(commands,"commands")
            	HX_STACK_ARG(data,"data")
            	HX_STACK_ARG(winding,"winding")
HXLINE( 392)		HX_VARI( Int,dataIndex) = (int)0;
HXLINE( 394)		{
HXLINE( 394)			HX_VARI( Int,_g) = (int)0;
HXDLIN( 394)			while((_g < commands->length)){
HXLINE( 394)				HX_VARI(  ::Dynamic,command) = commands->__get(_g);
HXDLIN( 394)				++_g;
HXLINE( 396)				Bool _hx_tmp = hx::IsNull( command );
HXDLIN( 396)				if (!(_hx_tmp)) {
HXLINE( 396)					 ::Dynamic _hx_switch_0 = command;
            					if (  (_hx_switch_0==(int)1) ){
HXLINE( 400)						this->moveTo(data->__get(dataIndex),data->__get((dataIndex + (int)1)));
HXLINE( 401)						hx::AddEq(dataIndex,(int)2);
HXLINE( 398)						goto _hx_goto_3;
            					}
            					if (  (_hx_switch_0==(int)2) ){
HXLINE( 405)						this->lineTo(data->__get(dataIndex),data->__get((dataIndex + (int)1)));
HXLINE( 406)						hx::AddEq(dataIndex,(int)2);
HXLINE( 403)						goto _hx_goto_3;
            					}
            					if (  (_hx_switch_0==(int)3) ){
HXLINE( 420)						this->curveTo(data->__get(dataIndex),data->__get((dataIndex + (int)1)),data->__get((dataIndex + (int)2)),data->__get((dataIndex + (int)3)));
HXLINE( 421)						hx::AddEq(dataIndex,(int)4);
HXLINE( 418)						goto _hx_goto_3;
            					}
            					if (  (_hx_switch_0==(int)4) ){
HXLINE( 410)						this->moveTo(data->__get((dataIndex + (int)2)),data->__get((dataIndex + (int)3)));
HXDLIN( 410)						goto _hx_goto_2;
HXLINE( 408)						goto _hx_goto_3;
            					}
            					if (  (_hx_switch_0==(int)5) ){
HXLINE( 415)						this->lineTo(data->__get((dataIndex + (int)2)),data->__get((dataIndex + (int)3)));
HXDLIN( 415)						goto _hx_goto_2;
HXLINE( 413)						goto _hx_goto_3;
            					}
            					if (  (_hx_switch_0==(int)6) ){
HXLINE( 425)						this->cubicCurveTo(data->__get(dataIndex),data->__get((dataIndex + (int)1)),data->__get((dataIndex + (int)2)),data->__get((dataIndex + (int)3)),data->__get((dataIndex + (int)4)),data->__get((dataIndex + (int)5)));
HXLINE( 426)						hx::AddEq(dataIndex,(int)6);
HXLINE( 423)						goto _hx_goto_3;
            					}
            					/* default */{
            					}
            					_hx_goto_3:;
            				}
            			}
            			_hx_goto_2:;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Graphics_obj,drawPath,(void))

void Graphics_obj::drawRect(Float x,Float y,Float width,Float height){
            	HX_STACK_FRAME("openfl.display.Graphics","drawRect",0xa1f75fa1,"openfl.display.Graphics.drawRect","openfl/display/Graphics.hx",437,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
            	HX_STACK_ARG(width,"width")
            	HX_STACK_ARG(height,"height")
HXLINE( 439)		Bool _hx_tmp;
HXDLIN( 439)		if (!((width <= (int)0))) {
HXLINE( 439)			_hx_tmp = (height <= (int)0);
            		}
            		else {
HXLINE( 439)			_hx_tmp = true;
            		}
HXDLIN( 439)		if (_hx_tmp) {
HXLINE( 439)			return;
            		}
HXLINE( 441)		Float _hx_tmp1 = (x - this->_hx___strokePadding);
HXDLIN( 441)		Float _hx_tmp2 = (y - this->_hx___strokePadding);
HXDLIN( 441)		this->_hx___inflateBounds(_hx_tmp1,_hx_tmp2);
HXLINE( 442)		Float _hx_tmp3 = ((x + width) + this->_hx___strokePadding);
HXDLIN( 442)		Float _hx_tmp4 = ((y + height) + this->_hx___strokePadding);
HXDLIN( 442)		this->_hx___inflateBounds(_hx_tmp3,_hx_tmp4);
HXLINE( 444)		this->_hx___commands->drawRect(x,y,width,height);
HXLINE( 446)		this->set___dirty(true);
            	}


HX_DEFINE_DYNAMIC_FUNC4(Graphics_obj,drawRect,(void))

void Graphics_obj::drawRoundRect(Float x,Float y,Float width,Float height,Float ellipseWidth, ::Dynamic ellipseHeight){
            	HX_STACK_FRAME("openfl.display.Graphics","drawRoundRect",0xb24e78f5,"openfl.display.Graphics.drawRoundRect","openfl/display/Graphics.hx",451,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
            	HX_STACK_ARG(width,"width")
            	HX_STACK_ARG(height,"height")
            	HX_STACK_ARG(ellipseWidth,"ellipseWidth")
            	HX_STACK_ARG(ellipseHeight,"ellipseHeight")
HXLINE( 453)		Bool _hx_tmp;
HXDLIN( 453)		if (!((width <= (int)0))) {
HXLINE( 453)			_hx_tmp = (height <= (int)0);
            		}
            		else {
HXLINE( 453)			_hx_tmp = true;
            		}
HXDLIN( 453)		if (_hx_tmp) {
HXLINE( 453)			return;
            		}
HXLINE( 455)		Float _hx_tmp1 = (x - this->_hx___strokePadding);
HXDLIN( 455)		Float _hx_tmp2 = (y - this->_hx___strokePadding);
HXDLIN( 455)		this->_hx___inflateBounds(_hx_tmp1,_hx_tmp2);
HXLINE( 456)		Float _hx_tmp3 = ((x + width) + this->_hx___strokePadding);
HXDLIN( 456)		Float _hx_tmp4 = ((y + height) + this->_hx___strokePadding);
HXDLIN( 456)		this->_hx___inflateBounds(_hx_tmp3,_hx_tmp4);
HXLINE( 458)		this->_hx___commands->drawRoundRect(x,y,width,height,ellipseWidth,ellipseHeight);
HXLINE( 460)		this->_hx___hardware = false;
HXLINE( 461)		this->set___dirty(true);
            	}


HX_DEFINE_DYNAMIC_FUNC6(Graphics_obj,drawRoundRect,(void))

void Graphics_obj::drawRoundRectComplex(Float x,Float y,Float width,Float height,Float topLeftRadius,Float topRightRadius,Float bottomLeftRadius,Float bottomRightRadius){
            	HX_STACK_FRAME("openfl.display.Graphics","drawRoundRectComplex",0x06fa4dbb,"openfl.display.Graphics.drawRoundRectComplex","openfl/display/Graphics.hx",468,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
            	HX_STACK_ARG(width,"width")
            	HX_STACK_ARG(height,"height")
            	HX_STACK_ARG(topLeftRadius,"topLeftRadius")
            	HX_STACK_ARG(topRightRadius,"topRightRadius")
            	HX_STACK_ARG(bottomLeftRadius,"bottomLeftRadius")
            	HX_STACK_ARG(bottomRightRadius,"bottomRightRadius")
HXLINE( 468)		::openfl::Lib_obj::notImplemented(HX_("Graphics.drawRoundRectComplex",45,c0,68,95));
            	}


HX_DEFINE_DYNAMIC_FUNC8(Graphics_obj,drawRoundRectComplex,(void))

void Graphics_obj::drawTiles( ::openfl::display::Tilesheet sheet,::Array< Float > tileData,hx::Null< Bool >  __o_smooth,hx::Null< Int >  __o_flags, ::openfl::display::Shader shader,hx::Null< Int >  __o_count){
Bool smooth = __o_smooth.Default(false);
Int flags = __o_flags.Default(0);
Int count = __o_count.Default(-1);
            	HX_STACK_FRAME("openfl.display.Graphics","drawTiles",0x3ff51868,"openfl.display.Graphics.drawTiles","openfl/display/Graphics.hx",473,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(sheet,"sheet")
            	HX_STACK_ARG(tileData,"tileData")
            	HX_STACK_ARG(smooth,"smooth")
            	HX_STACK_ARG(flags,"flags")
            	HX_STACK_ARG(shader,"shader")
            	HX_STACK_ARG(count,"count")
HXLINE( 475)		HX_VARI( Bool,useScale) = (((int)flags & (int)(int)1) > (int)0);
HXLINE( 476)		HX_VARI( Bool,useRotation) = (((int)flags & (int)(int)2) > (int)0);
HXLINE( 477)		HX_VARI( Bool,useRGB) = (((int)flags & (int)(int)4) > (int)0);
HXLINE( 478)		HX_VARI( Bool,useAlpha) = (((int)flags & (int)(int)8) > (int)0);
HXLINE( 479)		HX_VARI( Bool,useTransform) = (((int)flags & (int)(int)16) > (int)0);
HXLINE( 480)		HX_VARI( Bool,useColorTransform) = (((int)flags & (int)(int)128) > (int)0);
HXLINE( 481)		HX_VARI( Bool,useRect) = (((int)flags & (int)(int)32) > (int)0);
HXLINE( 482)		HX_VARI( Bool,useOrigin) = (((int)flags & (int)(int)64) > (int)0);
HXLINE( 484)		HX_VARI(  ::openfl::geom::Rectangle,rect) = ::openfl::geom::Rectangle_obj::_hx___temp;
HXLINE( 485)		HX_VARI(  ::openfl::geom::Matrix,matrix) = ::openfl::geom::Matrix_obj::_hx___temp;
HXLINE( 487)		HX_VARI( Int,numValues) = (int)3;
HXLINE( 488)		HX_VARI( Int,totalCount) = count;
HXLINE( 490)		if ((count < (int)0)) {
HXLINE( 492)			totalCount = tileData->length;
            		}
HXLINE( 496)		Bool _hx_tmp;
HXDLIN( 496)		Bool _hx_tmp1;
HXDLIN( 496)		Bool _hx_tmp2;
HXDLIN( 496)		Bool _hx_tmp3;
HXDLIN( 496)		Bool _hx_tmp4;
HXDLIN( 496)		if (!(useTransform)) {
HXLINE( 496)			_hx_tmp4 = useScale;
            		}
            		else {
HXLINE( 496)			_hx_tmp4 = true;
            		}
HXDLIN( 496)		if (!(_hx_tmp4)) {
HXLINE( 496)			_hx_tmp3 = useRotation;
            		}
            		else {
HXLINE( 496)			_hx_tmp3 = true;
            		}
HXDLIN( 496)		if (!(_hx_tmp3)) {
HXLINE( 496)			_hx_tmp2 = useRGB;
            		}
            		else {
HXLINE( 496)			_hx_tmp2 = true;
            		}
HXDLIN( 496)		if (!(_hx_tmp2)) {
HXLINE( 496)			_hx_tmp1 = useAlpha;
            		}
            		else {
HXLINE( 496)			_hx_tmp1 = true;
            		}
HXDLIN( 496)		if (!(_hx_tmp1)) {
HXLINE( 496)			_hx_tmp = useColorTransform;
            		}
            		else {
HXLINE( 496)			_hx_tmp = true;
            		}
HXDLIN( 496)		if (_hx_tmp) {
HXLINE( 498)			HX_VARI( Int,scaleIndex) = (int)0;
HXLINE( 499)			HX_VARI( Int,rotationIndex) = (int)0;
HXLINE( 500)			HX_VARI( Int,transformIndex) = (int)0;
HXLINE( 502)			if (useRect) {
HXLINE( 502)				if (useOrigin) {
HXLINE( 502)					numValues = (int)8;
            				}
            				else {
HXLINE( 502)					numValues = (int)6;
            				}
            			}
HXLINE( 503)			if (useScale) {
HXLINE( 503)				scaleIndex = numValues;
HXDLIN( 503)				++numValues;
            			}
HXLINE( 504)			if (useRotation) {
HXLINE( 504)				rotationIndex = numValues;
HXDLIN( 504)				++numValues;
            			}
HXLINE( 505)			if (useTransform) {
HXLINE( 505)				transformIndex = numValues;
HXDLIN( 505)				hx::AddEq(numValues,(int)4);
            			}
HXLINE( 506)			if (useRGB) {
HXLINE( 506)				hx::AddEq(numValues,(int)3);
            			}
HXLINE( 507)			if (useAlpha) {
HXLINE( 507)				++numValues;
            			}
HXLINE( 508)			if (useColorTransform) {
HXLINE( 508)				hx::AddEq(numValues,(int)4);
            			}
HXLINE( 510)			::Std_obj::_hx_int(((Float)totalCount / (Float)numValues));
HXLINE( 511)			HX_VARI( Int,index) = (int)0;
HXLINE( 512)			HX_VARI( Int,cacheID) = (int)-1;
HXLINE( 514)			HX_VAR( Float,x);
HXDLIN( 514)			HX_VAR( Float,y);
HXDLIN( 514)			HX_VAR( Int,id);
HXDLIN( 514)			HX_VAR( Float,scale);
HXDLIN( 514)			HX_VAR( Float,rotation);
HXDLIN( 514)			HX_VAR( Float,tileWidth);
HXDLIN( 514)			HX_VAR( Float,tileHeight);
HXDLIN( 514)			HX_VAR( Float,originX);
HXDLIN( 514)			HX_VAR( Float,originY);
HXLINE( 515)			HX_VARI(  ::openfl::geom::Rectangle,tile) = null();
HXLINE( 516)			HX_VARI(  ::openfl::geom::Point,tilePoint) = null();
HXLINE( 518)			while((index < totalCount)){
HXLINE( 520)				x = tileData->__get(index);
HXLINE( 521)				y = tileData->__get((index + (int)1));
HXLINE( 522)				if (!(useRect)) {
HXLINE( 522)					Float _hx_tmp5 = tileData->__get((index + (int)2));
HXDLIN( 522)					id = ::Std_obj::_hx_int(_hx_tmp5);
            				}
            				else {
HXLINE( 522)					id = (int)-1;
            				}
HXLINE( 523)				scale = ((Float)1.0);
HXLINE( 524)				rotation = ((Float)0.0);
HXLINE( 526)				if (useScale) {
HXLINE( 528)					scale = tileData->__get((index + scaleIndex));
            				}
HXLINE( 532)				if (useRotation) {
HXLINE( 534)					rotation = tileData->__get((index + rotationIndex));
            				}
HXLINE( 538)				if ((id < (int)0)) {
HXLINE( 540)					tile = null();
            				}
            				else {
HXLINE( 544)					Bool _hx_tmp6;
HXDLIN( 544)					if (!(useRect)) {
HXLINE( 544)						_hx_tmp6 = (cacheID != id);
            					}
            					else {
HXLINE( 544)						_hx_tmp6 = false;
            					}
HXDLIN( 544)					if (_hx_tmp6) {
HXLINE( 546)						cacheID = id;
HXLINE( 547)						tile = sheet->_hx___tileRects->__get(id).StaticCast<  ::openfl::geom::Rectangle >();
HXLINE( 548)						tilePoint = sheet->_hx___centerPoints->__get(id).StaticCast<  ::openfl::geom::Point >();
            					}
            					else {
HXLINE( 550)						if (useRect) {
HXLINE( 552)							tile = sheet->_hx___rectTile;
HXLINE( 553)							Float _hx_tmp7 = tileData->__get((index + (int)2));
HXDLIN( 553)							Float _hx_tmp8 = tileData->__get((index + (int)3));
HXDLIN( 553)							Float _hx_tmp9 = tileData->__get((index + (int)4));
HXDLIN( 553)							Float _hx_tmp10 = tileData->__get((index + (int)5));
HXDLIN( 553)							tile->setTo(_hx_tmp7,_hx_tmp8,_hx_tmp9,_hx_tmp10);
HXLINE( 554)							tilePoint = sheet->_hx___point;
HXLINE( 556)							if (useOrigin) {
HXLINE( 558)								Float _hx_tmp11 = ((Float)tileData->__get((index + (int)6)) / (Float)tile->width);
HXDLIN( 558)								Float _hx_tmp12 = ((Float)tileData->__get((index + (int)7)) / (Float)tile->height);
HXDLIN( 558)								tilePoint->setTo(_hx_tmp11,_hx_tmp12);
            							}
            							else {
HXLINE( 562)								tilePoint->setTo((int)0,(int)0);
            							}
            						}
            					}
            				}
HXLINE( 570)				Bool _hx_tmp13 = hx::IsNotNull( tile );
HXDLIN( 570)				if (_hx_tmp13) {
HXLINE( 572)					if (useTransform) {
HXLINE( 574)						rect->setTo((int)0,(int)0,tile->width,tile->height);
HXLINE( 575)						Float _hx_tmp14 = tileData->__get((index + transformIndex));
HXDLIN( 575)						Float _hx_tmp15 = tileData->__get(((index + transformIndex) + (int)1));
HXDLIN( 575)						Float _hx_tmp16 = tileData->__get(((index + transformIndex) + (int)2));
HXDLIN( 575)						Float _hx_tmp17 = tileData->__get(((index + transformIndex) + (int)3));
HXDLIN( 575)						matrix->setTo(_hx_tmp14,_hx_tmp15,_hx_tmp16,_hx_tmp17,(int)0,(int)0);
HXLINE( 577)						originX = (tilePoint->x * scale);
HXLINE( 578)						originY = (tilePoint->y * scale);
HXLINE( 580)						Float _hx_tmp18 = (x - (((originX * matrix->a) + (originY * matrix->c)) + matrix->tx));
HXDLIN( 580)						Float _hx_tmp19 = (y - (((originX * matrix->b) + (originY * matrix->d)) + matrix->ty));
HXDLIN( 580)						matrix->translate(_hx_tmp18,_hx_tmp19);
HXLINE( 582)						rect->_hx___transform(rect,matrix);
HXLINE( 584)						this->_hx___inflateBounds(rect->x,rect->y);
HXLINE( 585)						Float _hx_tmp20 = rect->get_right();
HXDLIN( 585)						Float _hx_tmp21 = rect->get_bottom();
HXDLIN( 585)						this->_hx___inflateBounds(_hx_tmp20,_hx_tmp21);
            					}
            					else {
HXLINE( 589)						tileWidth = (tile->width * scale);
HXLINE( 590)						tileHeight = (tile->height * scale);
HXLINE( 592)						hx::SubEq(x,(tilePoint->x * tileWidth));
HXLINE( 593)						hx::SubEq(y,(tilePoint->y * tileHeight));
HXLINE( 595)						if ((rotation != (int)0)) {
HXLINE( 597)							rect->setTo((int)0,(int)0,tileWidth,tileHeight);
HXLINE( 599)							matrix->identity();
HXLINE( 600)							matrix->rotate(rotation);
HXLINE( 601)							matrix->translate(x,y);
HXLINE( 603)							rect->_hx___transform(rect,matrix);
HXLINE( 605)							this->_hx___inflateBounds(rect->x,rect->y);
HXLINE( 606)							Float _hx_tmp22 = rect->get_right();
HXDLIN( 606)							Float _hx_tmp23 = rect->get_bottom();
HXDLIN( 606)							this->_hx___inflateBounds(_hx_tmp22,_hx_tmp23);
            						}
            						else {
HXLINE( 610)							this->_hx___inflateBounds(x,y);
HXLINE( 611)							this->_hx___inflateBounds((x + tileWidth),(y + tileHeight));
            						}
            					}
            				}
HXLINE( 619)				hx::AddEq(index,numValues);
            			}
            		}
            		else {
HXLINE( 625)			HX_VAR_NAME( Float,x1,"x");
HXDLIN( 625)			HX_VAR_NAME( Float,y1,"y");
HXDLIN( 625)			HX_VAR_NAME( Int,id1,"id");
HXDLIN( 625)			HX_VAR_NAME(  ::openfl::geom::Rectangle,tile1,"tile");
HXDLIN( 625)			HX_VAR(  ::openfl::geom::Point,centerPoint);
HXDLIN( 625)			HX_VAR_NAME( Float,originX1,"originX");
HXDLIN( 625)			HX_VAR_NAME( Float,originY1,"originY");
HXLINE( 626)			HX_VARI_NAME(  ::openfl::geom::Rectangle,rect1,"rect") = ::openfl::geom::Rectangle_obj::_hx___temp;
HXLINE( 627)			HX_VARI_NAME( Int,index1,"index") = (int)0;
HXLINE( 629)			while((index1 < totalCount)){
HXLINE( 631)				Int _hx_tmp24 = index1++;
HXDLIN( 631)				x1 = tileData->__get(_hx_tmp24);
HXLINE( 632)				Int _hx_tmp25 = index1++;
HXDLIN( 632)				y1 = tileData->__get(_hx_tmp25);
HXLINE( 642)				if (!(useRect)) {
HXLINE( 642)					Int _hx_tmp26 = index1++;
HXDLIN( 642)					Float _hx_tmp27 = tileData->__get(_hx_tmp26);
HXDLIN( 642)					id1 = ::Std_obj::_hx_int(_hx_tmp27);
            				}
            				else {
HXLINE( 642)					id1 = (int)-1;
            				}
HXLINE( 645)				originX1 = ((Float)0.0);
HXLINE( 646)				originY1 = ((Float)0.0);
HXLINE( 648)				if (useRect) {
HXLINE( 650)					Int _hx_tmp28 = index1++;
HXDLIN( 650)					Float _hx_tmp29 = tileData->__get(_hx_tmp28);
HXDLIN( 650)					Int _hx_tmp30 = index1++;
HXDLIN( 650)					Float _hx_tmp31 = tileData->__get(_hx_tmp30);
HXDLIN( 650)					Int _hx_tmp32 = index1++;
HXDLIN( 650)					Float _hx_tmp33 = tileData->__get(_hx_tmp32);
HXDLIN( 650)					Int _hx_tmp34 = index1++;
HXDLIN( 650)					Float _hx_tmp35 = tileData->__get(_hx_tmp34);
HXDLIN( 650)					rect1->setTo(_hx_tmp29,_hx_tmp31,_hx_tmp33,_hx_tmp35);
HXLINE( 652)					if (useOrigin) {
HXLINE( 654)						Int _hx_tmp36 = index1++;
HXDLIN( 654)						originX1 = tileData->__get(_hx_tmp36);
HXLINE( 655)						Int _hx_tmp37 = index1++;
HXDLIN( 655)						originY1 = tileData->__get(_hx_tmp37);
            					}
HXLINE( 659)					this->_hx___inflateBounds((x1 - originX1),(y1 - originY1));
HXLINE( 660)					Float _hx_tmp38 = ((x1 - originX1) + rect1->width);
HXDLIN( 660)					Float _hx_tmp39 = ((y1 - originY1) + rect1->height);
HXDLIN( 660)					this->_hx___inflateBounds(_hx_tmp38,_hx_tmp39);
            				}
            				else {
HXLINE( 664)					tile1 = sheet->_hx___tileRects->__get(id1).StaticCast<  ::openfl::geom::Rectangle >();
HXLINE( 666)					Bool _hx_tmp40 = hx::IsNotNull( tile1 );
HXDLIN( 666)					if (_hx_tmp40) {
HXLINE( 668)						centerPoint = sheet->_hx___centerPoints->__get(id1).StaticCast<  ::openfl::geom::Point >();
HXLINE( 669)						originX1 = (centerPoint->x * tile1->width);
HXLINE( 670)						originY1 = (centerPoint->y * tile1->height);
HXLINE( 672)						this->_hx___inflateBounds((x1 - originX1),(y1 - originY1));
HXLINE( 673)						Float _hx_tmp41 = ((x1 - originX1) + tile1->width);
HXDLIN( 673)						Float _hx_tmp42 = ((y1 - originY1) + tile1->height);
HXDLIN( 673)						this->_hx___inflateBounds(_hx_tmp41,_hx_tmp42);
            					}
            				}
            			}
            		}
HXLINE( 682)		this->_hx___commands->drawTiles(sheet,tileData,smooth,flags,shader,count);
HXLINE( 684)		this->set___dirty(true);
HXLINE( 685)		this->_hx___visible = true;
            	}


HX_DEFINE_DYNAMIC_FUNC6(Graphics_obj,drawTiles,(void))

void Graphics_obj::drawTriangles(::Array< Float > vertices,::Array< Int > indices,::Array< Float > uvtData, ::Dynamic __o_culling){
 ::Dynamic culling = __o_culling.Default(1);
            	HX_STACK_FRAME("openfl.display.Graphics","drawTriangles",0xae0bf90e,"openfl.display.Graphics.drawTriangles","openfl/display/Graphics.hx",690,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(vertices,"vertices")
            	HX_STACK_ARG(indices,"indices")
            	HX_STACK_ARG(uvtData,"uvtData")
            	HX_STACK_ARG(culling,"culling")
HXLINE( 692)		Float _hx_tmp = ((Float)vertices->length / (Float)(int)2);
HXDLIN( 692)		HX_VARI( Int,vlen) = ::Std_obj::_hx_int(_hx_tmp);
HXLINE( 694)		Bool _hx_tmp1 = hx::IsNull( culling );
HXDLIN( 694)		if (_hx_tmp1) {
HXLINE( 696)			culling = (int)1;
            		}
HXLINE( 700)		Bool _hx_tmp2 = hx::IsNull( indices );
HXDLIN( 700)		if (_hx_tmp2) {
HXLINE( 702)			if ((hx::Mod(vlen,(int)3) != (int)0)) {
HXLINE( 704)				HX_STACK_DO_THROW( ::openfl::errors::ArgumentError_obj::__new(HX_("Not enough vertices to close a triangle.",fe,c6,58,0d)));
            			}
HXLINE( 708)			HX_VARI_NAME( ::Array< Int >,this1,"this") = ::Array_obj< Int >::__new();
HXDLIN( 708)			this1->__SetSizeExact(null());
HXDLIN( 708)			indices = this1;
HXLINE( 710)			{
HXLINE( 710)				HX_VARI( Int,_g1) = (int)0;
HXDLIN( 710)				while((_g1 < vlen)){
HXLINE( 710)					HX_VARI( Int,i) = _g1++;
HXLINE( 712)					indices->push(i);
            				}
            			}
            		}
HXLINE( 718)		this->_hx___inflateBounds((int)0,(int)0);
HXLINE( 720)		HX_VARI( Float,tmpx) = ::Math_obj::NEGATIVE_INFINITY;
HXLINE( 721)		HX_VARI( Float,tmpy) = ::Math_obj::NEGATIVE_INFINITY;
HXLINE( 722)		HX_VARI( Float,maxX) = ::Math_obj::NEGATIVE_INFINITY;
HXLINE( 723)		HX_VARI( Float,maxY) = ::Math_obj::NEGATIVE_INFINITY;
HXLINE( 725)		{
HXLINE( 725)			HX_VARI_NAME( Int,_g11,"_g1") = (int)0;
HXDLIN( 725)			while((_g11 < vlen)){
HXLINE( 725)				HX_VARI_NAME( Int,i1,"i") = _g11++;
HXLINE( 727)				tmpx = vertices->__get((i1 * (int)2));
HXLINE( 728)				tmpy = vertices->__get(((i1 * (int)2) + (int)1));
HXLINE( 729)				Bool _hx_tmp3 = (maxX < tmpx);
HXDLIN( 729)				if (_hx_tmp3) {
HXLINE( 729)					maxX = tmpx;
            				}
HXLINE( 730)				Bool _hx_tmp4 = (maxY < tmpy);
HXDLIN( 730)				if (_hx_tmp4) {
HXLINE( 730)					maxY = tmpy;
            				}
            			}
            		}
HXLINE( 734)		this->_hx___inflateBounds(maxX,maxY);
HXLINE( 735)		this->_hx___commands->drawTriangles(vertices,indices,uvtData,culling);
HXLINE( 737)		this->set___dirty(true);
HXLINE( 738)		this->_hx___visible = true;
            	}


HX_DEFINE_DYNAMIC_FUNC4(Graphics_obj,drawTriangles,(void))

void Graphics_obj::endFill(){
            	HX_STACK_FRAME("openfl.display.Graphics","endFill",0xe14b2dc5,"openfl.display.Graphics.endFill","openfl/display/Graphics.hx",745,0x8d299ce7)
            	HX_STACK_THIS(this)
HXLINE( 745)		this->_hx___commands->endFill();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Graphics_obj,endFill,(void))

void Graphics_obj::lineBitmapStyle( ::openfl::display::BitmapData bitmap, ::openfl::geom::Matrix matrix,hx::Null< Bool >  __o_repeat,hx::Null< Bool >  __o_smooth){
Bool repeat = __o_repeat.Default(true);
Bool smooth = __o_smooth.Default(false);
            	HX_STACK_FRAME("openfl.display.Graphics","lineBitmapStyle",0x0ce183f5,"openfl.display.Graphics.lineBitmapStyle","openfl/display/Graphics.hx",752,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(bitmap,"bitmap")
            	HX_STACK_ARG(matrix,"matrix")
            	HX_STACK_ARG(repeat,"repeat")
            	HX_STACK_ARG(smooth,"smooth")
HXLINE( 752)		 ::openfl::geom::Matrix _hx_tmp;
HXDLIN( 752)		Bool _hx_tmp1 = hx::IsNotNull( matrix );
HXDLIN( 752)		if (_hx_tmp1) {
HXLINE( 752)			_hx_tmp = matrix->clone();
            		}
            		else {
HXLINE( 752)			_hx_tmp = null();
            		}
HXDLIN( 752)		this->_hx___commands->lineBitmapStyle(bitmap,_hx_tmp,repeat,smooth);
            	}


HX_DEFINE_DYNAMIC_FUNC4(Graphics_obj,lineBitmapStyle,(void))

void Graphics_obj::lineGradientStyle( ::Dynamic type,::Array< Int > colors,::Array< Float > alphas,::Array< Int > ratios, ::openfl::geom::Matrix matrix, ::Dynamic __o_spreadMethod, ::Dynamic __o_interpolationMethod,hx::Null< Float >  __o_focalPointRatio){
 ::Dynamic spreadMethod = __o_spreadMethod.Default(0);
 ::Dynamic interpolationMethod = __o_interpolationMethod.Default(1);
Float focalPointRatio = __o_focalPointRatio.Default(0);
            	HX_STACK_FRAME("openfl.display.Graphics","lineGradientStyle",0x2de26914,"openfl.display.Graphics.lineGradientStyle","openfl/display/Graphics.hx",759,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(type,"type")
            	HX_STACK_ARG(colors,"colors")
            	HX_STACK_ARG(alphas,"alphas")
            	HX_STACK_ARG(ratios,"ratios")
            	HX_STACK_ARG(matrix,"matrix")
            	HX_STACK_ARG(spreadMethod,"spreadMethod")
            	HX_STACK_ARG(interpolationMethod,"interpolationMethod")
            	HX_STACK_ARG(focalPointRatio,"focalPointRatio")
HXLINE( 759)		this->_hx___commands->lineGradientStyle(type,colors,alphas,ratios,matrix,spreadMethod,interpolationMethod,focalPointRatio);
            	}


HX_DEFINE_DYNAMIC_FUNC8(Graphics_obj,lineGradientStyle,(void))

void Graphics_obj::lineStyle( ::Dynamic thickness,hx::Null< Int >  __o_color,hx::Null< Float >  __o_alpha,hx::Null< Bool >  __o_pixelHinting, ::Dynamic __o_scaleMode, ::Dynamic caps, ::Dynamic joints,hx::Null< Float >  __o_miterLimit){
Int color = __o_color.Default(0);
Float alpha = __o_alpha.Default(1);
Bool pixelHinting = __o_pixelHinting.Default(false);
 ::Dynamic scaleMode = __o_scaleMode.Default(2);
Float miterLimit = __o_miterLimit.Default(3);
            	HX_STACK_FRAME("openfl.display.Graphics","lineStyle",0x32cd8e24,"openfl.display.Graphics.lineStyle","openfl/display/Graphics.hx",764,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(thickness,"thickness")
            	HX_STACK_ARG(color,"color")
            	HX_STACK_ARG(alpha,"alpha")
            	HX_STACK_ARG(pixelHinting,"pixelHinting")
            	HX_STACK_ARG(scaleMode,"scaleMode")
            	HX_STACK_ARG(caps,"caps")
            	HX_STACK_ARG(joints,"joints")
            	HX_STACK_ARG(miterLimit,"miterLimit")
HXLINE( 766)		Bool _hx_tmp = hx::IsNotNull( thickness );
HXDLIN( 766)		if (_hx_tmp) {
HXLINE( 768)			if (hx::IsEq( joints,(int)1 )) {
HXLINE( 770)				Bool _hx_tmp1 = hx::IsGreater( thickness,this->_hx___strokePadding );
HXDLIN( 770)				if (_hx_tmp1) {
HXLINE( 770)					this->_hx___strokePadding = thickness;
            				}
            			}
            			else {
HXLINE( 774)				Bool _hx_tmp2 = (((Float)thickness / (Float)(int)2) > this->_hx___strokePadding);
HXDLIN( 774)				if (_hx_tmp2) {
HXLINE( 774)					this->_hx___strokePadding = ((Float)thickness / (Float)(int)2);
            				}
            			}
            		}
HXLINE( 780)		this->_hx___commands->lineStyle(thickness,color,alpha,pixelHinting,scaleMode,caps,joints,miterLimit);
HXLINE( 782)		Bool _hx_tmp3 = hx::IsNotNull( thickness );
HXDLIN( 782)		if (_hx_tmp3) {
HXLINE( 782)			this->_hx___visible = true;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC8(Graphics_obj,lineStyle,(void))

void Graphics_obj::lineTo(Float x,Float y){
            	HX_STACK_FRAME("openfl.display.Graphics","lineTo",0x25b7b6a8,"openfl.display.Graphics.lineTo","openfl/display/Graphics.hx",787,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
HXLINE( 791)		Float _hx_tmp = (this->_hx___positionX - this->_hx___strokePadding);
HXDLIN( 791)		Float _hx_tmp1 = (this->_hx___positionY - this->_hx___strokePadding);
HXDLIN( 791)		this->_hx___inflateBounds(_hx_tmp,_hx_tmp1);
HXLINE( 792)		Float _hx_tmp2 = (this->_hx___positionX + this->_hx___strokePadding);
HXDLIN( 792)		Float _hx_tmp3 = (this->_hx___positionY + this->_hx___strokePadding);
HXDLIN( 792)		this->_hx___inflateBounds(_hx_tmp2,_hx_tmp3);
HXLINE( 794)		this->_hx___positionX = x;
HXLINE( 795)		this->_hx___positionY = y;
HXLINE( 797)		Float _hx_tmp4 = (this->_hx___positionX - this->_hx___strokePadding);
HXDLIN( 797)		Float _hx_tmp5 = (this->_hx___positionY - this->_hx___strokePadding);
HXDLIN( 797)		this->_hx___inflateBounds(_hx_tmp4,_hx_tmp5);
HXLINE( 798)		Float _hx_tmp6 = (this->_hx___positionX + (this->_hx___strokePadding * (int)2));
HXDLIN( 798)		Float _hx_tmp7 = (this->_hx___positionY + this->_hx___strokePadding);
HXDLIN( 798)		this->_hx___inflateBounds(_hx_tmp6,_hx_tmp7);
HXLINE( 800)		this->_hx___commands->lineTo(x,y);
HXLINE( 802)		this->_hx___hardware = false;
HXLINE( 803)		this->set___dirty(true);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Graphics_obj,lineTo,(void))

void Graphics_obj::moveTo(Float x,Float y){
            	HX_STACK_FRAME("openfl.display.Graphics","moveTo",0x05c44305,"openfl.display.Graphics.moveTo","openfl/display/Graphics.hx",808,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
HXLINE( 810)		this->_hx___positionX = x;
HXLINE( 811)		this->_hx___positionY = y;
HXLINE( 813)		this->_hx___commands->moveTo(x,y);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Graphics_obj,moveTo,(void))

Float Graphics_obj::_hx___calculateBezierCubicPoint(Float t,Float p1,Float p2,Float p3,Float p4){
            	HX_STACK_FRAME("openfl.display.Graphics","__calculateBezierCubicPoint",0xb6679552,"openfl.display.Graphics.__calculateBezierCubicPoint","openfl/display/Graphics.hx",818,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(t,"t")
            	HX_STACK_ARG(p1,"p1")
            	HX_STACK_ARG(p2,"p2")
            	HX_STACK_ARG(p3,"p3")
            	HX_STACK_ARG(p4,"p4")
HXLINE( 820)		HX_VARI( Float,iT) = ((int)1 - t);
HXLINE( 821)		return ((((p1 * ((iT * iT) * iT)) + ((((int)3 * p2) * t) * (iT * iT))) + ((((int)3 * p3) * iT) * (t * t))) + (p4 * ((t * t) * t)));
            	}


HX_DEFINE_DYNAMIC_FUNC5(Graphics_obj,_hx___calculateBezierCubicPoint,return )

Float Graphics_obj::_hx___calculateBezierQuadPoint(Float t,Float p1,Float p2,Float p3){
            	HX_STACK_FRAME("openfl.display.Graphics","__calculateBezierQuadPoint",0x2414b8dd,"openfl.display.Graphics.__calculateBezierQuadPoint","openfl/display/Graphics.hx",826,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(t,"t")
            	HX_STACK_ARG(p1,"p1")
            	HX_STACK_ARG(p2,"p2")
            	HX_STACK_ARG(p3,"p3")
HXLINE( 828)		HX_VARI( Float,iT) = ((int)1 - t);
HXLINE( 829)		return ((((iT * iT) * p1) + ((((int)2 * iT) * t) * p2)) + ((t * t) * p3));
            	}


HX_DEFINE_DYNAMIC_FUNC4(Graphics_obj,_hx___calculateBezierQuadPoint,return )

void Graphics_obj::_hx___getBounds( ::openfl::geom::Rectangle rect, ::openfl::geom::Matrix matrix){
            	HX_STACK_FRAME("openfl.display.Graphics","__getBounds",0x7b7eedd2,"openfl.display.Graphics.__getBounds","openfl/display/Graphics.hx",834,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(rect,"rect")
            	HX_STACK_ARG(matrix,"matrix")
HXLINE( 836)		Bool _hx_tmp = hx::IsNull( this->_hx___bounds );
HXDLIN( 836)		if (_hx_tmp) {
HXLINE( 836)			return;
            		}
HXLINE( 838)		HX_VARI(  ::openfl::geom::Rectangle,bounds) = ::openfl::geom::Rectangle_obj::_hx___temp;
HXLINE( 839)		this->_hx___bounds->_hx___transform(bounds,matrix);
HXLINE( 840)		rect->_hx___expand(bounds->x,bounds->y,bounds->width,bounds->height);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Graphics_obj,_hx___getBounds,(void))

Bool Graphics_obj::_hx___hitTest(Float x,Float y,Bool shapeFlag, ::openfl::geom::Matrix matrix){
            	HX_STACK_FRAME("openfl.display.Graphics","__hitTest",0xcb8296ac,"openfl.display.Graphics.__hitTest","openfl/display/Graphics.hx",845,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
            	HX_STACK_ARG(shapeFlag,"shapeFlag")
            	HX_STACK_ARG(matrix,"matrix")
HXLINE( 847)		Bool _hx_tmp = hx::IsNull( this->_hx___bounds );
HXDLIN( 847)		if (_hx_tmp) {
HXLINE( 847)			return false;
            		}
HXLINE( 849)		HX_VARI( Float,norm) = ((matrix->a * matrix->d) - (matrix->b * matrix->c));
HXDLIN( 849)		HX_VAR( Float,px);
HXDLIN( 849)		if ((norm == (int)0)) {
HXLINE( 849)			px = -(matrix->tx);
            		}
            		else {
HXLINE( 849)			px = (((Float)((Float)1.0) / (Float)norm) * ((matrix->c * (matrix->ty - y)) + (matrix->d * (x - matrix->tx))));
            		}
HXLINE( 850)		HX_VARI_NAME( Float,norm1,"norm") = ((matrix->a * matrix->d) - (matrix->b * matrix->c));
HXDLIN( 850)		HX_VAR( Float,py);
HXDLIN( 850)		if ((norm1 == (int)0)) {
HXLINE( 850)			py = -(matrix->ty);
            		}
            		else {
HXLINE( 850)			py = (((Float)((Float)1.0) / (Float)norm1) * ((matrix->a * (y - matrix->ty)) + (matrix->b * (matrix->tx - x))));
            		}
HXLINE( 852)		Bool _hx_tmp1;
HXDLIN( 852)		Bool _hx_tmp2;
HXDLIN( 852)		if ((px > this->_hx___bounds->x)) {
HXLINE( 852)			_hx_tmp2 = (py > this->_hx___bounds->y);
            		}
            		else {
HXLINE( 852)			_hx_tmp2 = false;
            		}
HXDLIN( 852)		if (_hx_tmp2) {
HXLINE( 852)			_hx_tmp1 = this->_hx___bounds->contains(px,py);
            		}
            		else {
HXLINE( 852)			_hx_tmp1 = false;
            		}
HXDLIN( 852)		if (_hx_tmp1) {
HXLINE( 854)			if (shapeFlag) {
HXLINE( 859)				return ::openfl::_internal::renderer::cairo::CairoGraphics_obj::hitTest(hx::ObjectPtr<OBJ_>(this),px,py);
            			}
HXLINE( 864)			return true;
            		}
HXLINE( 868)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC4(Graphics_obj,_hx___hitTest,return )

void Graphics_obj::_hx___inflateBounds(Float x,Float y){
            	HX_STACK_FRAME("openfl.display.Graphics","__inflateBounds",0x7eaeb403,"openfl.display.Graphics.__inflateBounds","openfl/display/Graphics.hx",872,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
HXLINE( 874)		Bool _hx_tmp = hx::IsNull( this->_hx___bounds );
HXDLIN( 874)		if (_hx_tmp) {
HXLINE( 876)			this->_hx___bounds =  ::openfl::geom::Rectangle_obj::__new(x,y,(int)0,(int)0);
HXLINE( 877)			this->_hx___transformDirty = true;
HXLINE( 878)			return;
            		}
HXLINE( 882)		Bool _hx_tmp1 = (x < this->_hx___bounds->x);
HXDLIN( 882)		if (_hx_tmp1) {
HXLINE( 884)			hx::AddEq(this->_hx___bounds->width,(this->_hx___bounds->x - x));
HXLINE( 885)			this->_hx___bounds->x = x;
HXLINE( 886)			this->_hx___transformDirty = true;
            		}
HXLINE( 890)		Bool _hx_tmp2 = (y < this->_hx___bounds->y);
HXDLIN( 890)		if (_hx_tmp2) {
HXLINE( 892)			hx::AddEq(this->_hx___bounds->height,(this->_hx___bounds->y - y));
HXLINE( 893)			this->_hx___bounds->y = y;
HXLINE( 894)			this->_hx___transformDirty = true;
            		}
HXLINE( 898)		Bool _hx_tmp3 = (x > (this->_hx___bounds->x + this->_hx___bounds->width));
HXDLIN( 898)		if (_hx_tmp3) {
HXLINE( 900)			this->_hx___bounds->width = (x - this->_hx___bounds->x);
            		}
HXLINE( 904)		Bool _hx_tmp4 = (y > (this->_hx___bounds->y + this->_hx___bounds->height));
HXDLIN( 904)		if (_hx_tmp4) {
HXLINE( 906)			this->_hx___bounds->height = (y - this->_hx___bounds->y);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Graphics_obj,_hx___inflateBounds,(void))

Bool Graphics_obj::set___dirty(Bool value){
            	HX_STACK_FRAME("openfl.display.Graphics","set___dirty",0x3f74a55c,"openfl.display.Graphics.set___dirty","openfl/display/Graphics.hx",920,0x8d299ce7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE( 922)		Bool _hx_tmp;
HXDLIN( 922)		if (value) {
HXLINE( 922)			_hx_tmp = hx::IsNotNull( this->_hx___owner );
            		}
            		else {
HXLINE( 922)			_hx_tmp = false;
            		}
HXDLIN( 922)		if (_hx_tmp) {
HXLINE( 924)			HX_VARI(  ::openfl::display::DisplayObject,_this) = this->_hx___owner;
HXDLIN( 924)			Bool _hx_tmp1 = !(_this->_hx___renderDirty);
HXDLIN( 924)			if (_hx_tmp1) {
HXLINE( 924)				_this->_hx___updateCachedBitmap = true;
HXDLIN( 924)				Bool _hx_tmp2;
HXDLIN( 924)				::Array< ::Dynamic> _hx_tmp3 = _this->get_filters();
HXDLIN( 924)				Bool _hx_tmp4 = hx::IsNotNull( _hx_tmp3 );
HXDLIN( 924)				if (_hx_tmp4) {
HXLINE( 924)					_hx_tmp2 = (_this->get_filters()->length > (int)0);
            				}
            				else {
HXLINE( 924)					_hx_tmp2 = false;
            				}
HXDLIN( 924)				_this->_hx___updateFilters = _hx_tmp2;
HXDLIN( 924)				_this->_hx___renderDirty = true;
HXDLIN( 924)				::openfl::display::DisplayObject_obj::_hx___worldRenderDirty++;
            			}
            		}
HXLINE( 928)		return (this->_hx___dirty = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Graphics_obj,set___dirty,return )

Int Graphics_obj::TILE_SCALE;

Int Graphics_obj::TILE_ROTATION;

Int Graphics_obj::TILE_RGB;

Int Graphics_obj::TILE_ALPHA;

Int Graphics_obj::TILE_TRANS_2x2;

Int Graphics_obj::TILE_RECT;

Int Graphics_obj::TILE_ORIGIN;

Int Graphics_obj::TILE_BLEND_NORMAL;

Int Graphics_obj::TILE_BLEND_ADD;

Int Graphics_obj::TILE_BLEND_MULTIPLY;

Int Graphics_obj::TILE_BLEND_SCREEN;

Int Graphics_obj::TILE_BLEND_SUBTRACT;

Int Graphics_obj::TILE_BLEND_DARKEN;

Int Graphics_obj::TILE_BLEND_LIGHTEN;

Int Graphics_obj::TILE_BLEND_OVERLAY;

Int Graphics_obj::TILE_BLEND_HARDLIGHT;

Int Graphics_obj::TILE_BLEND_DIFFERENCE;

Int Graphics_obj::TILE_BLEND_INVERT;


Graphics_obj::Graphics_obj()
{
}

void Graphics_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Graphics);
	HX_MARK_MEMBER_NAME(_hx___hardware,"__hardware");
	HX_MARK_MEMBER_NAME(_hx___bounds,"__bounds");
	HX_MARK_MEMBER_NAME(_hx___commands,"__commands");
	HX_MARK_MEMBER_NAME(_hx___dirty,"__dirty");
	HX_MARK_MEMBER_NAME(_hx___glStack,"__glStack");
	HX_MARK_MEMBER_NAME(_hx___drawPaths,"__drawPaths");
	HX_MARK_MEMBER_NAME(_hx___image,"__image");
	HX_MARK_MEMBER_NAME(_hx___positionX,"__positionX");
	HX_MARK_MEMBER_NAME(_hx___positionY,"__positionY");
	HX_MARK_MEMBER_NAME(_hx___strokePadding,"__strokePadding");
	HX_MARK_MEMBER_NAME(_hx___transformDirty,"__transformDirty");
	HX_MARK_MEMBER_NAME(_hx___visible,"__visible");
	HX_MARK_MEMBER_NAME(_hx___cachedTexture,"__cachedTexture");
	HX_MARK_MEMBER_NAME(_hx___owner,"__owner");
	HX_MARK_MEMBER_NAME(_hx___cairo,"__cairo");
	HX_MARK_MEMBER_NAME(_hx___bitmap,"__bitmap");
	HX_MARK_END_CLASS();
}

void Graphics_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_hx___hardware,"__hardware");
	HX_VISIT_MEMBER_NAME(_hx___bounds,"__bounds");
	HX_VISIT_MEMBER_NAME(_hx___commands,"__commands");
	HX_VISIT_MEMBER_NAME(_hx___dirty,"__dirty");
	HX_VISIT_MEMBER_NAME(_hx___glStack,"__glStack");
	HX_VISIT_MEMBER_NAME(_hx___drawPaths,"__drawPaths");
	HX_VISIT_MEMBER_NAME(_hx___image,"__image");
	HX_VISIT_MEMBER_NAME(_hx___positionX,"__positionX");
	HX_VISIT_MEMBER_NAME(_hx___positionY,"__positionY");
	HX_VISIT_MEMBER_NAME(_hx___strokePadding,"__strokePadding");
	HX_VISIT_MEMBER_NAME(_hx___transformDirty,"__transformDirty");
	HX_VISIT_MEMBER_NAME(_hx___visible,"__visible");
	HX_VISIT_MEMBER_NAME(_hx___cachedTexture,"__cachedTexture");
	HX_VISIT_MEMBER_NAME(_hx___owner,"__owner");
	HX_VISIT_MEMBER_NAME(_hx___cairo,"__cairo");
	HX_VISIT_MEMBER_NAME(_hx___bitmap,"__bitmap");
}

hx::Val Graphics_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"clear") ) { return hx::Val( clear_dyn()); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"lineTo") ) { return hx::Val( lineTo_dyn()); }
		if (HX_FIELD_EQ(inName,"moveTo") ) { return hx::Val( moveTo_dyn()); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"__dirty") ) { return hx::Val( _hx___dirty); }
		if (HX_FIELD_EQ(inName,"__image") ) { return hx::Val( _hx___image); }
		if (HX_FIELD_EQ(inName,"__owner") ) { return hx::Val( _hx___owner); }
		if (HX_FIELD_EQ(inName,"__cairo") ) { return hx::Val( _hx___cairo); }
		if (HX_FIELD_EQ(inName,"curveTo") ) { return hx::Val( curveTo_dyn()); }
		if (HX_FIELD_EQ(inName,"endFill") ) { return hx::Val( endFill_dyn()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"__bounds") ) { return hx::Val( _hx___bounds); }
		if (HX_FIELD_EQ(inName,"__bitmap") ) { return hx::Val( _hx___bitmap); }
		if (HX_FIELD_EQ(inName,"copyFrom") ) { return hx::Val( copyFrom_dyn()); }
		if (HX_FIELD_EQ(inName,"drawPath") ) { return hx::Val( drawPath_dyn()); }
		if (HX_FIELD_EQ(inName,"drawRect") ) { return hx::Val( drawRect_dyn()); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"__glStack") ) { return hx::Val( _hx___glStack); }
		if (HX_FIELD_EQ(inName,"__visible") ) { return hx::Val( _hx___visible); }
		if (HX_FIELD_EQ(inName,"beginFill") ) { return hx::Val( beginFill_dyn()); }
		if (HX_FIELD_EQ(inName,"drawTiles") ) { return hx::Val( drawTiles_dyn()); }
		if (HX_FIELD_EQ(inName,"lineStyle") ) { return hx::Val( lineStyle_dyn()); }
		if (HX_FIELD_EQ(inName,"__hitTest") ) { return hx::Val( _hx___hitTest_dyn()); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"__hardware") ) { return hx::Val( _hx___hardware); }
		if (HX_FIELD_EQ(inName,"__commands") ) { return hx::Val( _hx___commands); }
		if (HX_FIELD_EQ(inName,"drawCircle") ) { return hx::Val( drawCircle_dyn()); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"__drawPaths") ) { return hx::Val( _hx___drawPaths); }
		if (HX_FIELD_EQ(inName,"__positionX") ) { return hx::Val( _hx___positionX); }
		if (HX_FIELD_EQ(inName,"__positionY") ) { return hx::Val( _hx___positionY); }
		if (HX_FIELD_EQ(inName,"drawEllipse") ) { return hx::Val( drawEllipse_dyn()); }
		if (HX_FIELD_EQ(inName,"__getBounds") ) { return hx::Val( _hx___getBounds_dyn()); }
		if (HX_FIELD_EQ(inName,"set___dirty") ) { return hx::Val( set___dirty_dyn()); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"cubicCurveTo") ) { return hx::Val( cubicCurveTo_dyn()); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"drawRoundRect") ) { return hx::Val( drawRoundRect_dyn()); }
		if (HX_FIELD_EQ(inName,"drawTriangles") ) { return hx::Val( drawTriangles_dyn()); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"__strokePadding") ) { return hx::Val( _hx___strokePadding); }
		if (HX_FIELD_EQ(inName,"__cachedTexture") ) { return hx::Val( _hx___cachedTexture); }
		if (HX_FIELD_EQ(inName,"beginBitmapFill") ) { return hx::Val( beginBitmapFill_dyn()); }
		if (HX_FIELD_EQ(inName,"lineBitmapStyle") ) { return hx::Val( lineBitmapStyle_dyn()); }
		if (HX_FIELD_EQ(inName,"__inflateBounds") ) { return hx::Val( _hx___inflateBounds_dyn()); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"__transformDirty") ) { return hx::Val( _hx___transformDirty); }
		if (HX_FIELD_EQ(inName,"drawGraphicsData") ) { return hx::Val( drawGraphicsData_dyn()); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"beginGradientFill") ) { return hx::Val( beginGradientFill_dyn()); }
		if (HX_FIELD_EQ(inName,"lineGradientStyle") ) { return hx::Val( lineGradientStyle_dyn()); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"drawRoundRectComplex") ) { return hx::Val( drawRoundRectComplex_dyn()); }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"__calculateBezierQuadPoint") ) { return hx::Val( _hx___calculateBezierQuadPoint_dyn()); }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"__calculateBezierCubicPoint") ) { return hx::Val( _hx___calculateBezierCubicPoint_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Graphics_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"__dirty") ) { if (inCallProp == hx::paccAlways) return hx::Val( set___dirty(inValue) );_hx___dirty=inValue.Cast< Bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__image") ) { _hx___image=inValue.Cast<  ::lime::graphics::Image >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__owner") ) { _hx___owner=inValue.Cast<  ::openfl::display::DisplayObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__cairo") ) { _hx___cairo=inValue.Cast<  ::lime::graphics::cairo::Cairo >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"__bounds") ) { _hx___bounds=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__bitmap") ) { _hx___bitmap=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"__glStack") ) { _hx___glStack=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__visible") ) { _hx___visible=inValue.Cast< Bool >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"__hardware") ) { _hx___hardware=inValue.Cast< Bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__commands") ) { _hx___commands=inValue.Cast<  ::openfl::_internal::renderer::DrawCommandBuffer >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"__drawPaths") ) { _hx___drawPaths=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__positionX") ) { _hx___positionX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__positionY") ) { _hx___positionY=inValue.Cast< Float >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"__strokePadding") ) { _hx___strokePadding=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__cachedTexture") ) { _hx___cachedTexture=inValue.Cast<  ::openfl::_internal::renderer::opengl::utils::RenderTexture >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"__transformDirty") ) { _hx___transformDirty=inValue.Cast< Bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Graphics_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("__hardware","\xc8","\x55","\x0c","\x19"));
	outFields->push(HX_HCSTRING("__bounds","\x95","\xf1","\x4c","\x0e"));
	outFields->push(HX_HCSTRING("__commands","\xe8","\x23","\x8e","\x61"));
	outFields->push(HX_HCSTRING("__dirty","\xf2","\xa8","\x2e","\x44"));
	outFields->push(HX_HCSTRING("__glStack","\xc3","\xe7","\x34","\x82"));
	outFields->push(HX_HCSTRING("__drawPaths","\x6a","\x89","\x8e","\xb3"));
	outFields->push(HX_HCSTRING("__image","\x3b","\x78","\xc7","\x27"));
	outFields->push(HX_HCSTRING("__positionX","\x6f","\x3c","\x7e","\xfe"));
	outFields->push(HX_HCSTRING("__positionY","\x70","\x3c","\x7e","\xfe"));
	outFields->push(HX_HCSTRING("__strokePadding","\xd9","\x6d","\xda","\xc4"));
	outFields->push(HX_HCSTRING("__transformDirty","\x26","\xf6","\x91","\x84"));
	outFields->push(HX_HCSTRING("__visible","\x52","\xc9","\x72","\x24"));
	outFields->push(HX_HCSTRING("__cachedTexture","\xf9","\x69","\x14","\x5c"));
	outFields->push(HX_HCSTRING("__owner","\x13","\xf1","\xd4","\xa2"));
	outFields->push(HX_HCSTRING("__cairo","\x68","\x89","\x77","\xab"));
	outFields->push(HX_HCSTRING("__bitmap","\x0f","\x7b","\x3b","\x99"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Graphics_obj_sMemberStorageInfo[] = {
	{hx::fsBool,(int)offsetof(Graphics_obj,_hx___hardware),HX_HCSTRING("__hardware","\xc8","\x55","\x0c","\x19")},
	{hx::fsObject /*::openfl::geom::Rectangle*/ ,(int)offsetof(Graphics_obj,_hx___bounds),HX_HCSTRING("__bounds","\x95","\xf1","\x4c","\x0e")},
	{hx::fsObject /*::openfl::_internal::renderer::DrawCommandBuffer*/ ,(int)offsetof(Graphics_obj,_hx___commands),HX_HCSTRING("__commands","\xe8","\x23","\x8e","\x61")},
	{hx::fsBool,(int)offsetof(Graphics_obj,_hx___dirty),HX_HCSTRING("__dirty","\xf2","\xa8","\x2e","\x44")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Graphics_obj,_hx___glStack),HX_HCSTRING("__glStack","\xc3","\xe7","\x34","\x82")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Graphics_obj,_hx___drawPaths),HX_HCSTRING("__drawPaths","\x6a","\x89","\x8e","\xb3")},
	{hx::fsObject /*::lime::graphics::Image*/ ,(int)offsetof(Graphics_obj,_hx___image),HX_HCSTRING("__image","\x3b","\x78","\xc7","\x27")},
	{hx::fsFloat,(int)offsetof(Graphics_obj,_hx___positionX),HX_HCSTRING("__positionX","\x6f","\x3c","\x7e","\xfe")},
	{hx::fsFloat,(int)offsetof(Graphics_obj,_hx___positionY),HX_HCSTRING("__positionY","\x70","\x3c","\x7e","\xfe")},
	{hx::fsFloat,(int)offsetof(Graphics_obj,_hx___strokePadding),HX_HCSTRING("__strokePadding","\xd9","\x6d","\xda","\xc4")},
	{hx::fsBool,(int)offsetof(Graphics_obj,_hx___transformDirty),HX_HCSTRING("__transformDirty","\x26","\xf6","\x91","\x84")},
	{hx::fsBool,(int)offsetof(Graphics_obj,_hx___visible),HX_HCSTRING("__visible","\x52","\xc9","\x72","\x24")},
	{hx::fsObject /*::openfl::_internal::renderer::opengl::utils::RenderTexture*/ ,(int)offsetof(Graphics_obj,_hx___cachedTexture),HX_HCSTRING("__cachedTexture","\xf9","\x69","\x14","\x5c")},
	{hx::fsObject /*::openfl::display::DisplayObject*/ ,(int)offsetof(Graphics_obj,_hx___owner),HX_HCSTRING("__owner","\x13","\xf1","\xd4","\xa2")},
	{hx::fsObject /*::lime::graphics::cairo::Cairo*/ ,(int)offsetof(Graphics_obj,_hx___cairo),HX_HCSTRING("__cairo","\x68","\x89","\x77","\xab")},
	{hx::fsObject /*::openfl::display::BitmapData*/ ,(int)offsetof(Graphics_obj,_hx___bitmap),HX_HCSTRING("__bitmap","\x0f","\x7b","\x3b","\x99")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Graphics_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &Graphics_obj::TILE_SCALE,HX_HCSTRING("TILE_SCALE","\x59","\x77","\x2d","\x62")},
	{hx::fsInt,(void *) &Graphics_obj::TILE_ROTATION,HX_HCSTRING("TILE_ROTATION","\xaf","\x5b","\x7b","\x62")},
	{hx::fsInt,(void *) &Graphics_obj::TILE_RGB,HX_HCSTRING("TILE_RGB","\x1c","\x7e","\xfb","\xfc")},
	{hx::fsInt,(void *) &Graphics_obj::TILE_ALPHA,HX_HCSTRING("TILE_ALPHA","\x2d","\x50","\xf5","\x0a")},
	{hx::fsInt,(void *) &Graphics_obj::TILE_TRANS_2x2,HX_HCSTRING("TILE_TRANS_2x2","\xe4","\x26","\x89","\xb2")},
	{hx::fsInt,(void *) &Graphics_obj::TILE_RECT,HX_HCSTRING("TILE_RECT","\x15","\x57","\x11","\x5f")},
	{hx::fsInt,(void *) &Graphics_obj::TILE_ORIGIN,HX_HCSTRING("TILE_ORIGIN","\x17","\x26","\x76","\x94")},
	{hx::fsInt,(void *) &Graphics_obj::TILE_BLEND_NORMAL,HX_HCSTRING("TILE_BLEND_NORMAL","\xa6","\x02","\x62","\x2c")},
	{hx::fsInt,(void *) &Graphics_obj::TILE_BLEND_ADD,HX_HCSTRING("TILE_BLEND_ADD","\x22","\x74","\xbf","\x89")},
	{hx::fsInt,(void *) &Graphics_obj::TILE_BLEND_MULTIPLY,HX_HCSTRING("TILE_BLEND_MULTIPLY","\x63","\xb4","\x29","\xf2")},
	{hx::fsInt,(void *) &Graphics_obj::TILE_BLEND_SCREEN,HX_HCSTRING("TILE_BLEND_SCREEN","\xeb","\xcb","\x55","\x43")},
	{hx::fsInt,(void *) &Graphics_obj::TILE_BLEND_SUBTRACT,HX_HCSTRING("TILE_BLEND_SUBTRACT","\x53","\x47","\xae","\x4f")},
	{hx::fsInt,(void *) &Graphics_obj::TILE_BLEND_DARKEN,HX_HCSTRING("TILE_BLEND_DARKEN","\xde","\xc6","\x32","\x1d")},
	{hx::fsInt,(void *) &Graphics_obj::TILE_BLEND_LIGHTEN,HX_HCSTRING("TILE_BLEND_LIGHTEN","\x40","\x29","\x69","\x97")},
	{hx::fsInt,(void *) &Graphics_obj::TILE_BLEND_OVERLAY,HX_HCSTRING("TILE_BLEND_OVERLAY","\x11","\x22","\x96","\x26")},
	{hx::fsInt,(void *) &Graphics_obj::TILE_BLEND_HARDLIGHT,HX_HCSTRING("TILE_BLEND_HARDLIGHT","\xcc","\x92","\x06","\xa5")},
	{hx::fsInt,(void *) &Graphics_obj::TILE_BLEND_DIFFERENCE,HX_HCSTRING("TILE_BLEND_DIFFERENCE","\xfc","\x9f","\xb6","\x5c")},
	{hx::fsInt,(void *) &Graphics_obj::TILE_BLEND_INVERT,HX_HCSTRING("TILE_BLEND_INVERT","\x95","\x77","\xd1","\x9b")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Graphics_obj_sMemberFields[] = {
	HX_HCSTRING("__hardware","\xc8","\x55","\x0c","\x19"),
	HX_HCSTRING("__bounds","\x95","\xf1","\x4c","\x0e"),
	HX_HCSTRING("__commands","\xe8","\x23","\x8e","\x61"),
	HX_HCSTRING("__dirty","\xf2","\xa8","\x2e","\x44"),
	HX_HCSTRING("__glStack","\xc3","\xe7","\x34","\x82"),
	HX_HCSTRING("__drawPaths","\x6a","\x89","\x8e","\xb3"),
	HX_HCSTRING("__image","\x3b","\x78","\xc7","\x27"),
	HX_HCSTRING("__positionX","\x6f","\x3c","\x7e","\xfe"),
	HX_HCSTRING("__positionY","\x70","\x3c","\x7e","\xfe"),
	HX_HCSTRING("__strokePadding","\xd9","\x6d","\xda","\xc4"),
	HX_HCSTRING("__transformDirty","\x26","\xf6","\x91","\x84"),
	HX_HCSTRING("__visible","\x52","\xc9","\x72","\x24"),
	HX_HCSTRING("__cachedTexture","\xf9","\x69","\x14","\x5c"),
	HX_HCSTRING("__owner","\x13","\xf1","\xd4","\xa2"),
	HX_HCSTRING("__cairo","\x68","\x89","\x77","\xab"),
	HX_HCSTRING("__bitmap","\x0f","\x7b","\x3b","\x99"),
	HX_HCSTRING("beginBitmapFill","\x9b","\xc9","\x07","\x6a"),
	HX_HCSTRING("beginFill","\x4c","\xad","\x95","\x8c"),
	HX_HCSTRING("beginGradientFill","\x5c","\x3c","\x03","\x2e"),
	HX_HCSTRING("clear","\x8d","\x71","\x5b","\x48"),
	HX_HCSTRING("copyFrom","\xbf","\x0b","\x61","\xc8"),
	HX_HCSTRING("cubicCurveTo","\xe0","\x07","\x90","\x2e"),
	HX_HCSTRING("curveTo","\x0a","\x60","\x88","\xce"),
	HX_HCSTRING("drawCircle","\x34","\xed","\xd0","\x97"),
	HX_HCSTRING("drawEllipse","\x3a","\x85","\xce","\x54"),
	HX_HCSTRING("drawGraphicsData","\xb9","\xaa","\x6e","\x60"),
	HX_HCSTRING("drawPath","\xc9","\x8f","\xbb","\x5e"),
	HX_HCSTRING("drawRect","\x48","\xf7","\x10","\x60"),
	HX_HCSTRING("drawRoundRect","\xee","\xc3","\xaa","\xe2"),
	HX_HCSTRING("drawRoundRectComplex","\xe2","\x43","\x2c","\x11"),
	HX_HCSTRING("drawTiles","\xe1","\x32","\x40","\xd8"),
	HX_HCSTRING("drawTriangles","\x07","\x44","\x68","\xde"),
	HX_HCSTRING("endFill","\xfe","\x87","\xe0","\x25"),
	HX_HCSTRING("lineBitmapStyle","\x2e","\x3f","\x21","\x45"),
	HX_HCSTRING("lineGradientStyle","\x8d","\x24","\xf2","\xc1"),
	HX_HCSTRING("lineStyle","\x9d","\xa8","\x18","\xcb"),
	HX_HCSTRING("lineTo","\x8f","\x46","\xa0","\xec"),
	HX_HCSTRING("moveTo","\xec","\xd2","\xac","\xcc"),
	HX_HCSTRING("__calculateBezierCubicPoint","\x0b","\xc2","\xaf","\xf4"),
	HX_HCSTRING("__calculateBezierQuadPoint","\x44","\x46","\xe8","\x5e"),
	HX_HCSTRING("__getBounds","\x8b","\x58","\xa0","\x10"),
	HX_HCSTRING("__hitTest","\x25","\xb1","\xcd","\x63"),
	HX_HCSTRING("__inflateBounds","\x3c","\x6f","\xee","\xb6"),
	HX_HCSTRING("set___dirty","\x15","\x10","\x96","\xd4"),
	::String(null()) };

static void Graphics_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Graphics_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_SCALE,"TILE_SCALE");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_ROTATION,"TILE_ROTATION");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_RGB,"TILE_RGB");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_ALPHA,"TILE_ALPHA");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_TRANS_2x2,"TILE_TRANS_2x2");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_RECT,"TILE_RECT");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_ORIGIN,"TILE_ORIGIN");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_BLEND_NORMAL,"TILE_BLEND_NORMAL");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_BLEND_ADD,"TILE_BLEND_ADD");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_BLEND_MULTIPLY,"TILE_BLEND_MULTIPLY");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_BLEND_SCREEN,"TILE_BLEND_SCREEN");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_BLEND_SUBTRACT,"TILE_BLEND_SUBTRACT");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_BLEND_DARKEN,"TILE_BLEND_DARKEN");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_BLEND_LIGHTEN,"TILE_BLEND_LIGHTEN");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_BLEND_OVERLAY,"TILE_BLEND_OVERLAY");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_BLEND_HARDLIGHT,"TILE_BLEND_HARDLIGHT");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_BLEND_DIFFERENCE,"TILE_BLEND_DIFFERENCE");
	HX_MARK_MEMBER_NAME(Graphics_obj::TILE_BLEND_INVERT,"TILE_BLEND_INVERT");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Graphics_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Graphics_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_SCALE,"TILE_SCALE");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_ROTATION,"TILE_ROTATION");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_RGB,"TILE_RGB");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_ALPHA,"TILE_ALPHA");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_TRANS_2x2,"TILE_TRANS_2x2");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_RECT,"TILE_RECT");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_ORIGIN,"TILE_ORIGIN");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_BLEND_NORMAL,"TILE_BLEND_NORMAL");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_BLEND_ADD,"TILE_BLEND_ADD");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_BLEND_MULTIPLY,"TILE_BLEND_MULTIPLY");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_BLEND_SCREEN,"TILE_BLEND_SCREEN");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_BLEND_SUBTRACT,"TILE_BLEND_SUBTRACT");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_BLEND_DARKEN,"TILE_BLEND_DARKEN");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_BLEND_LIGHTEN,"TILE_BLEND_LIGHTEN");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_BLEND_OVERLAY,"TILE_BLEND_OVERLAY");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_BLEND_HARDLIGHT,"TILE_BLEND_HARDLIGHT");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_BLEND_DIFFERENCE,"TILE_BLEND_DIFFERENCE");
	HX_VISIT_MEMBER_NAME(Graphics_obj::TILE_BLEND_INVERT,"TILE_BLEND_INVERT");
};

#endif

hx::Class Graphics_obj::__mClass;

static ::String Graphics_obj_sStaticFields[] = {
	HX_HCSTRING("TILE_SCALE","\x59","\x77","\x2d","\x62"),
	HX_HCSTRING("TILE_ROTATION","\xaf","\x5b","\x7b","\x62"),
	HX_HCSTRING("TILE_RGB","\x1c","\x7e","\xfb","\xfc"),
	HX_HCSTRING("TILE_ALPHA","\x2d","\x50","\xf5","\x0a"),
	HX_HCSTRING("TILE_TRANS_2x2","\xe4","\x26","\x89","\xb2"),
	HX_HCSTRING("TILE_RECT","\x15","\x57","\x11","\x5f"),
	HX_HCSTRING("TILE_ORIGIN","\x17","\x26","\x76","\x94"),
	HX_HCSTRING("TILE_BLEND_NORMAL","\xa6","\x02","\x62","\x2c"),
	HX_HCSTRING("TILE_BLEND_ADD","\x22","\x74","\xbf","\x89"),
	HX_HCSTRING("TILE_BLEND_MULTIPLY","\x63","\xb4","\x29","\xf2"),
	HX_HCSTRING("TILE_BLEND_SCREEN","\xeb","\xcb","\x55","\x43"),
	HX_HCSTRING("TILE_BLEND_SUBTRACT","\x53","\x47","\xae","\x4f"),
	HX_HCSTRING("TILE_BLEND_DARKEN","\xde","\xc6","\x32","\x1d"),
	HX_HCSTRING("TILE_BLEND_LIGHTEN","\x40","\x29","\x69","\x97"),
	HX_HCSTRING("TILE_BLEND_OVERLAY","\x11","\x22","\x96","\x26"),
	HX_HCSTRING("TILE_BLEND_HARDLIGHT","\xcc","\x92","\x06","\xa5"),
	HX_HCSTRING("TILE_BLEND_DIFFERENCE","\xfc","\x9f","\xb6","\x5c"),
	HX_HCSTRING("TILE_BLEND_INVERT","\x95","\x77","\xd1","\x9b"),
	::String(null())
};

void Graphics_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl.display.Graphics","\x35","\x67","\x20","\x87");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Graphics_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Graphics_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Graphics_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Graphics_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Graphics_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Graphics_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Graphics_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Graphics_obj::__boot()
{
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",39,0x8d299ce7)
HXLINE(  39)		TILE_SCALE = (int)1;
            	}
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",40,0x8d299ce7)
HXLINE(  40)		TILE_ROTATION = (int)2;
            	}
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",41,0x8d299ce7)
HXLINE(  41)		TILE_RGB = (int)4;
            	}
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",42,0x8d299ce7)
HXLINE(  42)		TILE_ALPHA = (int)8;
            	}
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",43,0x8d299ce7)
HXLINE(  43)		TILE_TRANS_2x2 = (int)16;
            	}
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",44,0x8d299ce7)
HXLINE(  44)		TILE_RECT = (int)32;
            	}
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",45,0x8d299ce7)
HXLINE(  45)		TILE_ORIGIN = (int)64;
            	}
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",47,0x8d299ce7)
HXLINE(  47)		TILE_BLEND_NORMAL = (int)0;
            	}
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",48,0x8d299ce7)
HXLINE(  48)		TILE_BLEND_ADD = (int)65536;
            	}
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",49,0x8d299ce7)
HXLINE(  49)		TILE_BLEND_MULTIPLY = (int)131072;
            	}
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",50,0x8d299ce7)
HXLINE(  50)		TILE_BLEND_SCREEN = (int)262144;
            	}
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",51,0x8d299ce7)
HXLINE(  51)		TILE_BLEND_SUBTRACT = (int)524288;
            	}
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",52,0x8d299ce7)
HXLINE(  52)		TILE_BLEND_DARKEN = (int)1048576;
            	}
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",53,0x8d299ce7)
HXLINE(  53)		TILE_BLEND_LIGHTEN = (int)2097152;
            	}
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",54,0x8d299ce7)
HXLINE(  54)		TILE_BLEND_OVERLAY = (int)4194304;
            	}
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",55,0x8d299ce7)
HXLINE(  55)		TILE_BLEND_HARDLIGHT = (int)8388608;
            	}
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",56,0x8d299ce7)
HXLINE(  56)		TILE_BLEND_DIFFERENCE = (int)16777216;
            	}
{
            	HX_STACK_FRAME("openfl.display.Graphics","boot",0x557e8c0b,"openfl.display.Graphics.boot","openfl/display/Graphics.hx",57,0x8d299ce7)
HXLINE(  57)		TILE_BLEND_INVERT = (int)33554432;
            	}
}

} // end namespace openfl
} // end namespace display
