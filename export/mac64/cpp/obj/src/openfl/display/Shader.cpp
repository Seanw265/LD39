// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_lime_graphics_GLRenderContext
#include <lime/graphics/GLRenderContext.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_shaders2_DefaultShader
#include <openfl/_internal/renderer/opengl/shaders2/DefaultShader.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_shaders2_Shader
#include <openfl/_internal/renderer/opengl/shaders2/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_GLShaderParameter
#include <openfl/display/GLShaderParameter.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif

namespace openfl{
namespace display{

void Shader_obj::__construct( ::Dynamic __o_precision){
 ::Dynamic precision = __o_precision.Default(1);
            	HX_STACK_FRAME("openfl.display.Shader","new",0x88fbb381,"openfl.display.Shader.new","openfl/display/Shader.hx",12,0xae8f5dcd)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(precision,"precision")
HXLINE( 130)		this->_hx___dirty = true;
HXLINE( 118)		this->repeatY = (int)33071;
HXLINE( 113)		this->repeatX = (int)33071;
HXLINE( 104)		this->precision = (int)1;
HXLINE( 136)		this->precision = precision;
HXLINE( 137)		this->data =  ::haxe::ds::StringMap_obj::__new();
HXLINE( 139)		{
HXLINE( 139)			 ::openfl::display::GLShaderParameter value =  ::openfl::display::GLShaderParameter_obj::__new(HX_("vec2",5e,27,4c,4e),null());
HXDLIN( 139)			this->data->set(::openfl::display::Shader_obj::uObjectSize,value);
            		}
HXLINE( 140)		{
HXLINE( 140)			 ::openfl::display::GLShaderParameter value1 =  ::openfl::display::GLShaderParameter_obj::__new(HX_("vec2",5e,27,4c,4e),null());
HXDLIN( 140)			this->data->set(::openfl::display::Shader_obj::uTextureSize,value1);
            		}
            	}

Dynamic Shader_obj::__CreateEmpty() { return new Shader_obj; }

hx::ObjectPtr< Shader_obj > Shader_obj::__new( ::Dynamic __o_precision)
{
	hx::ObjectPtr< Shader_obj > _hx_result = new Shader_obj();
	_hx_result->__construct(__o_precision);
	return _hx_result;
}

Dynamic Shader_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Shader_obj > _hx_result = new Shader_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

void Shader_obj::_hx___init( ::lime::graphics::GLRenderContext gl){
            	HX_STACK_FRAME("openfl.display.Shader","__init",0x2faba5af,"openfl.display.Shader.__init","openfl/display/Shader.hx",143,0xae8f5dcd)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(gl,"gl")
HXLINE( 144)		HX_VARI( Bool,dirty) = this->_hx___dirty;
HXLINE( 145)		if (dirty) {
HXLINE( 146)			Bool _hx_tmp = hx::IsNotNull( this->_hx___shader );
HXDLIN( 146)			if (_hx_tmp) {
HXLINE( 147)				this->_hx___shader->destroy();
            			}
HXLINE( 149)			this->_hx___shader =  ::openfl::_internal::renderer::opengl::shaders2::Shader_obj::__new(gl);
HXLINE( 150)			::String _hx_tmp1;
HXDLIN( 150)			Bool _hx_tmp2 = hx::IsNotNull( this->_hx___vertexCode );
HXDLIN( 150)			if (_hx_tmp2) {
HXLINE( 150)				_hx_tmp1 = this->_hx___vertexCode;
            			}
            			else {
HXLINE( 150)				_hx_tmp1 = ::openfl::_internal::renderer::opengl::shaders2::DefaultShader_obj::VERTEX_SRC->join(HX_("\n",0a,00,00,00));
            			}
HXDLIN( 150)			this->_hx___shader->vertexString = _hx_tmp1;
HXLINE( 151)			this->_hx___shader->fragmentString = this->_hx___fragmentCode;
HXLINE( 152)			this->_hx___dirty = false;
            		}
HXLINE( 155)		this->_hx___shader->init(dirty);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shader_obj,_hx___init,(void))

void Shader_obj::_hx___buildFragmentCode(::String code){
            	HX_STACK_FRAME("openfl.display.Shader","__buildFragmentCode",0xc1a3b76c,"openfl.display.Shader.__buildFragmentCode","openfl/display/Shader.hx",158,0xae8f5dcd)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(code,"code")
HXLINE( 159)		HX_VARI( ::Array< ::String >,output) = ::Array_obj< ::String >::__new(0);
HXLINE( 161)		output->push(HX_("#ifdef GL_ES",2d,5e,36,de));
HXLINE( 162)		HX_VARI( Int,_g) = this->precision;
HXDLIN( 162)		::String _hx_tmp;
HXDLIN( 162)		switch((int)(_g)){
            			case (int)1: {
HXLINE( 162)				_hx_tmp = HX_("precision mediump float;",e6,f2,15,86);
            			}
            			break;
            			case (int)2: {
HXLINE( 162)				_hx_tmp = HX_("precision highp float;",53,3e,5f,7e);
            			}
            			break;
            			default:{
HXLINE( 162)				_hx_tmp = HX_("precision lowp float;",81,5f,ad,9a);
            			}
            		}
HXDLIN( 162)		output->push(_hx_tmp);
HXLINE( 167)		output->push(HX_("#endif",75,ed,f7,6e));
HXLINE( 171)		output = output->concat(::openfl::display::Shader_obj::fragmentHeader);
HXLINE( 172)		output->push(code);
HXLINE( 174)		this->_hx___fragmentCode = output->join(HX_("\n",0a,00,00,00));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shader_obj,_hx___buildFragmentCode,(void))

void Shader_obj::_hx___buildVertexCode(::String code){
            	HX_STACK_FRAME("openfl.display.Shader","__buildVertexCode",0x0fad0b40,"openfl.display.Shader.__buildVertexCode","openfl/display/Shader.hx",177,0xae8f5dcd)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(code,"code")
HXLINE( 178)		HX_VARI( ::Array< ::String >,output) = ::Array_obj< ::String >::__new(0);
HXLINE( 180)		output->push(HX_("#ifdef GL_ES",2d,5e,36,de));
HXLINE( 181)		HX_VARI( Int,_g) = this->precision;
HXDLIN( 181)		::String _hx_tmp;
HXDLIN( 181)		switch((int)(_g)){
            			case (int)1: {
HXLINE( 181)				_hx_tmp = HX_("precision mediump float;",e6,f2,15,86);
            			}
            			break;
            			case (int)2: {
HXLINE( 181)				_hx_tmp = HX_("precision highp float;",53,3e,5f,7e);
            			}
            			break;
            			default:{
HXLINE( 181)				_hx_tmp = HX_("precision lowp float;",81,5f,ad,9a);
            			}
            		}
HXDLIN( 181)		output->push(_hx_tmp);
HXLINE( 186)		output->push(HX_("#endif",75,ed,f7,6e));
HXLINE( 188)		output = output->concat(::openfl::display::Shader_obj::vertexHeader);
HXLINE( 189)		output->push(code);
HXLINE( 191)		this->_hx___vertexCode = output->join(HX_("\n",0a,00,00,00));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shader_obj,_hx___buildVertexCode,(void))

 ::EReg Shader_obj::uniformRegex;

::String Shader_obj::aPosition;

::String Shader_obj::aTexCoord;

::String Shader_obj::aColor;

::String Shader_obj::uSampler;

::String Shader_obj::uProjectionMatrix;

::String Shader_obj::uColorMultiplier;

::String Shader_obj::uColorOffset;

::String Shader_obj::uObjectSize;

::String Shader_obj::uTextureSize;

::String Shader_obj::vTexCoord;

::String Shader_obj::vColor;

::Array< ::String > Shader_obj::vertexHeader;

::Array< ::String > Shader_obj::fragmentHeader;


Shader_obj::Shader_obj()
{
}

void Shader_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Shader);
	HX_MARK_MEMBER_NAME(precision,"precision");
	HX_MARK_MEMBER_NAME(data,"data");
	HX_MARK_MEMBER_NAME(repeatX,"repeatX");
	HX_MARK_MEMBER_NAME(repeatY,"repeatY");
	HX_MARK_MEMBER_NAME(smooth,"smooth");
	HX_MARK_MEMBER_NAME(blendMode,"blendMode");
	HX_MARK_MEMBER_NAME(_hx___dirty,"__dirty");
	HX_MARK_MEMBER_NAME(_hx___fragmentCode,"__fragmentCode");
	HX_MARK_MEMBER_NAME(_hx___vertexCode,"__vertexCode");
	HX_MARK_MEMBER_NAME(_hx___shader,"__shader");
	HX_MARK_END_CLASS();
}

void Shader_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(precision,"precision");
	HX_VISIT_MEMBER_NAME(data,"data");
	HX_VISIT_MEMBER_NAME(repeatX,"repeatX");
	HX_VISIT_MEMBER_NAME(repeatY,"repeatY");
	HX_VISIT_MEMBER_NAME(smooth,"smooth");
	HX_VISIT_MEMBER_NAME(blendMode,"blendMode");
	HX_VISIT_MEMBER_NAME(_hx___dirty,"__dirty");
	HX_VISIT_MEMBER_NAME(_hx___fragmentCode,"__fragmentCode");
	HX_VISIT_MEMBER_NAME(_hx___vertexCode,"__vertexCode");
	HX_VISIT_MEMBER_NAME(_hx___shader,"__shader");
}

hx::Val Shader_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"data") ) { return hx::Val( data); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"smooth") ) { return hx::Val( smooth); }
		if (HX_FIELD_EQ(inName,"__init") ) { return hx::Val( _hx___init_dyn()); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"repeatX") ) { return hx::Val( repeatX); }
		if (HX_FIELD_EQ(inName,"repeatY") ) { return hx::Val( repeatY); }
		if (HX_FIELD_EQ(inName,"__dirty") ) { return hx::Val( _hx___dirty); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"__shader") ) { return hx::Val( _hx___shader); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"precision") ) { return hx::Val( precision); }
		if (HX_FIELD_EQ(inName,"blendMode") ) { return hx::Val( blendMode); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"__vertexCode") ) { return hx::Val( _hx___vertexCode); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"__fragmentCode") ) { return hx::Val( _hx___fragmentCode); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"__buildVertexCode") ) { return hx::Val( _hx___buildVertexCode_dyn()); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"__buildFragmentCode") ) { return hx::Val( _hx___buildFragmentCode_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

bool Shader_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"aColor") ) { outValue = aColor; return true; }
		if (HX_FIELD_EQ(inName,"vColor") ) { outValue = vColor; return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"uSampler") ) { outValue = uSampler; return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"aPosition") ) { outValue = aPosition; return true; }
		if (HX_FIELD_EQ(inName,"aTexCoord") ) { outValue = aTexCoord; return true; }
		if (HX_FIELD_EQ(inName,"vTexCoord") ) { outValue = vTexCoord; return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"uObjectSize") ) { outValue = uObjectSize; return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"uniformRegex") ) { outValue = uniformRegex; return true; }
		if (HX_FIELD_EQ(inName,"uColorOffset") ) { outValue = uColorOffset; return true; }
		if (HX_FIELD_EQ(inName,"uTextureSize") ) { outValue = uTextureSize; return true; }
		if (HX_FIELD_EQ(inName,"vertexHeader") ) { outValue = vertexHeader; return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"fragmentHeader") ) { outValue = fragmentHeader; return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"uColorMultiplier") ) { outValue = uColorMultiplier; return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"uProjectionMatrix") ) { outValue = uProjectionMatrix; return true; }
	}
	return false;
}

hx::Val Shader_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"data") ) { data=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"smooth") ) { smooth=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"repeatX") ) { repeatX=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"repeatY") ) { repeatY=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__dirty") ) { _hx___dirty=inValue.Cast< Bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"__shader") ) { _hx___shader=inValue.Cast<  ::openfl::_internal::renderer::opengl::shaders2::Shader >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"precision") ) { precision=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"blendMode") ) { blendMode=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"__vertexCode") ) { _hx___vertexCode=inValue.Cast< ::String >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"__fragmentCode") ) { _hx___fragmentCode=inValue.Cast< ::String >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Shader_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"aColor") ) { aColor=ioValue.Cast< ::String >(); return true; }
		if (HX_FIELD_EQ(inName,"vColor") ) { vColor=ioValue.Cast< ::String >(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"uSampler") ) { uSampler=ioValue.Cast< ::String >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"aPosition") ) { aPosition=ioValue.Cast< ::String >(); return true; }
		if (HX_FIELD_EQ(inName,"aTexCoord") ) { aTexCoord=ioValue.Cast< ::String >(); return true; }
		if (HX_FIELD_EQ(inName,"vTexCoord") ) { vTexCoord=ioValue.Cast< ::String >(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"uObjectSize") ) { uObjectSize=ioValue.Cast< ::String >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"uniformRegex") ) { uniformRegex=ioValue.Cast<  ::EReg >(); return true; }
		if (HX_FIELD_EQ(inName,"uColorOffset") ) { uColorOffset=ioValue.Cast< ::String >(); return true; }
		if (HX_FIELD_EQ(inName,"uTextureSize") ) { uTextureSize=ioValue.Cast< ::String >(); return true; }
		if (HX_FIELD_EQ(inName,"vertexHeader") ) { vertexHeader=ioValue.Cast< ::Array< ::String > >(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"fragmentHeader") ) { fragmentHeader=ioValue.Cast< ::Array< ::String > >(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"uColorMultiplier") ) { uColorMultiplier=ioValue.Cast< ::String >(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"uProjectionMatrix") ) { uProjectionMatrix=ioValue.Cast< ::String >(); return true; }
	}
	return false;
}

void Shader_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("precision","\x3e","\xd5","\xc7","\x80"));
	outFields->push(HX_HCSTRING("data","\x2a","\x56","\x63","\x42"));
	outFields->push(HX_HCSTRING("repeatX","\x9d","\xd8","\x87","\xa6"));
	outFields->push(HX_HCSTRING("repeatY","\x9e","\xd8","\x87","\xa6"));
	outFields->push(HX_HCSTRING("smooth","\x2e","\x08","\x6b","\x07"));
	outFields->push(HX_HCSTRING("blendMode","\x54","\xe4","\x37","\x0c"));
	outFields->push(HX_HCSTRING("__dirty","\xf2","\xa8","\x2e","\x44"));
	outFields->push(HX_HCSTRING("__fragmentCode","\x3d","\xe8","\x37","\x26"));
	outFields->push(HX_HCSTRING("__vertexCode","\xd1","\xb5","\x14","\x0b"));
	outFields->push(HX_HCSTRING("__shader","\x45","\x2a","\x50","\xc5"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Shader_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(Shader_obj,precision),HX_HCSTRING("precision","\x3e","\xd5","\xc7","\x80")},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(int)offsetof(Shader_obj,data),HX_HCSTRING("data","\x2a","\x56","\x63","\x42")},
	{hx::fsInt,(int)offsetof(Shader_obj,repeatX),HX_HCSTRING("repeatX","\x9d","\xd8","\x87","\xa6")},
	{hx::fsInt,(int)offsetof(Shader_obj,repeatY),HX_HCSTRING("repeatY","\x9e","\xd8","\x87","\xa6")},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(Shader_obj,smooth),HX_HCSTRING("smooth","\x2e","\x08","\x6b","\x07")},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(Shader_obj,blendMode),HX_HCSTRING("blendMode","\x54","\xe4","\x37","\x0c")},
	{hx::fsBool,(int)offsetof(Shader_obj,_hx___dirty),HX_HCSTRING("__dirty","\xf2","\xa8","\x2e","\x44")},
	{hx::fsString,(int)offsetof(Shader_obj,_hx___fragmentCode),HX_HCSTRING("__fragmentCode","\x3d","\xe8","\x37","\x26")},
	{hx::fsString,(int)offsetof(Shader_obj,_hx___vertexCode),HX_HCSTRING("__vertexCode","\xd1","\xb5","\x14","\x0b")},
	{hx::fsObject /*::openfl::_internal::renderer::opengl::shaders2::Shader*/ ,(int)offsetof(Shader_obj,_hx___shader),HX_HCSTRING("__shader","\x45","\x2a","\x50","\xc5")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Shader_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::EReg*/ ,(void *) &Shader_obj::uniformRegex,HX_HCSTRING("uniformRegex","\xf3","\x80","\x0b","\xb7")},
	{hx::fsString,(void *) &Shader_obj::aPosition,HX_HCSTRING("aPosition","\x2a","\x26","\x25","\x92")},
	{hx::fsString,(void *) &Shader_obj::aTexCoord,HX_HCSTRING("aTexCoord","\xcf","\x8c","\x5d","\xf2")},
	{hx::fsString,(void *) &Shader_obj::aColor,HX_HCSTRING("aColor","\x42","\xe1","\x27","\xa6")},
	{hx::fsString,(void *) &Shader_obj::uSampler,HX_HCSTRING("uSampler","\x13","\x15","\x29","\x75")},
	{hx::fsString,(void *) &Shader_obj::uProjectionMatrix,HX_HCSTRING("uProjectionMatrix","\xc5","\x5e","\x25","\xc4")},
	{hx::fsString,(void *) &Shader_obj::uColorMultiplier,HX_HCSTRING("uColorMultiplier","\xcf","\xe9","\x0f","\xba")},
	{hx::fsString,(void *) &Shader_obj::uColorOffset,HX_HCSTRING("uColorOffset","\xe1","\xda","\x17","\x0b")},
	{hx::fsString,(void *) &Shader_obj::uObjectSize,HX_HCSTRING("uObjectSize","\xf5","\x1f","\xe4","\xaa")},
	{hx::fsString,(void *) &Shader_obj::uTextureSize,HX_HCSTRING("uTextureSize","\xc7","\x50","\x82","\xf3")},
	{hx::fsString,(void *) &Shader_obj::vTexCoord,HX_HCSTRING("vTexCoord","\xe4","\x29","\x2b","\x40")},
	{hx::fsString,(void *) &Shader_obj::vColor,HX_HCSTRING("vColor","\x0d","\x75","\xa6","\x0b")},
	{hx::fsObject /*Array< ::String >*/ ,(void *) &Shader_obj::vertexHeader,HX_HCSTRING("vertexHeader","\x11","\xfc","\x14","\x9d")},
	{hx::fsObject /*Array< ::String >*/ ,(void *) &Shader_obj::fragmentHeader,HX_HCSTRING("fragmentHeader","\x7d","\x99","\xbb","\x19")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Shader_obj_sMemberFields[] = {
	HX_HCSTRING("precision","\x3e","\xd5","\xc7","\x80"),
	HX_HCSTRING("data","\x2a","\x56","\x63","\x42"),
	HX_HCSTRING("repeatX","\x9d","\xd8","\x87","\xa6"),
	HX_HCSTRING("repeatY","\x9e","\xd8","\x87","\xa6"),
	HX_HCSTRING("smooth","\x2e","\x08","\x6b","\x07"),
	HX_HCSTRING("blendMode","\x54","\xe4","\x37","\x0c"),
	HX_HCSTRING("__dirty","\xf2","\xa8","\x2e","\x44"),
	HX_HCSTRING("__fragmentCode","\x3d","\xe8","\x37","\x26"),
	HX_HCSTRING("__vertexCode","\xd1","\xb5","\x14","\x0b"),
	HX_HCSTRING("__shader","\x45","\x2a","\x50","\xc5"),
	HX_HCSTRING("__init","\x30","\x9e","\xb3","\xf4"),
	HX_HCSTRING("__buildFragmentCode","\x4b","\xc2","\x57","\x26"),
	HX_HCSTRING("__buildVertexCode","\x5f","\x50","\xae","\xfd"),
	::String(null()) };

static void Shader_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Shader_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Shader_obj::uniformRegex,"uniformRegex");
	HX_MARK_MEMBER_NAME(Shader_obj::aPosition,"aPosition");
	HX_MARK_MEMBER_NAME(Shader_obj::aTexCoord,"aTexCoord");
	HX_MARK_MEMBER_NAME(Shader_obj::aColor,"aColor");
	HX_MARK_MEMBER_NAME(Shader_obj::uSampler,"uSampler");
	HX_MARK_MEMBER_NAME(Shader_obj::uProjectionMatrix,"uProjectionMatrix");
	HX_MARK_MEMBER_NAME(Shader_obj::uColorMultiplier,"uColorMultiplier");
	HX_MARK_MEMBER_NAME(Shader_obj::uColorOffset,"uColorOffset");
	HX_MARK_MEMBER_NAME(Shader_obj::uObjectSize,"uObjectSize");
	HX_MARK_MEMBER_NAME(Shader_obj::uTextureSize,"uTextureSize");
	HX_MARK_MEMBER_NAME(Shader_obj::vTexCoord,"vTexCoord");
	HX_MARK_MEMBER_NAME(Shader_obj::vColor,"vColor");
	HX_MARK_MEMBER_NAME(Shader_obj::vertexHeader,"vertexHeader");
	HX_MARK_MEMBER_NAME(Shader_obj::fragmentHeader,"fragmentHeader");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Shader_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Shader_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Shader_obj::uniformRegex,"uniformRegex");
	HX_VISIT_MEMBER_NAME(Shader_obj::aPosition,"aPosition");
	HX_VISIT_MEMBER_NAME(Shader_obj::aTexCoord,"aTexCoord");
	HX_VISIT_MEMBER_NAME(Shader_obj::aColor,"aColor");
	HX_VISIT_MEMBER_NAME(Shader_obj::uSampler,"uSampler");
	HX_VISIT_MEMBER_NAME(Shader_obj::uProjectionMatrix,"uProjectionMatrix");
	HX_VISIT_MEMBER_NAME(Shader_obj::uColorMultiplier,"uColorMultiplier");
	HX_VISIT_MEMBER_NAME(Shader_obj::uColorOffset,"uColorOffset");
	HX_VISIT_MEMBER_NAME(Shader_obj::uObjectSize,"uObjectSize");
	HX_VISIT_MEMBER_NAME(Shader_obj::uTextureSize,"uTextureSize");
	HX_VISIT_MEMBER_NAME(Shader_obj::vTexCoord,"vTexCoord");
	HX_VISIT_MEMBER_NAME(Shader_obj::vColor,"vColor");
	HX_VISIT_MEMBER_NAME(Shader_obj::vertexHeader,"vertexHeader");
	HX_VISIT_MEMBER_NAME(Shader_obj::fragmentHeader,"fragmentHeader");
};

#endif

hx::Class Shader_obj::__mClass;

static ::String Shader_obj_sStaticFields[] = {
	HX_HCSTRING("uniformRegex","\xf3","\x80","\x0b","\xb7"),
	HX_HCSTRING("aPosition","\x2a","\x26","\x25","\x92"),
	HX_HCSTRING("aTexCoord","\xcf","\x8c","\x5d","\xf2"),
	HX_HCSTRING("aColor","\x42","\xe1","\x27","\xa6"),
	HX_HCSTRING("uSampler","\x13","\x15","\x29","\x75"),
	HX_HCSTRING("uProjectionMatrix","\xc5","\x5e","\x25","\xc4"),
	HX_HCSTRING("uColorMultiplier","\xcf","\xe9","\x0f","\xba"),
	HX_HCSTRING("uColorOffset","\xe1","\xda","\x17","\x0b"),
	HX_HCSTRING("uObjectSize","\xf5","\x1f","\xe4","\xaa"),
	HX_HCSTRING("uTextureSize","\xc7","\x50","\x82","\xf3"),
	HX_HCSTRING("vTexCoord","\xe4","\x29","\x2b","\x40"),
	HX_HCSTRING("vColor","\x0d","\x75","\xa6","\x0b"),
	HX_HCSTRING("vertexHeader","\x11","\xfc","\x14","\x9d"),
	HX_HCSTRING("fragmentHeader","\x7d","\x99","\xbb","\x19"),
	::String(null())
};

void Shader_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl.display.Shader","\x0f","\xdf","\x61","\xa7");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Shader_obj::__GetStatic;
	__mClass->mSetStaticField = &Shader_obj::__SetStatic;
	__mClass->mMarkFunc = Shader_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Shader_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Shader_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Shader_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Shader_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Shader_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Shader_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Shader_obj::__boot()
{
{
            	HX_STACK_FRAME("openfl.display.Shader","boot",0x4b5a5df1,"openfl.display.Shader.boot","openfl/display/Shader.hx",14,0xae8f5dcd)
HXLINE(  14)		uniformRegex =  ::EReg_obj::__new(HX_("^\\s*uniform\\s+(sampler(?:2D|Cube)|[bi]?vec[234]|float|int|bool|mat[234])\\s+(\\w+)\\s*(?:\\[(\\d+)\\])?\\s*;.*$",e1,59,d3,bc),HX_("gmi",83,87,4e,00));
            	}
{
            	HX_STACK_FRAME("openfl.display.Shader","boot",0x4b5a5df1,"openfl.display.Shader.boot","openfl/display/Shader.hx",19,0xae8f5dcd)
HXLINE(  19)		aPosition = HX_("openfl_aPosition",7b,19,f2,d0);
            	}
{
            	HX_STACK_FRAME("openfl.display.Shader","boot",0x4b5a5df1,"openfl.display.Shader.boot","openfl/display/Shader.hx",23,0xae8f5dcd)
HXLINE(  23)		aTexCoord = HX_("openfl_aTexCoord0",10,9c,05,d4);
            	}
{
            	HX_STACK_FRAME("openfl.display.Shader","boot",0x4b5a5df1,"openfl.display.Shader.boot","openfl/display/Shader.hx",27,0xae8f5dcd)
HXLINE(  27)		aColor = HX_("openfl_aColor",51,21,0d,bc);
            	}
{
            	HX_STACK_FRAME("openfl.display.Shader","boot",0x4b5a5df1,"openfl.display.Shader.boot","openfl/display/Shader.hx",32,0xae8f5dcd)
HXLINE(  32)		uSampler = HX_("openfl_uSampler0",0e,4f,96,4d);
            	}
{
            	HX_STACK_FRAME("openfl.display.Shader","boot",0x4b5a5df1,"openfl.display.Shader.boot","openfl/display/Shader.hx",36,0xae8f5dcd)
HXLINE(  36)		uProjectionMatrix = HX_("openfl_uProjectionMatrix",16,8b,ff,93);
            	}
{
            	HX_STACK_FRAME("openfl.display.Shader","boot",0x4b5a5df1,"openfl.display.Shader.boot","openfl/display/Shader.hx",40,0xae8f5dcd)
HXLINE(  40)		uColorMultiplier = HX_("openfl_uColorMultiplier",9e,72,0d,28);
            	}
{
            	HX_STACK_FRAME("openfl.display.Shader","boot",0x4b5a5df1,"openfl.display.Shader.boot","openfl/display/Shader.hx",44,0xae8f5dcd)
HXLINE(  44)		uColorOffset = HX_("openfl_uColorOffset",30,10,2f,e8);
            	}
{
            	HX_STACK_FRAME("openfl.display.Shader","boot",0x4b5a5df1,"openfl.display.Shader.boot","openfl/display/Shader.hx",49,0xae8f5dcd)
HXLINE(  49)		uObjectSize = HX_("openfl_uObjectSize",86,49,51,ed);
            	}
{
            	HX_STACK_FRAME("openfl.display.Shader","boot",0x4b5a5df1,"openfl.display.Shader.boot","openfl/display/Shader.hx",54,0xae8f5dcd)
HXLINE(  54)		uTextureSize = HX_("openfl_uTextureSize",16,86,99,d0);
            	}
{
            	HX_STACK_FRAME("openfl.display.Shader","boot",0x4b5a5df1,"openfl.display.Shader.boot","openfl/display/Shader.hx",59,0xae8f5dcd)
HXLINE(  59)		vTexCoord = HX_("openfl_vTexCoord",35,1d,f8,7e);
            	}
{
            	HX_STACK_FRAME("openfl.display.Shader","boot",0x4b5a5df1,"openfl.display.Shader.boot","openfl/display/Shader.hx",63,0xae8f5dcd)
HXLINE(  63)		vColor = HX_("openfl_vColor",1c,b5,8b,21);
            	}
{
            	HX_STACK_FRAME("openfl.display.Shader","boot",0x4b5a5df1,"openfl.display.Shader.boot","openfl/display/Shader.hx",66,0xae8f5dcd)
HXLINE(  66)		vertexHeader = ::Array_obj< ::String >::__new(8)->init(0,((HX_("attribute vec2 ",fe,43,ff,be) + ::openfl::display::Shader_obj::aPosition) + HX_(";",3b,00,00,00)))->init(1,((HX_("attribute vec2 ",fe,43,ff,be) + ::openfl::display::Shader_obj::aTexCoord) + HX_(";",3b,00,00,00)))->init(2,((HX_("attribute vec4 ",bc,45,ff,be) + ::openfl::display::Shader_obj::aColor) + HX_(";",3b,00,00,00)))->init(3,((HX_("uniform mat3 ",41,cb,75,0c) + ::openfl::display::Shader_obj::uProjectionMatrix) + HX_(";",3b,00,00,00)))->init(4,((HX_("uniform vec2 ",16,f7,a8,3d) + ::openfl::display::Shader_obj::uObjectSize) + HX_(";",3b,00,00,00)))->init(5,((HX_("uniform vec2 ",16,f7,a8,3d) + ::openfl::display::Shader_obj::uTextureSize) + HX_(";",3b,00,00,00)))->init(6,((HX_("varying vec2 ",52,87,16,2a) + ::openfl::display::Shader_obj::vTexCoord) + HX_(";",3b,00,00,00)))->init(7,((HX_("varying vec4 ",10,89,16,2a) + ::openfl::display::Shader_obj::vColor) + HX_(";",3b,00,00,00)));
            	}
{
            	HX_STACK_FRAME("openfl.display.Shader","boot",0x4b5a5df1,"openfl.display.Shader.boot","openfl/display/Shader.hx",80,0xae8f5dcd)
HXLINE(  80)		fragmentHeader = ::Array_obj< ::String >::__new(15)->init(0,((HX_("uniform sampler2D ",72,47,f0,ca) + ::openfl::display::Shader_obj::uSampler) + HX_(";",3b,00,00,00)))->init(1,((HX_("uniform vec4 ",d4,f8,a8,3d) + ::openfl::display::Shader_obj::uColorMultiplier) + HX_(";",3b,00,00,00)))->init(2,((HX_("uniform vec4 ",d4,f8,a8,3d) + ::openfl::display::Shader_obj::uColorOffset) + HX_(";",3b,00,00,00)))->init(3,((HX_("uniform vec2 ",16,f7,a8,3d) + ::openfl::display::Shader_obj::uObjectSize) + HX_(";",3b,00,00,00)))->init(4,((HX_("uniform vec2 ",16,f7,a8,3d) + ::openfl::display::Shader_obj::uTextureSize) + HX_(";",3b,00,00,00)))->init(5,((HX_("varying vec2 ",52,87,16,2a) + ::openfl::display::Shader_obj::vTexCoord) + HX_(";",3b,00,00,00)))->init(6,((HX_("varying vec4 ",10,89,16,2a) + ::openfl::display::Shader_obj::vColor) + HX_(";",3b,00,00,00)))->init(7,HX_("vec4 colorTransform(const vec4 color, const vec4 tint, const vec4 multiplier, const vec4 offset) {",a7,0a,a9,f9))->init(8,HX_("   vec4 unmultiply = vec4(color.rgb / color.a, color.a);",0f,f7,2c,dd))->init(9,HX_("   vec4 result = unmultiply * tint * multiplier;",32,67,2e,56))->init(10,HX_("   result = result + offset;",d6,2b,93,f8))->init(11,HX_("   result = clamp(result, 0., 1.);",65,22,a3,fc))->init(12,HX_("   result = vec4(result.rgb * result.a, result.a);",1e,90,43,04))->init(13,HX_("   return result;",6e,cd,02,a1))->init(14,HX_("}",7d,00,00,00));
            	}
}

} // end namespace openfl
} // end namespace display
